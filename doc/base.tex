% This file has been edited by Fredrik Lindgren, a.k.a. Wisp,
% starting from 18 December 2012 and WeiDU 231.06.

% Note added due to LGPL terms.
%
% This file was edited by Valerio Bigiani, AKA The Bigg, starting from
% 6 November 2005. All changes for this file are listed in
% diffs/doc.base.tex.diff file, as the output of a diff -Bw -c -N command.
%
% It was originally taken from Westley Weimer's WeiDU 185.

\documentclass{article}

\usepackage{hevea}
\usepackage{color}
\usepackage{index}
\usepackage{url}
\usepackage[utf8]{inputenc}
\makeindex

\def\ttref#1{\ahrefloc{#1}{\tt #1}}
\def\DEFINE#1{{\tt \bf #1}\label{#1}\index{#1}}
\def\DEFSYN#1{{\tt \bf #1}\index{#1}}
\def\t#1{{\tt #1}}
\def\CMD#1{{\tt {C:$\backslash$Program Files$\backslash$Black Isle$\backslash$BGII - SoA$\backslash$>} \color{red} \t{#1} }}
\def\Slist{{\color{red} list }}
\def\Ob{{\color{red} [ }}
\def\Oe{{\color{red} ] }}

% This is to make hevea happy (indexing)
\def\textexcl{!}
\def\textpipe{|}

\title{WeiDU Documentation}
\author{Fredrik Lindgren, a.k.a. Wisp\\
\mailto{lindgren.fredrik@gmail.com}\\
edited according to the GPL from source code by \\
Valerio Bigiani, AKA The Bigg \\
\mailto{thebigg@spellholdstudios.net} and\\
Westley Weimer\\
\mailto{weimer@cs.berkley.edu}}

\begin{document}

\maketitle
\tableofcontents

% Note: '!' becomes '_' in the final output. So COPY!REGEXP becomes
% COPY_REGEXP. This is to deal with some hideousness in the latex->html
% converter.

% \DEFINE{foo} and \ttref{foo} are used for indexing and cross-references.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{About WeiDU}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The main home page for WeiDU is:
\ahrefurl{\url{http://weidu.org/}}.
I encourage you to download the latest version.

WeiDU is designed to make it easier to write and distribute modifications
to Infinity Engine games. It can load and modify Infinity Engine resources
according to instructions you provide. WeiDU is ideal for packaging
modifications that include dialogue or that want to be compatible with
other modifications.

I'll be honest with you up front: WeiDU is initially harder to use than
some of its alternatives. However, most users report that (1) the
alternatives are insufficient because they lack features that only WeiDU
provides and (2) WeiDU grows on you over time.

You are welcome to use these utilities to make and distribute your own
Infinity Engine mods. This utility is covered by the GNU General Public
License, but you are also allowed to distribute an unmodified binary copy
of \t{WeiDU.EXE} (without the source code) with your mod if you like.

I decided to write my own Infinity Engine \ttref{DLG} and \ttref{TLK}
utilities because I was unable to get the TeamBG DLG Editor and Mass
Converter to work properly. Either they wouldn't parse the strings or they
would mangle the text or they would randomly crash ... it was bad all
around. Also, they were all GUIs. As a unix weenie I'm in love with command
line utilities and as a PL doctoral student I love making little languages
and compilers.  WeiDU was originally a family of small programs with
unimaginative names like DC, DD and TP. The more appealing term ``WeiDU''
(which rhymes with ``IDU'', Eye-Dee-You) was coined by Jason Compton and
Ghreyfain, noted BGII mod authors.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Don't Panic!}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Step-By-Step Beginner's Guide to WeiDU:

\begin{enumerate}

\item Don't Panic. Many of you are children of the GUI era. But programs
that run from the command line can be your friend, and in the long run are
often much faster and, yes, easier to use.

\item The Best Way To Learn How To Write Code In WeiDU's \ttref{D} Format
Is To {\em Read} Code Written In WeiDU's \ttref{D} Format. Start by decompiling
existing in-game \ttref{DLG}s that you understand and read through them.
Compare how they appear in WeiDU to how they appear in other BG2 editing
tools you may be more comfortable with, such as Near Infinity or Infinity
Explorer.

\item The Best Way To Learn How To Write Code In WeiDU's \ttref{D} Format
Is To {\em Read} Code Written In WeiDU's \ttref{D} Format, Part 2. A growing
number of BG2 add-on packs are being created using WeiDU. A list is
available at
\ahrefurl{\url{http://www.pocketplane.net/modlist/}}.
These
can help you understand how WeiDU's advanced features, such as dialogue
appending, script and \ttref{2DA} patching, and item/spell/creature
patching work in a ``real-world'' setting.  Make it a point to download some
of them and understand HOW they work.

\item Take a look at some of the examples in this document.
There is a lovely WeiDU tutorial (written by
Japheth) available at
\ahrefurl{\url{http://forums.pocketplane.net/index.php?topic=55.0}}.
If you
are feeling overwhelmed, start there first. It also covers installation.
Ghreyfain also has a ``how to create an NPC with WeiDU'' tutorial at
\ahrefurl{\url{http://forums.pocketplane.net/index.php?topic=52.0}}.

\item There is a WeiDU discussion board at
\ahrefurl{\url{http://forums.pocketplane.net/index.php?board=50.0}}.  The
discussion board is the best place to have your WeiDU (and mod-making)
questions answered.

\item Finally, if you are using a Mac and you want to play around with
WeiDU, check out \ahrefurl{\url{http://weidu.org/Mac.html}} for more
information on obtaining a copy of WeiDU that works under OS X.

\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{DLG}\section{\ttref{D} and \DEFINE{DLG} File Concepts}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This section is a gentle introduction to how Infinity Engine \ttref{DLG}
files are structured. First, let's use WeiDU to create
\t{SCSARLES.}\ttref{D} and take a look at the dialogue of Sir Sarles.

You may install \t{WeiDU.exe} anywhere on your system. However, I recommend
that you put it in your Baldur's Gate 2 installation directory.  However,
WeiDU will use the Windows Registry to attempt to locate your BG2 game
files.

To run the effect described, open up a DOS prompt window and change
directories to get to your BGII directory. Then just type in the
{\color{red} \tt text in red} at the DOS Prompt.

\CMD{weidu SCSARLES.DLG}

This will create a text file called \t{SCSARLES.D} in the current
directory.  Open it up with Notepad or Microsoft Word or something. It's
just a text file that describes the game dialogue.

It will look something like:
\begin{rawhtml}
<pre width="80"><font color="#219121">// creator  : c:\bgate\weidu\weidu.exe
</font><font color="#219121">// argument : SCSARLES.DLG
</font><font color="#219121">// game     : C:\Program Files\Black Isle\BGII - SoA
</font><font color="#219121">// source   : C:\Program Files\Black Isle\BGII - SoA\data\Dialog.bif
</font><font color="#219121">// dialog   : C:\Program Files\Black Isle\BGII - SoA\DIALOG.TLK
</font><font color="#219121">// dialogF  : (none)
</font>
<font color="#3159D1">BEGIN</font> <font color="#868626">~SCSARLES~</font>

<font color="#3159D1">IF</font> <font color="#868626">~NumTimesTalkedTo(0)~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> <font color="#0000FF">0</font> <font color="#219121">// from:
</font>  <font color="#3159D1">SAY</font> <font color="#0000FF">#28655</font> <font color="#219121">/* ~Who is it? Might I ask why you have disturbed my
    meditations? My creative muse must be gently awakened, and your
    stomping about is simply not conducive to this.~ [SARLES02] */</font>
  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">REPLY</font> <font color="#0000FF">#28656</font> <font color="#219121">/* ~My apologies. I will leave you to your
    thinking.~ */</font> <font color="#3159D1">GOTO</font> <font color="#0000FF">1</font>
  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">REPLY</font> <font color="#0000FF">#28657</font> <font color="#219121">/* ~I apologize, but I have come to request your
    talent on a commissioned artwork.~ */</font>
      <font color="#3159D1">DO</font> <font color="#868626">~SetGlobal("TalkedToSarles","GLOBAL",1)~</font> <font color="#3159D1">GOTO</font> <font color="#0000FF">2</font>
<font color="#3159D1">END</font>

<font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> <font color="#0000FF">1</font> <font color="#219121">// from: 0.0
</font>  <font color="#3159D1">SAY</font> <font color="#0000FF">#28661</font> <font color="#219121">/* ~Then I shall forget you were ever here. Actually, it is an
    astoundingly easy thing to do.~ */</font>
  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">DO</font> <font color="#868626">~SetNumTimesTalkedTo(0)~</font> <font color="#3159D1">EXIT</font>
<font color="#3159D1">END</font></pre>
\end{rawhtml} Dialogues in Infinity Engine games behave like finite state machines. If
you aren't familiar with the concept of a finite state machine, see
\ahrefurl{\url{http://whatis.techtarget.com/definition/0,,sid9_gci213052,00.html}} or
\ahrefurl{\url{http://www.c3.lanl.gov/mega-math/workbk/machine/mabkgd.html}}.
Each block of the form:
\begin{rawhtml}
<pre width="80">  <font color="#3159D1">IF</font> <font color="#868626">~Initial Condition~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> state1
    <font color="#3159D1">SAY</font> <font color="#868626">~Something~</font>
    <font color="#3159D1">IF</font> <font color="#868626">~Reply Condition~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">REPLY</font> <font color="#868626">~Reply Text~</font> <font color="#3159D1">GOTO</font> state2
  <font color="#3159D1">END</font></pre>
\end{rawhtml} represents a \ttref{state} (more details below). When the player starts a
conversation with an NPC, the game engine scans through all
of the \ttref{state}s in that NPC's \ttref{DLG} file in a special
\ttref{WEIGHT}ed order and picks the one with a non-empty and true "Initial
Condition". If no state has a non-empty and true "Initial Condition" then
you get that ``Bob - has nothing to say to you.'' message. Don't worry about
the weighting process for now.

The speaker (in this case, Sir Sarles) then says whatever appears after
\ttref{SAY}.  The \ttref{REPLY} lines represent responses the PC can say
back. If the "Reply Condition" is true, the player is given the option of
saying the "Reply Text" and moving to another state in the dialogue (where
Sarles will probably say something else).

Remember: \ttref{SAY} is for what the NPC says, \ttref{REPLY} is for what
the player says back. If you think carefully, you'll notice that all
dialogue in Infinity Engine games is structed in this manner.

Conditions use the same syntax as triggers do in Infinity Engine
\ttref{BCS} scripting. You will need to learn Infinity Engine scripting
before too long. \ttref{String}s are delineated by tildes or \%\%
or "" (your choice, but WeiDU uses the tilde by default).  After
\ttref{SAY} or \ttref{REPLY} or \ttref{JOURNAL} you may give two
\ttref{String}s
instead of one. The first is used with \t{DIALOG.}\ttref{TLK}, the second
is used with \t{DIALOGF.}\ttref{TLK} (foreign language version for when the
main character is female). If you do not give two \ttref{String}s, the one
\ttref{String} you gave is used for both.

You may also use raw numbers prefaced with a number sign (like \t{\#1234})
to specify a strref inside \t{DIALOG.}\ttref{TLK} directly. This is useful
when modifying existing dialogues (say, the Fate Spirit in ToB) so that you
if a foreign user installs your dialogue they will retain all of the
foreign versions of the strings you didn't change or add. Normally
the string reference numbers are put right after the \ttref{SAY} keyword
and the string text is put in comments.  The \t{--text} command-line option
causes string text to be emitted with the string number in comments.

You may also indicate that a sound file (WAV/WAVC) should be associated
with a given \ttref{String} by including its up-to-8-letter resource name in
\t{[brackets]} after the string, as in:
\begin{rawhtml}
<pre width="80">  <font color="#3159D1">SAY</font> <font color="#868626">~Hello~</font> [HELLO]
</pre>
\end{rawhtml}
Comments are C/C++ style: everything from // to the end of the line is a
comment, as is /* everything in these star-slash things */. Comments are
ignored by WeiDU. They are there for your benefit. Example:
\begin{rawhtml}
<pre width="80">  <font color="#3159D1">SAY</font> <font color="#868626">~Hello~</font> [HELLO]   <font color="#219121">// this is a comment        ... way out to here!
</font>  <font color="#3159D1">IF</font> <font color="#219121">/* this is also a comment */</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">EXIT</font>
</pre>
\end{rawhtml}
Replies can also contain actions (using the \ttref{DO} keyword) which
behave just like Infinity Engine \ttref{BCS} script actions. They can also
add Journal entries, end the dialogue or transfer to another speaker.

Examples:
\begin{rawhtml}
<pre width="80">  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> <font color="#0000FF">2</font> <font color="#219121">// from: 0.1
</font></pre>
\end{rawhtml}
This line marks the beginning of \ttref{state} 2 in a dialogue. The comment
tells you that it can be reached by the first reply \ttref{transition} from
state 0.
\begin{rawhtml}
<pre width="80">  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">REPLY</font> <font color="#868626">~My apologies. I will leave you to your thinking.~</font> <font color="#219121">// </font><font color="#0000FF">#28656</font>
      <font color="#3159D1">GOTO</font> <font color="#0000FF">1</font>
</pre>
\end{rawhtml}
This \ttref{REPLY} can always be chosen and involves the spoken text "My
apologies...". That text is string reference number 28656. If the PC
chooses that reply, it transitions to state 1.

Finally, a \ttref{transition} may also take the form:
\begin{rawhtml}
<pre width="80">  <font color="#3159D1">COPY_TRANS</font> filename label
</pre>
\end{rawhtml}
During processing, \ttref{COPY!TRANS} will be replaced by all of the
transitions from state "label" of file "filename". The copying takes place
before all other \ttref{D} actions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{{\tt D} Dialogue File Format} \label{D}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The \ttref{D} file format is a way of describing Infinity Engine dialogues
and modifications to Infinity Engine Dialogues in a portable,
easy-to-understand format. It supports foreign language translations and
allows you to describe extensions to existing game dialogues without
forcing you to describe their content. This allows you to write mods that
work with mods written by others.

The \ttref{D} file format is presented here in an extended context-free
grammar notation. If you are unfamiliar with CFGs, take a look
\ahrefurl{\url{http://www.wikipedia.com/wiki/Context-free_grammar}},
\ahrefurl{\url{http://cs.wpi.edu/~kal/PLT/PLT2.1.2.html}}
or
\ahrefurl{\url{http://www.cs.rochester.edu/users/faculty/nelson/courses/csc_173/grammars/cfg.html}}.
You don't really need to understand a CFG formally, though.

To get a real idea of how they work, use WeiDU to create JAHEIRA.D for
yourself and look at it in a text editor. You can also browse the \t{examples}
and \t{test} directories that come with WeiDU.

All of the syntax keywords are given in a {\tt UPPERCASE COURIER}.
All other keywords are symbolic. Notes:
\begin{itemize}
\item bar \Slist means "0 or more copies of bar".
\item \Ob foo \Oe means "an optional foo" or "0 or 1 copies of foo".
\item foo bar ...  means "you may repeat foo bar as often as you like here".
\end{itemize}

\begin{tabular}{cp{10in}|p{10in}}

\DEFINE{D File} & &
  A \ttref{D File} is a text file that contains a number of \ttref{D Action}s.
  \ttref{D File}s tell WeiDU how to create and modify Infinity
  Engine \ttref{DLG} files.  \\

  is & \ttref{D Action} \Slist &
  A \ttref{D File} is a list of \ttref{D Action}s. Typically the first and
  only one is \ttref{BEGIN}, which defines the content of a new dialogue.
  Other \ttref{D Action}s can be used to modify existing dialogues. \\

\\

\DEFINE{D Action} & &
  A \ttref{D Action} tells WeiDU how to create or modify Infinity Engine
  \ttref{DLG} files. \\

  is & \DEFINE{BEGIN} filename \Ob \DEFINE{nonPausing} \Oe \ttref{state} \Slist &
    \ttref{BEGIN} tells WeiDU that you are creating a new DLG file from
    scratch. Any existing DLG file with the same name will be overwritten.
    The new DLG file contains exactly the \ttref{state}s in the list.
    If you set \ttref{nonPausing} to a non-zero integer, the game will not
    ``stop time'' while the conversation takes place. By default time stops
    during conversations.  \\

  or   & \DEFINE{APPEND} \Ob \t{IF!FILE!EXISTS} \Oe filename \ttref{state} \Slist {\tt END} &
    This tells WeiDU to place the given \ttref{state}s at the end of the
    already-existing dialogue \t{filename.}\ttref{DLG}. If there is IF!FILE!EXISTS
    and the file doesn't exists, this action is skipped. \\

  or   & \DEFINE{APPEND!EARLY} \Ob \t{IF!FILE!EXISTS} \Oe filename \ttref{state} \Slist {\tt END} &
    Works like \ttref{APPEND}, but the \ttref{state}s are added early on in
    the compilation timeline (just after \ttref{BEGIN} is processed). Thus
    they can be the targets for \ttref{INTERJECT!COPY!TRANS} and friends.
    \\

  or & \DEFINE{CHAIN}
    \Ob {\tt IF} \Ob {\tt WEIGHT} {\tt \#}weight \Oe {\tt
    stateTriggerString}  {\tt THEN} \Oe \Ob \t{IF!FILE!EXISTS} \Oe
    entryFilename entryLabel \ttref{chainText} \Slist
    \ttref{chainEpilogue} &
  This instructs WeiDU to make a long conversation in which the PC can say
  nothing. This is useful when you want the NPCs to talk among themselves
  for a long time. It and its friends, \ttref{INTERJECT} and
  \ttref{INTERJECT!COPY!TRANS} can incredible time-savers when you're
  writing non-trivial dialogue. See the examples for ideas. \ttref{CHAIN}
  will only append to existing dialogues. You cannot use \ttref{CHAIN} to
  create a new DLG. If the entryFilename file is missing and there is IF!FILE!EXISTS,
  the whole CHAIN is not compiled.
  \\

  or & \DEFINE{INTERJECT} entryFilename entryLabel {\tt globalVariable}
    \ttref{chainText} \Slist
    \ttref{chainEpilogue} &
  Behaves like \ttref{CHAIN} except that all of the \ttref{chainText} is
  additionally guarded by the \ttref{transition} predicate {\tt Global("globalVariable","GLOBAL",0)} and accompanied by the action {\tt SetGlobal("globalVariable","GLOBAL",1)}. If you pick {\tt globalVariable } to be unique, this will ensure that the \ttref{chainText} is only ever seen once per game. This is useful for making interjections. \\

  or & \DEFINE{INTERJECT!COPY!TRANS} \Ob \t{SAFE} \Oe entryFilename
  entryLabel {\tt globalVariable} \ttref{chainText} \Slist &
  This behaves just like \ttref{INTERJECT} except that the
  exitFilename and exitLabel are not present. Instead, whenever the
  dialogue would pass out of the \ttref{chainText} it follows a copy
  of the \ttref{transition}s that were at the \ttref{state} with
  \ttref{stateLabel} originally. This is convenient for making quick
  interjections from NPCs that do not actually change the true flow of
  the conversation. See the \ttref{transition} \ttref{COPY!TRANS} and
  the \ahrefloc{sec-interject-copy-trans}{\t{INTERJECT!COPY!TRANS} tutorial} for more information about
  this idea. If \t{SAFE} is specified, \ttref{INTERJECT!COPY!TRANS}
  will not warn about potentially unsafe uses (use this if you know it
  is safe).
  \\

  or & \DEFINE{INTERJECT!COPY!TRANS2} \Ob \t{SAFE} \Oe entryFilename entryLabel {\tt
  globalVariable} \ttref{chainText} \Slist &
  This works just like \ttref{INTERJECT!COPY!TRANS}, except that any
  actions taken in the transitions of the state specified by entryFilename
  and entryLabel are preserved and kept with the speaker associated with
  entryFilename (rather than being mistakenly performed by your new
  speaker). See the \ahrefloc{sec-interject-copy-trans2}{\t{INTERJECT!COPY!TRANS2} tutorial}.
  \\

  or & \DEFINE{INTERJECT!COPY!TRANS3} \Ob \t{SAFE} \Oe entryFilename entryLabel {\tt
  globalVariable} \ttref{chainText} \Slist &
  This works just like \ttref{INTERJECT!COPY!TRANS}, except that all
  states in chainText get a link in the entry state, rather than only the
  first one. Expecting documentation.
  \\

  or & \DEFINE{INTERJECT!COPY!TRANS4} \Ob \t{SAFE} \Oe entryFilename entryLabel {\tt
  globalVariable} \ttref{chainText} \Slist &
  This is either \ttref{INTERJECT!COPY!TRANS3} with \ttref{INTERJECT!COPY!TRANS2}-style
  action handling, or \ttref{INTERJECT!COPY!TRANS2} with the extended
  \ttref{INTERJECT!COPY!TRANS3} state creation rules, depending at how you
  look at it.
  \\

  or   &
  \DEFINE{EXTEND!TOP}
    filename \ttref{stateLabel} \Slist \Ob {\tt \#positionNumber} \Oe
      \ttref{transition} \Slist \t{END} &
  This instructs WeiDU to add the \ttref{transition}s in list to the top of
  the \ttref{transition} list for the specified states in \t{filename.}\ttref{DLG}
  (which must already exist).

  If a \t{positionNumber} is given, WeiDU to insert the \ttref{transition}s
  just between already-existing transitions \t{\#positionNumber} and
  \t{\#positionNumber+1} in the given states for the given file. The first
  \ttref{transition} is number 1.  \\

  or & \DEFINE{EXTEND!BOTTOM} filename \ttref{stateNumber} \Slist \Ob {\tt
  \#positionNumber} \Oe \ttref{transition} \Slist \t{END} &
  Behaves just like \ttref{EXTEND!TOP} but adds the transitions to the
  bottom of the list instead.  \\

  or & \DEFINE{ADD!STATE!TRIGGER} filename \ttref{stateNumber}
    \ttref{stateTriggerString} \Ob \ttref{stateNumber} \Slist \Oe
	\ttref{dActionWhen} \Slist &
  This instructs WeiDU to add the \ttref{stateTriggerString} to all
  of the \ttref{state}s with the given \ttref{stateNumber}s in
  the file \t{filename.}\ttref{DLG} (which must already exist). This is handy for
  adding extra conditions to an existing dialogue \ttref{state}. \\

  or & \DEFINE{ADD!TRANS!TRIGGER} filename \ttref{stateNumber}
    \ttref{transTriggerString} \Ob \ahrefloc{stateNumber}{moreStateNumbers} \Slist \Oe
    \Ob \t{DO} \t{transNumber} \Slist \Oe \ttref{dActionWhen} \Slist
    &
  This instructs WeiDU to add the \ttref{transTriggerString} to all
  of the \ttref{transition}s in all of the \ttref{state}s with the given
  \ttref{stateNumber}s in the file \t{filename.}\ttref{DLG} (which must already
  exist). This is often used in conjunction with \ttref{EXTEND!BOTTOM} to
  make a new branch in an existing \ttref{state}. Use
  \ttref{ADD!TRANS!TRIGGER} to add the negation of some predicate to all of
  the existing \ttref{transition}s, then use \ttref{EXTEND!BOTTOM} to add a
  \ttref{transition} with that predicate to that \ttref{state}.
  If a list of \t{transNumber}s is specified, only those transitions
  will have \ttref{transTriggerString} added to them. If such a list is not
  specified, every transition in every specified state will be modified.
  Note that the ``first'' transition is number 0.
  \\

  or & \DEFINE{ADD!TRANS!ACTION} filename
    \t{BEGIN} \ttref{stateNumber} \Slist \t{END}
    \t{BEGIN} \t{transNumber} \Slist \t{END}
    \t{transActionString} \ttref{dActionWhen} \Slist &
  This instructs WeiDU to add the \t{transActionString} to all
  of the actions in all the \ttref{transition}s in all of the \ttref{state}s specified by the
  \t{stateNumber} list and the \t{transNumber} list. You may use
  state labels in the \t{stateNumber} list. If the \t{transNumber} list
  is empty, the text added to all transitions on all listed states.
  Note that the \t{BEGIN} and \t{END} keywords must be present, even if you
  specify an empty list of \t{transNumber}s.
  The ``first'' transition is number 0. Any out-of-bounds \t{transNumbers}
  are silently ignored. The \t{transActionString} is prepended to any
  existing action text on a per-\ttref{transition}, per-\ttref{state}
  basis.

  \\

  or & \DEFINE{REPLACE!TRANS!ACTION} filename
    \t{BEGIN} \ttref{stateNumber} \Slist \t{END}
    \t{BEGIN} \t{transNumber} \Slist \t{END}
    oldText newText \ttref{dActionWhen} \Slist &
  This instructs WeiDU to replace all instances of oldText in newText to all
  of the actions in all the \ttref{transition}s in all of the \ttref{state}s specified by the
  \t{stateNumber} list and the \t{transNumber} list. You may use
  state labels in the \t{stateNumber} list. If the \t{transNumber} list
  is empty, the text added to all transitions on all listed states.
  Note that the \t{BEGIN} and \t{END} keywords must be present, even if you
  specify an empty list of \t{transNumber}s.
  The ``first'' transition is number 0. Any out-of-bounds \t{transNumbers}
  are silently ignored.

  \\
  or & \DEFINE{REPLACE!TRANS!TRIGGER} filename
    \t{BEGIN} \ttref{stateNumber} \Slist \t{END}
    \t{BEGIN} \t{transNumber} \Slist \t{END}
    oldText newText \ttref{dActionWhen} \Slist &
  This instructs WeiDU to replace all instances of oldText in newText to all
  of the triggers in all of the \ttref{transition}s in all of the \ttref{state}s specified by the
  \t{stateNumber} list and the \t{transNumber} list. You may use
  state labels in the \t{stateNumber} list. If the \t{transNumber} list
  is empty, the text added to all transitions on all listed states.
  Note that the \t{BEGIN} and \t{END} keywords must be present, even if you
  specify an empty list of \t{transNumber}s.
  The ``first'' transition is number 0. Any out-of-bounds \t{transNumbers}
  are silently ignored.

  \\

  or & \DEFINE{ALTER!TRANS} filename
    \t{BEGIN} \ttref{stateNumber} \Slist \t{END}
    \t{BEGIN} \t{transNumber} \Slist \t{END}
    \t{BEGIN} changeWhat changeInto \Slist \t{END} &
  Fine altering of a single transition. See the \ahrefloc{sec-alter-trans}{\t{ALTER!TRANS} tutorial}.

  \\

  or & \DEFINE{REPLACE} filename \ttref{state} \Slist \t{END} &
  This instructs WeiDU to load \t{filename.}\ttref{DLG} and replace some of its
  \ttref{state}s with the new ones described in the \ttref{state} list.
  All of the \ttref{state}s should have numeric stateLabels (e.g., "5" or
  "67"). A new \ttref{state} with label \t{X} will replace the old
  \ttref{state} number \t{X}.  \\

  or & \DEFINE{SET!WEIGHT} filename \ttref{stateLabel} \tt{\#stateWeight} &
  This instructs WeiDU to destructively change the \ttref{WEIGHT} of the
  given \ttref{state} in \t{filename.}\ttref{DLG} (which must exist). This should only
  be used to patch or workaround existing dialogues. Never use
  \ttref{SET!WEIGHT} if you can help it.  \\

  or & \DEFINE{REPLACE!SAY} filename \ttref{stateLabel} \ttref{sayText} &
  This instructs WeiDU to destructively change the \ttref{sayText} of the
  given \ttref{state} in \t{filename.}\ttref{DLG} (which must exist). This should only
  be used to patch or workaround existing dialogues. Never use
  \ttref{REPLACE!SAY} if you can help it. \\

  or & \DEFINE{REPLACE!STATE!TRIGGER} filename \ttref{stateNumber}
    \ttref{stateTriggerString} \Ob \ttref{stateNumber} \Slist \Oe
	\ttref{dActionWhen} \Slist &
  This instructs WeiDU to destructively set the
  \ttref{stateTriggerString} of all of the \ttref{state}s with the given
  \ttref{stateNumber}s in the file \t{filename.}\ttref{DLG} (which must already
  exist). It should be used with caution. \\

  or & \DEFINE{REPLACE!TRIGGER!TEXT} filename oldText newText
 \ttref{dActionWhen} \Slist  &
  This instructs WeiDU to destructively replace every occurrence of oldText
  (which may be a \ttref{regexp}) in the \ttref{stateTriggerString}s and
  \ttref{transTriggerString}s of \t{filename.}\ttref{DLG} (which must exist).
  This should only be used to patch or workaround existing dialogues. Never
  use this if you can help it. \\

  or & \DEFINE{REPLACE!TRIGGER!TEXT!REGEXP} filenameRegexp oldText newText
 \ttref{dActionWhen} \Slist  &
  Just like \ttref{REPLACE!TRIGGER!TEXT} but the filename is a
  \ttref{regexp}. The .\ttref{DLG} is implied. \\

  or & \DEFINE{REPLACE!ACTION!TEXT} filename oldText newText
    \Ob moreFilenames \Oe  \ttref{dActionWhen} \Slist &
  This instructs WeiDU to destructively replace every occurrence of oldText
  (which may be a \ttref{regexp}) in the \ttref{stateActionString}s
  of \t{filename.}\ttref{DLG} (which must exist). This should only be used
  to patch or workaround existing dialogues. Never use this if you can help
  it. \\

  or & \DEFINE{REPLACE!ACTION!TEXT!REGEXP} filenameRegexp oldText newText
    \Ob moreFilenameRegexps \Oe  \ttref{dActionWhen} \Slist &
  Just like \ttref{REPLACE!ACTION!TEXT} but the filenames are
  \ttref{regexp}s. The .\ttref{DLG} is implied, do not include it in your
  \ttref{regexp}s. \\

  or & \DEFINE{REPLACE!ACTION!TEXT!PROCESS} filename oldText newText
    \Ob moreFilenames \Oe \ttref{dActionWhen} \Slist &
  This instructs WeiDU to destructively replace every occurrence of oldText
  (which may be a \ttref{regexp}) in the \ttref{stateActionString}s
  of \t{filename.}\ttref{DLG} (which must exist) with newText. However,
  newText is first compiled as a \ttref{BAF} action list. In particular,
  this means that replacing with commands like:
\begin{verbatim}
~DisplayString(Myself,@123)~
\end{verbatim}
  ... will do what you expect.  This should only be used to patch or
  workaround existing dialogues. Never use this if you can help it. \\

  or & \DEFINE{R!A!T!P!R}
    filenameRegexp oldText newText
    \Ob moreFilenameRegexps \Oe \ttref{dActionWhen} \Slist &
  Just like \ttref{REPLACE!ACTION!TEXT!PROCESS}, but the filenames are
  \ttref{regexp}s. The .\ttref{DLG} is implied. R!A!T!P!R is
  shorthand for REPLACE!ACTION!TEXT!PROCESS!REGEXP (to avoid undue scrollbars
  in the readme on a 1024x768 monitor). \\


\\

\DEFINE{dActionWhen} & defines when a D action (E.G. \ttref{ADD!TRANS!ACTION}) will
be processed or not. \\
is & \DEFSYN{IF} String & The action is processed if the element being
altered/replaced/added to contains a substring matching against the String
regexp. \\
or & \DEFSYN{UNLESS} String & The action is not processed if the element being
altered/replaced/added to contains a substring matching against the String
regexp. \\

\\

\DEFINE{chainEpilogue} & & Determines where the dialogue should flow at the
end of the \ttref{CHAIN}. \\
is & {\tt END} filename stateNumber & Transfer to the given state in the given dialogue file. \\
or & {\tt EXTERN} filename stateNumber & Transfer to the given state in the given dialogue file. \\
or & {\tt COPY!TRANS} \Ob \t{SAFE} \Oe filename stateNumber & At the end of the
\ttref{CHAIN} text, copy all transitions from the given state in the
given file. This is useful for interjections (see \ttref{INTERJECT}). If \t{SAFE} is specified, \ttref{CHAIN} will not warn about potentially unsafe uses of \t{COPY!TRANS} (use this if you know it is safe). \\
or & {\tt COPY!TRANS!LATE} \Ob \t{SAFE} \Oe filename stateNumber & Same as above, but only copy after all the other \ttref{D Action}s have been applied. \\
or & {\tt EXIT} & At the end of the \ttref{CHAIN} text, exit the dialogue.\\
or & {\tt END} \ttref{transition} \Slist & Execute the given \ttref{transition}s
after the final state in the \ttref{CHAIN}. \\

\\

\DEFINE{state} & & In Infinity Engine games, this is the fundamental unit
of dialogue. \\
is & {\tt IF} \Ob \DEFINE{WEIGHT} \t{\#weightNumber} \Oe \DEFINE{stateTriggerString} \Ob {\tt THEN} \Oe
  \Ob {\tt BEGIN} \Oe \DEFINE{stateLabel} \DEFINE{SAY} \ttref{sayText} \Ob \t{=}
  \ttref{sayText} ... \Oe \ttref{transition} \Slist \t{END} &
  When you start conversing with a creature that uses a \ttref{DLG} file, the
  Infinity Engine searches through all of the \ttref{state}s in that file
  in order of increasing \ttref{WEIGHT} and selects the first one it finds
  for which the \ttref{stateTriggerString} is both true and not empty.
  The creature then says all of the associated \ttref{sayText}. Finally,
  the \ttref{transition}s are evaluated in bottom-up (i.e., reverse) order.
  If a \ttref{transition} is found with a \ttref{transTriggerString} that
  evaluates to True and no \ttref{replyText}, that \ttref{transition} is
  immediately executed. Otherwise, all of the \ttref{transition}s are
  presented as options to the PC.

  \

  If a \ttref{stateLabel} is an integer it is called a
  \DEFINE{stateNumber}. All of the states in the \ttref{DLG} files that
  come with the original game use \ttref{stateNumber}s. Only \ttref{D}
  files use symbolic strings for \ttref{stateLabel}s.

  \

  Including more than one bit of \ttref{sayText} here is often called
  \ttref{Multisay}.

  \

  Finally, once you are familiar with the syntax you may omit the \t{THEN}
  and \t{BEGIN} keywords if you like.
  \\

or & \DEFINE{APPENDI} filename \ttref{state} \Slist \t{END} &
  This is legacy syntax that behaves just like the \ttref{D Action}
  \ttref{APPEND} but is considered a \ttref{state}. Avoid it. \\

or & \DEFINE{CHAIN2} entryFilename entryLabel
  \t{chain2Text} \Slist exitFilename exitLabel &
  This is legacy syntax that behaves somewhat like the \ttref{D Action}
  \ttref{CHAIN} but is considered a \ttref{state}. In addition,
  \t{chain2Text} is slightly different from \ttref{chainText}. Avoid
  this construction. \\

\\

\DEFINE{sayText} & & \t{sayText} and \DEFINE{replyText} are displayed to
the user as part of a dialogue. \\
is & \ttref{text} & \t{sayText} and \t{replyText} are both \ttref{text}. \\

\\

\DEFINE{transition} & & Transitions determine how dialogue flows from one
state to another. \\

is & \t{IF} \DEFINE{transTriggerString} \Ob \t{THEN} \Oe
      \ttref{transFeature} \Slist \ttref{transNext} &
    If the \ttref{transTriggerString} evaluates to true or is empty, this
    \ttref{transition} is viable. If it contains no \ttref{replyText}
    within its \ttref{transFeature} list, it is immediately taken.
    Otherwise, the \ttref{replyText} is presented as an option to the user.
    If the transition is taken, any actions in the \ttref{transFeature}
    list are performed and the dialogue flows to the point indicated by the
    \ttref{transNext}.
  \ttref{transition}s are evaluated in "reverse order". That is, the "bottom"
  or "last" response for a \ttref{state} is checked first. If its
  \ttref{transTriggerString}
  evaluates to true and it has no \ttref{REPLY} text, that transition is
  immediately taken. See \t{SAREV25A} \ttref{state} 1 for an example of a
  \ttref{state} with all kinds of \ttref{transition}s. \\

or & \t{+} \Ob \ttref{transTriggerString} \Oe \t{+} \ttref{replyText}
     \ttref{transFeature} \Slist \ttref{transNext} &
  This abbreviated syntax for transitions that would contain \ttref{REPLY}
  (which is by far the most common case) allows you to save yourself
  some time and typing. It behaves like the full form above.  \\

or & \DEFINE{COPY!TRANS} \Ob \t{SAFE} \Oe filename \ttref{stateLabel} &
    This instructs WeiDU to copy all of the \ttref{transition}s from the
    \ttref{state} with the given \ttref{stateLabel} in \t{filename.}\ttref{DLG}. This
    copying takes place before all other \ttref{D Action}s. For example,
    this is a valid \ttref{transition} list:
\begin{rawhtml}
<pre width="40"><font color="#3159D1">IF</font> <font color="#868626">~Before()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">GOTO</font> my_state
<font color="#3159D1">COPY_TRANS</font> PLAYER1 <font color="#0000FF">33</font>
<font color="#3159D1">IF</font> <font color="#868626">~After()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">EXTERN</font> SOLA <font color="#0000FF">55</font></pre>
\end{rawhtml}
    If \t{SAFE} is specified, \ttref{COPY!TRANS} will not warn about potentially unsafe uses (use this if you know it is safe). \\
or & \DEFINE{COPY!TRANS!LATE} \Ob \t{SAFE} \Oe filename \ttref{stateLabel} &
    Same as \ttref{COPY!TRANS}, but is invoked after all other \ttref{D Action}s. \\

\\

\DEFINE{transFeature} & & These are features or actions associated with
taking a transition. \\
is & \DEFINE{REPLY} \ttref{replyText} &
  If this \ttref{transition} is taken, the PC says the \ttref{replyText}.  \\
or & \DEFINE{DO} \DEFINE{stateActionString} &
  If this \ttref{transition} is taken, the \ttref{stateActionString} is
  executed.  \\
or & \DEFINE{JOURNAL} \ttref{text} &
  If this \ttref{transition} is taken, the \ttref{text} is added to the
  PC's journal. \\
or & \DEFINE{SOLVED!JOURNAL} \ttref{text} &
  If this \ttref{transition} is taken, the \ttref{text} is added to the
  ``solved'' section of the PC's journal. \\
or & \DEFINE{UNSOLVED!JOURNAL} \ttref{text} &
  If this \ttref{transition} is taken, the \ttref{text} is added to the
  ``unsolved'' section of the PC's journal. \\
or & \DEFINE{FLAGS} integer &
  This allows you to set the features associated with a transition directly
  using the binary format of \ttref{DLG} files. \\

\\

\DEFINE{transNext} & & This determines where dialogue flows after a
transition has been taken. \\
is & \DEFINE{GOTO} \ttref{stateLabel} &
  The dialogue continues at the state with label \ttref{stateLabel} in the
  same \ttref{DLG} file as the current \ttref{state}. \\
or & \DEFINE{EXTERN} \Ob \t{IF!FILE!EXISTS} \Oe filename \ttref{stateLabel} &
  The dialogue continues at the state with label \ttref{stateLabel} in the
  file \t{filename.}\ttref{DLG}. The whole transition is not compiled if there's
  \t{IF!FILE!EXISTS} and the file filename doesn't exist. \\
or & \DEFINE{EXIT} &
  The conversation ends. \\
or & \t{+} \ttref{stateLabel} &
  This is a synonym for \ttref{GOTO}. \\

\\

\DEFINE{chainText} & & This is a rapid shorthand for chaining together many
little bits of dialogue when the PC is not saying anything. \\
is & \Ob \t{IF} \ttref{transTriggerString} \t{THEN} \Oe \ttref{sayText}
      \t{=} \ttref{sayText} ... & \\
followed by &
      \Ob \t{==} \Ob \t{IF!FILE!EXISTS} \Oe fileName
      \Ob \t{IF} \ttref{transTriggerString} \t{THEN} \Oe \ttref{sayText}
      \t{=} \ttref{sayText} ... \Oe &
      The \t{==} (that's two consecutive equal signs) marks the beginning of a
      new speaker (indicated by fileName).  If the
      \ttref{transTriggerString} is true or if it is not present, this new
      speaker says all of its \ttref{sayText} in order. If the \t{IF!FILE!EXISTS}
      part is present, these lines are not compiled at all if the current file is
      not missing.
      \\
or followed by &
    \t{BRANCH} \ttref{transTriggerString} \t{BEGIN}
      \Ob \t{==} \Ob \t{IF!FILE!EXISTS} \Oe fileName
      \Ob \t{IF} \ttref{transTriggerString} \t{THEN} \Oe \ttref{sayText}
      \t{=} \ttref{sayText} ... \Oe
    \t{END} &
      As above, except that the first transTriggerString is appended to all
      existing dialogue units.\\
\\

\DEFINE{text} & & This represents strings that are shown to the player,
rather than strings that the game uses internally for predicates and
actions. \\
is & \ttref{String} \Ob \t{[WAVEFILE]} \Oe & The given string is used for both male and
female players. The optional \t{[WAVEFILE]} is the associated sound. \\

or & \ttref{String} \Ob \t{[WAVEFILE]} \Oe \ttref{String} \Ob \t{[WAVEFILE]} \Oe &
The first string and sound file are used if the PC is male, the second
string and sound file are used if the PC is female. This is useful mainly
for international versions of Infinity Engine games. \\

or & \t{!integer} \ttref{text} & \DEFINE{Forced String Reference}. As with
\ttref{text} in general, but rather than being assigned a new,
previously-unused \t{DIALOG.TLK} string entry (or merging with an existing
one that has the same \ttref{text}), this \ttref{text} is written over
\t{DIALOG.TLK} string entry \#\t{integer}. \emph{Do not use this without a real reason.}
\\
or & \ttref{reference} & \\

\\

\DEFINE{reference} & & This is a subset of \ttref{text}. \\
is & \t{\#integer} & The string with reference number \t{\#integer} from
\t{DIALOG.}\ttref{TLK} should be used unchanged. \\

or & \t{@integer} & The last definition of the translation string
\t{@integer} given in any \ttref{TRA} file should be used.\\

or & \t{( AT {\bf{"}}var{\bf{"}} )} & The last definition of the translation string
(with value defined by a variable) given in any \ttref{TRA} file should be used.\\

\\

\DEFINE{String}\label{string} & & This is how you tell WeiDU what text you want shown
to the player. For international mods or international translations, you
may use any encoding you like (that is, you are not restricted to 7-bit
characters or Latin-1 or anything like that). \\
is & {\bf{"}}abcdef{\bf{"}} & A string can be any sequence of characters not
including a " that is enclosed in ""s. \\
or & {\bf{\verb+~+}}abcdef{\bf\verb+~+} & A string can be any sequence of
characters not including a \verb+~+ that is enclosed in
{\verb+~+\verb+~+}s. \\
or & {\bf{\%}}abcdef{\bf{\%}} & A string can be any sequence of characters not
including a \% that is enclosed in \%\%s. This is handy for Big5
translations, since " and \verb+~+ can be part of Big5-encoded characters.
\\
or & {\bf{\verb+~~~~~+}}abcdef{\bf\verb+~~~~~+} & That's five consecutive
tildes on each side. A string can be any
sequence of characters not including \verb+~~~~~+ that is enclosed in
{\verb+~~~~~+}s. For example,
string \#8750 is
{\color{red}\verb`~!@#$\%^&*()_+-=[]{}\|;:'",<.>/?`}
and can be given to WeiDU as
{\verb+~~~~~+}{\color{red}\verb`~!@#$\%^&*()_+-=[]{}\|;:'",<.>/?`}{\verb+~~~~~+}
 (the content of the string is shown in red for clarity).
\\
or & \ttref{String} \t{\^{ }} \ttref{String} & String literal concatenation.
The second string is appended to the first string. No whitespace is added.
Thus \t{"hello" \^{ } "World"} is the same as \t{"helloWorld"}.

\\

\end{tabular}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Scripts}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The Infinity Engine uses scripts in a bytecode format, known as
\t{BCS}. Bytecode is not human-friendly, and the textual format
\t{BAF} was derived from \t{BCS}. WeiDU includes a \t{BAF} compiler
for turning \t{BAF} scripts into \t{BCS} scripts and a decompiler for
the reverse transformation. The \t{BCS} format will not be documented
here, but the format is described by the
\ahref{\url{https://gibberlings3.github.io/iesdp/file_formats/ie_formats/bcs.htm}}{IESDP}.

The \t{BAF} format accepted by WeiDU's compiler is documented here in an extended context-free grammar notation.

Syntactical keywords are given in a \t{UPPERCASE COURIER}.
Other keywords are symbolic, with the exception of \t{TriggerOverride} which is not symbolic and not written in uppercase. Notes:
\begin{itemize}
\item foo \Slist means zero or more copies of foo.
\item \Ob foo \Oe means an optional foo or zero or one copies of foo.
\item foo bar ... means one or more copies of foo bar.
\end{itemize}

\begin{tabular}{cp{10in}|p{10in}}
\DEFINE{BAF File}\label{BAF} & &

  A \ttref{BAF File} is a text file that contains zero or more script
  blocks. \ttref{BAF File}s are compiled into \t{BCS} files, either by
  the \ttref{COMPILE} \t{TP2} action or on the command line. \\

is & \ttref{script block} \Slist & \\

\\

\DEFINE{script block} & & \\

is & \t{IF} \ttref{script trigger} ... \t{THEN} \ttref{script response} ... \t{END} &

  If the \ttref{script trigger}(s) are true, the \ttref{script response}(s)
  are evaluated. \\

\\

\DEFINE{script trigger} & & \\

is & \Ob !\Oe\ttref{Infinity Engine trigger} &

  What constitutes an \DEFINE{Infinity Engine trigger} (trigger)
  varies between different versions of the Infinity Engine and will
  not be documented here. Refer to the right section of the
  \ahref{\url{https://gibberlings3.github.io/iesdp/scripting/triggers/index.htm}}{IESDP}.
  A preceding exclamation mark negates the trigger. \\

or & \Ob !\Oe\t{TriggerOverride}(\ttref{Infinity Engine object},\ttref{Infinity Engine trigger}) &

  \t{TriggerOverride}() is a form of syntactical sugar enabled by
  WeiDU. It does not constitute a trigger of itself, does not exist in
  \t{BCS} form and it is only available on versions of the Infinity
  Engine which implement the \t{NextObjectTrigger}()
  trigger. \t{TriggerOverride}() is compiled into
  \t{NextObjectTrigger}() and \t{NextObjectTrigger}() is decompiled
  into \t{TriggerOverride}(). Use of \t{TriggerOverride}() is
  semantically identical to use of \t{NextObjectTrigger}() but may be
  a syntactically preferable short-hand. An exclamation mark before
  \t{TriggerOverride} negates the trigger.

  What constitutes an \DEFINE{Infinity Engine object} varies between
  different versions of the Infinity Engine and will not be documented
  here. \\

\\

\DEFINE{script response} & & \\

is & \t{RESPONSE} \t{#}weight \ttref{Infinity Engine action} ... &

  weight is a non-negative integer that gives the evaluation
  probability of the response block relative to any other response
  blocks in the same \ttref{script block}. What constitutes an
  \DEFINE{Infinity Engine action} (action) varies between different
  versions of the Infinity Engine and will not be documented
  here. Refer to the right section of the
  \ahref{\url{https://gibberlings3.github.io/iesdp/scripting/actions/index.htm}}{IESDP}.
  Any time an Infinity Engine String Reference (strref) is expected by
  an action, you can use \ttref{text}. When the script is compiled,
  WeiDU will add the text as a string and insert the corresponding
  strref in its stead. \\

\end{tabular}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Command Line Options}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

WeiDU is a command-line utility. GUIs are available, but this document only
describes command-line invocation. Use the DOS Shell ("command" or "cmd")
to run WeiDU. You control its behavior by passing arguments to it on the
command line.

You invoke WeiDU by typing {\tt WeiDU} and then any number of options and
files, as described below.

Note: since it may not be obvious, if an option accepts 'X' and says to be
cumulative, if you want to apply it multiple times you have to use the following
hideousness:
\begin{verbatim}
weidu --string 1 --string 2 --string 3
\end{verbatim}
This does not apply to *-rest commands like --biff-get-rest and --force-install-rest.

Moreover, *-rest commands must be the last, EG
\begin{verbatim}
weidu --biff-get-rest sw1h01.itm --out foo
\end{verbatim}
will try to extract sw1h01.itm, --out and foo from the biffs; you have to express the above as
\begin{verbatim}
weidu --out foo --biff-get-rest sw1h01.itm
\end{verbatim}

*-list commands work like the -rest variants, except that they stop parsing for the current
switch once they find an option starting with '-'. Basically, this works like you'd expect:
\begin{verbatim}
weidu --biff-get-list sw1h01.itm --out foo
\end{verbatim}


\

\begin{tabular}{lp{10in}|p{10in}}
\multicolumn{2}{c}{ \color{red} Compiling And Decompiling } \\
\tt{FILE.}\ttref{D}   & Compile \t{FILE} to a \ttref{DLG} (dialogue file). \\
\tt{FILE.}\ttref{DLG} & Decompile \t{FILE} to a \ttref{D} (dialogue text file). \\
\t{number}            & When decompiling a \ttref{DLG} file to a \ttref{D}
file, emit only state \t{number}. You may specify this multiple times and
only the states you specify will be emitted. \\
\t{numberA}\t{-}\t{numberB} &  When decompiling a \ttref{DLG} file to a
\ttref{D} file, emit only states between \t{numberA} and \t{numberB}
(inclusive). You may specify this multiple times and only the states you
specify will be emitted. \\
\tt{FILE.}\ttref{BAF} & Compile \t{FILE} to a \ttref{BCS} (script file).  \\
\tt{FILE.}\ttref{BCS} & Decompile \t{FILE} to a \ttref{BAF} (script text file).  \\
\DEFINE{--script-style} \t{X} & Use the given \ttref{BAF}/\ttref{BCS}
scripting style. \t{X} must be \t{BG} or \t{BG1} or \t{BG2} or \t{PST} or \t{IWD} or \t{IWD1}
or \t{IWD2}. \\
\DEFINE{--transin} \t{X} &
Use {\tt FILE} as a source of translation strings
when processing \ttref{D} and \ttref{BAF} files. \\
\tt{FILE.}\ttref{TRA} & Equivalent to \ttref{--transin} \t{FILE.TRA}. \\
\\
\multicolumn{2}{c}{ \color{red} Module Packaging Input And Control} \\
{\tt FILE.}\ttref{TP}  or
\tt{FILE.}\ttref{TP2} & Read {\tt FILE} and ask the user whether to install,
reinstall or uninstall its \ttref{TP2} \ttref{Component}s. \\
\DEFINE{--yes} & Answer all \ttref{TP2} questions with 'Yes' and do not
prompt for a key to be pressed at the end of \ttref{TP2} processing. \\
\DEFINE{--uninstall}  	& Answer all \ttref{TP2} questions with 'Uninstall'
and do not prompt for a key to be pressed at the end of \ttref{TP2}
processing. \\
\DEFINE{--reinstall}  	& Re-install all \ttref{TP2} components that are
already installed and do not prompt for a key to be pressed at the end of
\ttref{TP2} processing. \\
\DEFINE{--language}  \t{X}   & Sets the \ttref{TP2} \ttref{Language} to the one
passed here. Has no effect if the value is bigger than the language count
(I.E. you'll get asked for the language, unless you gave --uninstall, --reinstall
or --force-uninstall). \\
\DEFINE{--force-install} \t{X} & installs component number X, skips the others (cumulative). \\
\DEFINE{--force-uninstall} \t{X} & uninstalls component number X, skips the others (cumulative).
If there is no --force-install, you don't get asked for the language. \\
\DEFINE{--force-install-rest} \t{X Y...} & installs component number X Y...,
skips the others (cumulative). \\
\DEFINE{--force-uninstall-rest} \t{X Y...} & uninstalls component number X Y...,
skips the others (cumulative). \\
\DEFINE{--force-install-list} \t{X Y...} & installs component number X Y...,
skips the others (cumulative). \\
\DEFINE{--force-uninstall-list} \t{X Y...} & uninstalls component number X Y...,
skips the others (cumulative). \\
\DEFINE{--quick-menu} \t{X} & installs the \ttref{QUICK_MENU} selection X. Can be combined with
--force-install and friends, but only if the latter components are defined in ALWAYS_ASK.
\\
\DEFINE{--skip-at-view} & AT!* ~VIEW this~ actions (and the extra chromosome versions like
~NOTEPAD this~) aren't processed, while still processing batch files and similia. \\
\DEFINE{--safe-exit} & Save weidu.log every time a component installation is begun.
This makes it impossible to uninstall components (don't ask), but allows the user to kill
the weidu process (E.G. closing the DOS console via the X button) without leaving the game in an
unrecoverably inconsistent state (you can [R]e or [U]ninstall the component and the game will be
consistent again). This might break with mods using overly complicated AT!* actions (basically
don't use this with Big Mods). \\
\DEFINE{--save-components-name} & Reprints weidu.log. Useful if you install with --quick-log. \\
\DEFINE{--ask-every}   & Behave as if \ttref{ASK!EVERY!COMPONENT} were
present for all \ttref{TP2} components. \\
\DEFINE{--ask-only} \t{X Y ...} & Limit the interactive installer to
only asking about components number X Y..., skipping the others
(cumulative) \\
\DEFINE{--continue}     & Continue \ttref{TP2} processing despite
\ttref{TP2 Action} errors. \\
\DEFINE{--args} \t{X}       & X will be stored in the tp2 variable \verb+%argv[n]%+, where
n is 0 for the first argument, 1 for the second, etc.

If the installation is non-interactive, said variables will be loaded from the last interactive
session. \\
\DEFINE{--args-rest} \t{X Y...} & X Y Z will be stored in the tp2 variables \verb+%argv[n]%+,
where n is 0 for the first argument, 1 for the second, etc.

If the installation is non-interactive, said variables will be loaded from the last interactive
session. \\
\DEFINE{--args-list} \t{X Y...} & X Y Z will be stored in the tp2 variables \verb+%argv[n]%+,
where n is 0 for the first argument, 1 for the second, etc.

If the installation is non-interactive, said variables will be loaded from the last interactive
session. \\
\DEFINE{--debug-assign} & Print out all values assigned to \ttref{TP2}
variables (even implicit ones created by \t{WeiDU}). \\
\DEFINE{--debug-value} & Print out all \ttref{value}s encountered in
\ttref{TP2} processing and the results they evaluate to. Among other
things, this is useful for catching parenthesis errors in your
\ttref{value}s. \\
{\tt \DEFINE{--modder} \Ob X Y \Oe \Slist} & enables the
\ttref{MODDER} mode and sets the \ttref{MODDER} option X to Y (cumulative,
-list syntax).
\\
\DEFINE{--clear-memory} & calls \ttref{CLEAR!MEMORY} after every \ttref{TP2} action.
\\
\multicolumn{2}{c}{ \color{red} Automatic Updating Options } \\
\DEFINE{--update-all} & Auto-update all \t{WeiDU} setup files (e.g.,
\t{Setup-MyMod.exe}) in the current directory. \\
\DEFINE{--noautoupdate} & If you are running \t{WeiDU} as
\t{Setup-MyMod.exe}, do not attempt to update yourself or any other mod. \\
\DEFINE{--no-auto-tp2} & Do not run \t{setup-mymod.tp2} even if \t{WeiDU} is
running as \t{setup-mymod.exe}. \\
\DEFINE{--noselfupdatemsg} & If you are running \t{WeiDU} as
\t{Setup-MyMod.exe} and it automatically updates itself, do not display a
message or ask the user to press return. \\
\\
\multicolumn{2}{c}{ \color{red} Infinity Engine Game Location Options } \\
{\tt \DEFINE{--game} X	} & Set main game directory to {\tt X}. WeiDU looks for
{\tt CHITIN.}\ttref{KEY} and {\tt DIALOG.}\ttref{TLK} and the \t{override}
directory in the main game directory (but see \ttref{--tlkin} and
\ttref{--search}). WeiDU will look in the current directory and use the
registry to find your game. If this fails, you will need to run WeiDU using
the \ttref{--game} switch to define the full path to the BG2 directory.
WeiDU will also search for BG1, IWD and PST. \\
\DEFINE{--nogame}  & Do not
load any default game files. Unless you also specified \ttref{--tlkin}, no
\t{DIALOG.TLK} will be loaded. Unless you also specified \ttref{--search},
no \t{override} directory will be used. \\
{\tt \DEFINE{--game-by-type} X} & tries to guess the game path by reading
the registry; X can be one of BG1, BG2, PST, IWD1 or IWD2. BGEE is unsupported.
\\
\DEFINE{--search} \t{X}	& Look in {\tt X} for input files (cumulative).
\t{X} is treated as an \t{override} directory and is given priority over
the default \t{override} directory. \\
\\
\multicolumn{2}{c}{ \color{red} Game Text (\ttref{TLK}) File Input} \\
\DEFINE{--use-lang} \t{X} & On multi-language games (e.g., BGEE), use the files
in lang/X/ instead of asking which lang/X/ to use. This answer is saved
and --use-lang can override a previously saved answer.\\
\DEFINE{--tlkin} \t{X} & Use {\tt X} as {\tt DIALOG.}\ttref{TLK} (instead
of looking for \t{DIALOG.TLK} in the game directory). \\
\DEFINE{--ftlkin} \t{X} & Use {\tt X} as {\tt DIALOGF.}\ttref{TLK} (instead
of looking for \t{DIALOGF.TLK} in the game directory). \\
\tt{FILE.}\ttref{TLK} & Equivalent to \ttref{--tlkin} \t{X}. \\
\DEFINE{--tlkmerge} \t{X}	& Merge strings from {\tt X} over the strings from any other loaded {\tt \t{DIALOG.}\ttref{TLK}.} \\
\\
\multicolumn{2}{c}{ \color{red} General Output Options} \\
\DEFINE{--out} \t{X} &	Emit most output files generated by command-line
options (e.g., \ttref{D}, \ttref{DLG}, kits, \ttref{--biff-get},
\ttref{BAF}, \ttref{BCS}, \ttref{--automate}, \ttref{--traify-tlk},
\ttref{--extract-kits}, \ttref{--list-biffs}, \ttref{--cmp-from},
\ttref{--dcmp-from}, etc.) to file {\tt X}. If \t{X} is a directory,
certain commands (e.g., \ttref{D}, \ttref{DLG}, \ttref{--biff-get}, etc.)
will place their output there.  Does not affect \ttref{TP2} processing. \\
\DEFINE{--append} \t{X} & Like \ttref{--out}, but if \t{X} is an existing
file then the result will be appended to it instead of overwriting it. \\
\DEFINE{--backup} \t{X} &	Backup files to directory {\tt X} before overwriting. Does not affect \ttref{TP2} processing. \\
\DEFINE{--tlkout} \t{X} & Redirect the output dialog to X. If any strings were added to or changed in the loaded \t{DIALOG.TLK}, emit \t{X} as an updated version that reflects those changes. Many operations (e.g., compiling \t{D} files, \ttref{--tlkmerge}, \ttref{STRING!SET}) can add to or modify \t{DIALOG.TLK}. If this option is not provided, the output dialog is the same as the input dialog. \\
\DEFINE{--ftlkout} \t{X} & Redirect the output dialogf to X. If any strings were added to or changed in the
loaded \t{DIALOGF.TLK}, emit \t{X} as an updated version that reflects
those changes. If this options is not provided, the output dialogf is the same as the input dialogf. \\
\DEFINE{--version} & Print version number and exit. \\
\DEFINE{--parse-check} \t{X} \t{Y} & Parses file \t{Y} as file type
\t{X} and returns 0 if the file was parsed without errors. \t{X} must
be one of \t{D}, \t{BAF}, \t{TP2}, \t{TPA}, or \t{TPP}. \\
\\
\multicolumn{2}{c}{ \color{red} Dialogue Text File (\ttref{D}) Options} \\
\DEFINE{--noheader} &	Do not emit \ttref{D} header comments. \\
\DEFINE{--nofrom} &	Do not emit \ttref{D} {\tt // from:} comments. \\
\DEFINE{--full-from} &  Generate complete {\tt // from:} comments with a
slower two-pass process. \\
\DEFINE{--nocom} & Do not emit ANY \ttref{D} or \ttref{BAF} comments. \\
\DEFINE{--text} & Emit string text with string references in comments. \\
\DEFINE{--transitive} & Follow \ttref{EXTERN} links when making \ttref{D}
files. See the tutorial on \ttref{--transitive}. \\
\DEFINE{--toplevel} & Emit only top-level dialogue states -- that is,
states with non-empty triggers. \\
\\
\multicolumn{2}{c}{ \color{red} Translation Options} \\
\DEFINE{--traify} \t{X} & Convert \t{X} (which should be a \ttref{D} or \ttref{TP2} or \ttref{BAF}) so that it uses translation references instead of literal strings. Use \ttref{--out} \t{Y} to specify a name for the transformed version of \t{X} and its new \ttref{TRA} file. \\
\t{--traify\#} \t{X} &	Use with \ttref{--traify} and \ttref{--traify-tlk}. Start the newly-created \ttref{TRA} file at translation string {\tt @X} instead of {\tt @0}. \\
\DEFINE{--traify-old-tra} \t{X} & Assumes file X to contain strings already in .tra format.
Use this over \t{--traify\#} for merging new strings in an already traified \ttref{D} or \ttref{TP2} or \ttref{BAF} file.
\\
\DEFINE{--traify-comment} & output @1 /* ~Hello~ */ rather than @1 when traifying \\
\DEFINE{--untraify-d} \t{X} & convert .D file X to use hardcoded strings... \\
\DEFINE{--untraify-tra} \t{X} & ...from TRA file X. Please note that the outcoming file
  could not work properly (if baf code embedded in a d file contains @ references, or if a string contains
  the\verb+~+ character). \\
\DEFINE{--trans} & Emit coupled \ttref{D} and \ttref{TRA} files when
  decompiling a \ttref{DLG}.  \\
\DEFINE{--transref} &	Emit string reference numbers in \ttref{TRA} files
when using \ttref{--trans}. \\
\DEFINE{--traify-tlk} & Emit a \ttref{TRA} file for the loaded \ttref{TLK} file (see \ttref{--tlkin}, \ttref{--out}, \ttref{--min} and \t{--traify\#}). \\
\DEFINE{--make-tlk} \t{X} & Create a \ttref{TLK} file from \ttref{TRA} file X (cumulative, see \ttref{--tlkout}). \\
\DEFINE{--testtrans} &	Test all specified \ttref{TRA} translation files to
see if any of them use text that is already in the loaded
\t{DIALOG.}\ttref{TLK}. If they do you can save translation effort by using
string references instead. \\
\DEFINE{--forceify} \t{X} & Convert the given \ttref{D} file to use forced
strrefs (see \ttref{--out}, \ttref{SAY}, \ttref{Forced String Reference}). \\
\\
\multicolumn{2}{c}{ \color{red} Game Text Repository (\ttref{TLK}) Options} \\
\DEFINE{--string} \t{X}&	Display string reference {\tt \#X} (cumulative). If you also specify \ttref{--min} or \ttref{--max}, all string references between \ttref{--min} (or 0) and \ttref{--max} (or infinity) will be displayed. \\
\DEFINE{--strfind} \t{X}&	Display strings that contain {\tt X} (cumulative, \ttref{regexp} allowed). \\
\DEFINE{--strapp} \t{X}&	Append string \t{X} to \t{DIALOG.}\ttref{TLK} (cumulative). \\
\\
\multicolumn{2}{c}{ \color{red} Game Archive (\ttref{BIFF}) Options} \\
\DEFINE{--list-biffs}&	Enumerate all \ttref{BIFF} files in \t{CHITIN.}\ttref{KEY}. \\
\DEFINE{--list-files}&	Enumerate all resource files in \t{CHITIN.}\ttref{KEY} \\
\DEFINE{--biff} \t{X} & Enumerate contents of \ttref{BIFF} file \t{X} (cumulative). \\
\DEFINE{--biff-get} \t{X}&	Extract resource \t{X} from game \ttref{BIFF}s (cumulative, \ttref{regexp} allowed). \\
\DEFINE{--biff-get-rest} \t{X} \t{Y} ... & Every argument given on the
command line after \ttref{--biff-get-rest} is treated as if it were
preceded by \ttref{--biff-get}. Use this command to extract multiple
different files (or \ttref{regexp}s) at once. \\
\DEFINE{--biff-get-list} \t{X} \t{Y} ... & Every argument given on the
command line after \ttref{--biff-get-rest} is treated as if it were
preceded by \ttref{--biff-get}, with the -list exception. Use this command to extract multiple
different files (or \ttref{regexp}s) at once. \\
\DEFINE{--biff-str} \t{X}&	Search all game \ttref{BIFF}s for files
containing \t{X} (\ttref{regexp} allowed). \\
\DEFINE{--biff-value} \t{X} &   Search all game \ttref{BIFF}s for files
containing value \t{X} at offset \t{ADDR}. Must be used with
\ttref{--biff-value-at}. \\
\DEFINE{--biff-value-at} \t{ADDR} & Gives the offset address for a
\ttref{--biff-value} search. \\
\DEFINE{--biff-type} \t{X}&	Limit \ttref{--biff-str} or
\ttref{--biff-value} searches to
resources of type \t{X} (cumulative). \\
\DEFINE{--biff-name} \t{X}&	When a \ttref{--biff-str} or
\ttref{--biff-value} search finds a
matching file, assume it has a strref name at offset \t{X} and print that
name out as well. \\
\DEFINE{--make-biff} \t{X} & Create \t{data/X.bif} from all files in
folder \t{X} and destructively update \t{CHITIN.KEY}. \emph{Do not use this
feature. Use MAKE!BIFF instead.} \\
\DEFINE{--remove-biff} \t{X} & Remove references to \ttref{BIFF} \t{X} and
all of its resources from \t{CHITIN.KEY}. \emph{Do not use this feature.} \\
\\
\multicolumn{2}{c}{ {\color{red} Comparison Options} (see \ttref{--out})} \\
\DEFINE{--cmp-from} \t{X}&	Emit \ttref{WRITE!BYTE}s to turn this file ... \\
\DEFINE{--cmp-to}   \t{X}&	... into this one. \\
\DEFINE{--dcmp-from}\t{X}&	Emit \ttref{REPLACE}s to turn this \ttref{DLG} file ... \\
\DEFINE{--dcmp-to}  \t{X}&	... into this one. \\
\DEFINE{--tcmp-from}\t{X}&	Compare this \ttref{TRA} file (or directory of \ttref{TRA} files)... \\
\DEFINE{--tcmp-to}  \t{X}&	... with this one (or this directory). \\
\DEFINE{--tlkcmp-from}\t{X}&	Emit \ttref{STRING!SET}s to convert this \ttref{TLK} file ... \\
\DEFINE{--tlkcmp-to}\t{X}&	... into this one. \\
\DEFINE{--tlkcmp-use-strings} & When using \ttref{--tlkcmp-from}, emit
commands of the form \t{STRING!SET "Hello" @1} instead of \t{STRING!SET \#1
@1}. \\
\DEFINE{--bcmp-from}  \t{X}&      Emit \ttref{APPLY!BCS!PATCH} to turn this
\ttref{BCS} file ... \\
\DEFINE{--bcmp-to}    \t{X}&      ... into this one. \\
\DEFINE{--bcmp-orig}  \t{X}&      Original file \t{X} to apply ... \\
\DEFINE{--bcmp-patch} \t{X}&      ... this patch to. \\
\\
\multicolumn{2}{c}{ \color{red} Range Options} \\
\DEFINE{--min} \t{X} & Lower range for some commands. See
\ttref{--traify-tlk}, \ttref{--tlkcmp-from} and \ttref{--string}.  \\
\DEFINE{--max} \t{X} & Upper range for some commands. \\
\\
\multicolumn{2}{c}{ \color{red} Automatic Module Packaging Options} \\
\DEFINE{--automate} \t{X}&   Automatically create a \ttref{TP2} file for resources in folder \t{X}. See \ttref{--out}. \\
\DEFINE{--automate-min} \t{X}& Only \ttref{--automate} string references above \t{X}. If not specified, it is assumed as 62169 (that is, the number of strings in unmodded SoA). \\
\DEFINE{--extract-kits} \t{X} & Extract all kits starting with kit \#\t{X}
and create \ttref{TP2} actions to install those kits as part of a module.  \\
\\
\multicolumn{2}{c}{ \color{red} Logging Options } \\
\DEFINE{--log} \t{X}&	Log output and details to \t{X}. \\
\DEFINE{--autolog} & 	Log output and details to \t{WSETUP.DEBUG}. \\
\DEFINE{--logapp} & 	Append to log file instead of overwriting it. \\
\end{tabular}

Finally, note that WeiDU will \emph{not} add duplicate strings to
\t{DIALOG.}\ttref{TLK}. If you instruct WeiDU to make use of the string
``Imoen'' (via \ttref{SAY} or \t{--strapp} or whatever) it will re-use any
existing definition of ``Imoen'' instead. Two strings are equivalent in
this sense only if they have the same text and the same associated sounds
(normally strings have no associated sounds).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Example Uses}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

\item Decompiling a \ttref{DLG} to a \ttref{D}

\CMD{weidu bodhi.dlg}
\begin{verbatim}
  [C:\Program Files\Black Isle\BGII - SoA\chitin.key] 182 BIFFs, 41793 resources
  [C:\Program Files\Black Isle\BGII - SoA\DIALOG.TLK] 84458 string entries
  [C:\Program Files\Black Isle\BGII - SoA\data\Dialog.bif] 2729 file entries
  [BODHI.DLG] loaded
  [.\BODHI.D] created from [BODHI.DLG]
\end{verbatim}

  This loads \t{BODHI.}\ttref{DLG} from the standard search path (i.e., the
  current directory, your override directory, then the game \ttref{BIFF}s) and
  creates \t{BODHI.}\ttref{D} from it.


\item Decompiling a \ttref{DLG} file with translations

\CMD{weidu bodhi.dlg --trans}
\begin{verbatim}
        ...
  [.\BODHI.TRA] created as translation file
  [.\BODHI.D] created from [BODHI.DLG]
\end{verbatim}

  This creates \t{BODHI.}\ttref{D} as above and also the translation file
  \t{BODHI.}\ttref{TRA} (listing all of the strings in \t{BODHI.}\ttref{D}
  in an easy-to-translate or spell-check format). \t{BODHI.}\ttref{D} will
  be created with special references to those strings.

  This is particularly useful if you are converting existing modifications
  you may have created with another tool, such as IDU, into WeiDU format.
  It allows you to both create the WeiDU \ttref{D} code and the
  translation-friendly string labels at the same time.

\item  Decompiling a \ttref{DLG} files with options

  \CMD{ weidu --nofrom bodhi.dlg --out foozle.d --text}
\begin{verbatim}
        ...
  [.\foozle.d] created from [BODHI.DLG]
\end{verbatim}

  This creates \t{foozle.d} (instead of \t{BODHI.D}) and does not put any
  \t{"// from:"} comments in \t{foozle.d}. It will include \ttref{state}s
  with \ttref{SAY}s of the form
\begin{rawhtml}
<pre width="80"> <font color="#3159D1">SAY</font> <font color="#868626">~Hello~</font> <font color="#219121">/* #1 */</font> </pre>
\end{rawhtml}
instead of
\begin{rawhtml}
<pre width="80"> <font color="#3159D1">SAY</font> <font color="#0000FF">#1</font> <font color="#219121">/* ~Hello~ */</font> </pre>
\end{rawhtml}

\item  Decompiling multiple \ttref{DLG} files

  \CMD{ weidu bodhi.dlg jaheira.dlg --out test}
\begin{verbatim}
        ...
  [test\JAHEIRA.D] created from [JAHEIRA.DLG]
  [test\BODHI.D] created from [BODHI.DLG]
\end{verbatim}

  This loads \t{BODHI.DLG} and \t{JAHEIRA.DLG} and creates \t{BODHI.D} and
  \t{JAHEIRA.D}. The optional
  \t{--out test} argument instructs WeiDU to put the resulting \ttref{D}
  files in the \t{test} directory.

\item  Compiling a \ttref{D} file

  \CMD{ weidu bodhi.d}
\begin{verbatim}
        ...
  [bodhi.d] parsed
  [BODHI.DLG] saved       135 states, 259 trans, 16 strig, 66 ttrig, 54 actions
\end{verbatim}

  This loads and parses bodhi.d and then executed all instructions in it.
  This \t{bodhi.d} file just defines \t{BODHI.DLG}, which is created. If
  \t{bodhi.d} contains strings that do not occur in \t{DIALOG.}\ttref{TLK},
  these strings will be added as new string references.

\item  Compiling multiple \ttref{D} files

  \CMD{ weidu ppworker.d bodhi.d --out test}
\begin{verbatim}
        ...
  [bodhi.d] parsed
  [ppworker.d] parsed
  [BODHI.DLG] saved       135 states, 259 trans, 16 strig, 66 ttrig, 54 actions
  [PPWORKER.DLG] saved    33 states, 81 trans, 4 strig, 12 ttrig, 10 actions
\end{verbatim}

  This creates \t{test/BODHI.DLG} and \t{test/PPWORKER.DLG} based on the
  instructions in \t{bodhi.d} and \t{ppworker.d}.

\item  Compiling a \ttref{D} file that defines many \ttref{DLG} files

  \CMD{ weidu examples/sola/solae1.d}
    \\ OR \\
  \CMD{ weidu examples$\backslash$sola$\backslash$solae1.d}
\begin{verbatim}
        ...
  [examples/sola/solae1.d] parsed
  [SOLA.DLG] loaded
  [SOLA.DLG] saved        336 states, 401 trans, 64 strig, 18 ttrig, 125 actions
  [SOLAE1.DLG] saved      36 states, 49 trans, 1 strig, 11 ttrig, 1 actions
  [SOLAE2.DLG] saved      3 states, 3 trans, 0 strig, 0 ttrig, 0 actions
  [SOLAE3.DLG] saved      2 states, 2 trans, 0 strig, 0 ttrig, 0 actions
  [SOLAE4.DLG] saved      3 states, 3 trans, 1 strig, 0 ttrig, 0 actions
  [SOLAE5.DLG] saved      2 states, 2 trans, 0 strig, 0 ttrig, 0 actions
  [SOLAE6.DLG] saved      4 states, 5 trans, 0 strig, 2 ttrig, 0 actions
\end{verbatim}

  It just so happens that \t{solae1.d} \ttref{APPEND}s text to
  \t{SOLA.DLG} and
  creates \t{SOLAE1.DLG}, \t{SOLAE1.DLG},
  \t{SOLAE3.DLG}, ..., \t{SOLAE6.DLG}. You could
  have put them all in the override directory with \t{--out override}. You
  may use the forward slash (/) or the backslash ($\backslash$) for
  directories.

\item  Compiling a \ttref{D} file that uses a \ttref{TRA} file

  \CMD{ weidu examples/sola/solafoe.d --transin examples/sola/solafoe.tra}
  \\ OR \\
  \CMD{ weidu examples/sola/solafoe.d examples/sola/solafoe.tra}
\begin{verbatim}
        ...
  [examples/sola/solafoe.tra] parsed (15 translation strings)
  [examples/sola/solafoe.d] parsed
  [SOLA.DLG] loaded
  [SOLA.DLG] saved        336 states, 401 trans, 65 strig, 18 ttrig, 124 actions
  [SOLAFOE.DLG] saved     11 states, 14 trans, 1 strig, 2 ttrig, 1 actions
\end{verbatim}

  It happens that \t{solafoe.d} uses 15 strings from a translation file,
  \ttref{APPEND}s to \t{SOLA.DLG} and creates
  \t{SOLAFOE.DLG}. You may use \t{--transin} to
  specify a translation file or (if it ends in \ttref{TRA}) just throw it
  on the command line. If you include multiple \ttref{TRA} files, the last
  one to define a particular string index wins for that string. They need
  not all cover the same set.

\item  Displaying String References

  \CMD{ weidu --string 123 --strfind understudy --strfind acid.*rows}
\begin{verbatim}
        ...
  [C:\Program Files\Black Isle\BGII - SoA\chitin.key] 182 BIFFs, 41793 resources
  [C:\Program Files\Black Isle\BGII - SoA\DIALOG.TLK] 84458 string entries
  String #123 is ~Haer' Dalis, all of you, stop them!~
  String #6763 is ~Acid Arrows~
  String #11662 is ~Biff The Understudy~
        ...
\end{verbatim}

  This displays string \#123 and all strings that contain the string
  "understudy" and all strings that match the regular expression
  (\ttref{regexp}) "acid.*rows". Note that case does not matter.

\item  Updating \t{\t{DIALOG.}\ttref{TLK}} Manually

  \CMD{ weidu --strapp ANewString --tlkout happy.tlk}
\begin{verbatim}
  [C:\Program Files\Black Isle\BGII - SoA\DIALOG.TLK] 84458 string entries
  [.\happy.tlk] created, 84459 string entries
\end{verbatim}

  Not much to say here. String reference \#84459 in \t{happy.tlk} is now
  ``{\tt ANewString}''.

\item  Listing \ttref{BIFF} Contents

  \CMD{ weidu --biff data$\backslash$dialog.bif}
\begin{verbatim}
        ...
  [data\Dialog.bif] contains    ABELA.DLG at index 0
  [data\Dialog.bif] contains    ACHEN.DLG at index 1
        ...
\end{verbatim}

  This shows all of the resources (e.g., \t{ACHEN.DLG} is a resource) that
  are contained in \t{data$\backslash$Dialog.bif}.

\item  Extracting \ttref{BIFF} Contents

  \CMD{ weidu --biff-get dragred.cre }
\begin{verbatim}
  [C:\Program Files\Black Isle\BGII - SoA\chitin.key] 182 BIFFs, 41793 resources
  [C:\Program Files\Black Isle\BGII - SoA\DIALOG.TLK] 84458 string entries
  [C:\Program Files\Black Isle\BGII - SoA\data\Creature.bif] 3194 file entries
  [.\dragred.cre] 1776 bytes, created from [C:\Program Files\Black Isle\BGII - SoA\data\Creature.bif]
\end{verbatim}

  This grabs Firkraag's dragon-form \ttref{CRE} creature file from the game
  \ttref{BIFF}s and saves it in the current directory.

\item  Extracting \ttref{BIFF} Contents with Regular Expressions

  \CMD{weidu --biff-get sper.*itm}
\begin{verbatim}
  [.\chitin.key] loaded, 590551 bytes
  [.\chitin.key] 182 BIFFs, 41793 resources
  [.\DIALOG.TLK] loaded, 10154904 bytes
  [.\DIALOG.TLK] 77666 string entries
  [.\data\Items.bif] loaded, 659688 bytes
  [.\data\Items.bif] 1990 file entries
  [.\SPER01.ITM] 266 bytes, created from [.\data\Items.bif]
  [.\SPER02.ITM] 314 bytes, created from [.\data\Items.bif]
  [.\SPER03.ITM] 362 bytes, created from [.\data\Items.bif]
  [.\SPER04.ITM] 322 bytes, created from [.\data\Items.bif]
  [.\SPER05.ITM] 266 bytes, created from [.\data\Items.bif]
  [.\SPER06.ITM] 266 bytes, created from [.\data\Items.bif]
  [.\SPER07.ITM] 554 bytes, created from [.\data\Items.bif]
  [.\SPER08.ITM] 314 bytes, created from [.\data\Items.bif]
  [.\SPER09.ITM] 314 bytes, created from [.\data\Items.bif]
  [.\SPER10.ITM] 362 bytes, created from [.\data\Items.bif]
  [.\data\25Items.bif] loaded, 222370 bytes
  [.\data\25Items.bif] 479 file entries
  [.\SPER11.ITM] 314 bytes, created from [.\data\25Items.bif]
  [.\SPER12.ITM] 1610 bytes, created from [.\data\25Items.bif]
  [.\SPERMEL.ITM] 890 bytes, created from [.\data\25Items.bif]
\end{verbatim}

  This one assumes that the game is in the current directory and asks for
  every spear item in the game. Note that \t{--biff-get} uses regular
  expressions (\ttref{regexp}), not DOS-style wildcards. Note also that
  \t{--biff-get} does not look in the override directory. Finally, if
  you are using a Mac (or otherwise running unix) you'll want to put the
  regular expression in double quotes, like so:
  \CMD{weidu --biff-get "sper.*itm"}

\item  Searching \ttref{BIFF} Contents

  \CMD{ weidu --biff-type CRE --biff-str SPWI911}
\begin{verbatim}
        ...
  LICH01.CRE in [data\Creature.bif] matches
  HLKANG.CRE in [data\Creature.bif] matches
        ...
\end{verbatim}

  This finds all \ttref{CRE} files that contain the string "SPWI911", which is
  equivalent to finding all enemy mages that know the spell Meteor Swarm
  (which has resource name "SPWI911"). You could also try something like:

  \CMD{ weidu --biff-type BCS --biff-str Terminsel}
\begin{verbatim}
        ...
  AR0300.BCS in [data\Scripts.bif] matches
  AR0308.BCS in [data\Scripts.bif] matches
  JAHEIRA.BCS in [data\Scripts.bif] matches
        ...
\end{verbatim}

  to find all of the game scripts that include a variable that includes the
  substring "Terminsel". As you would expect, Jaheira shows up. Note that
  these searches are moderately time-consuming (e.g., searching all scripts
  takes about 20 seconds).

\item  Converting one \ttref{TLK} file to another

  \CMD{ weidu --tlkcmp-from DIALOG.TLK --tlkcmp-to dialog-asc.tlk }
\begin{verbatim}
    ...
  [DIALOG.TLK] loaded, 8692747 bytes
  [DIALOG.TLK] 74107 string entries
  [dialog-asc.tlk] loaded, 10211578 bytes
  [dialog-asc.tlk] 82805 string entries
  WARNING: DIALOG.TLK has 74107 entries, dialog-asc.tlk has 82805 entries
          STRING_SET 70866 ~Babau~ []
          STRING_SET 70867 ~Babau~ []
\end{verbatim}

This compares all strings in common between two \t{\t{DIALOG.}\ttref{TLK}} files and
generates a list of \ttref{STRING!SET} \ttref{TP2} entries to convert the
\ttref{TLK} file named in \t{--tlkcomp-from} into the \ttref{TLK} file named in
\t{--tlkcomp-to}.  In this case, WeiDU indicates there are two differences in
the strings shared between a standard ToB \ttref{TLK} file and an Ascension
Classic \ttref{TLK} file: strings 70866 and 70867 were changed to "Babau".
Also note that the Ascension Classic \ttref{TLK} file has more entries (82805
compared to 74107).

If you have made a large number of manual changes to a \ttref{TLK} file
(such as grammar/spelling corrections, or other dialogue tweaks), this is a
handy way to generate install-ready scripting to apply those changes to an
end user's version of BG2.

Note that the use of \t{--out} will be helpful for a long list.

  \CMD{ weidu --tlkcmp-from DIALOG.TLK --tlkcmp-to dialog-asc.tlk --out mylist.txt }

This will make a new \t{file mylist.txt} file that contains the
\ttref{STRING!SET} parts of the output, which can then be put into a
\ttref{TP2} file.

\item  Automating File Descriptions

\CMD{weidu --automate MyMod/SomeFolder --append MyMod.tp2}

WeiDU's \t{--automate} feature can save you oodles of time, so you probably
will want to learn how to use it.  It's rather simple when you get the hang
of it (but everything is right?).

Suppose you have just created some items, some spells and some creatures
and some areas for you mod and you want to distribute them to others using
WeiDU.  You could manually write out string patching code by hand for each
resource. Or you can get WeiDU to do it automatically.

WeiDU will scan every item, spell and creature inside the given folder (in
this example, the folder is \t{MyMod/SomeFolder}) and emit \ttref{TP2}
commands to \ttref{COPY} those resources from that folder into the
\t{override} folder. In addition, each resource's current strings (like
item descriptions and monster names) will be loaded from your \ttref{TLK}
file and used to patch that resource as it is copied.

For example, the output of \t{--automate} on a folder that contains a
potion of extra healing looks like this:

\begin{verbatim}
COPY ~MyMod/SomeFolder/potn52.itm~  ~override/potn52.itm~
  SAY NAME ~Potion~
  SAY NAME2 ~Potion of Extra Healing~
  SAY UNIDENTIFIED_DESC ~Potions are typically found in ceramic, crystal, glass,
    or metal flasks or vials.  Flasks or other containers generally contain
    enough fluid to provide one person with one complete dose to achieve the
    effects of the potion.~
  SAY DESC ~When wholly consumed, this potion restores 27 hit points to the
    person. The effect is instantaneous and the potion is destroyed in the
    process.~
  SAY 0xde ~Gulp!~ [GULP]
\end{verbatim}

And there you have it, apparently there is a substitute for hard work.

\item  Converting Between \ttref{TLK} and \ttref{TRA} Files

Some translators who are using WeiDU to translate non-WeiDU mods find it
handy to be able to convert between \ttref{TLK} and \ttref{TRA} files.

First, let's create a \ttref{TRA} file:

  \CMD{ weidu --traify-tlk --min 2000 --max 2002 }
\begin{verbatim}
        ...
  @2000  = ~Indeed! It's been quite tasty so far. Listen, we're not here to
  devour everything. In fact, we'd like to help a little girl named
  Jaella.~
  @2001  = ~No, we haven't. We will devour you if you don't tell us what we
  need to know.~
  @2002  = ~Let us stop this charade. I'm only here to ask you a few
  questions.~
        ...
\end{verbatim}

You may also extract only those strings matching a \ttref{regexp}:

  \CMD{ weidu --traify-tlk --strfind lawyer }
\begin{verbatim}
        ...
  @36568 = ~Honor-bound and honor-branded, then, is it?  Very well, lawyer,
  you have set me free and for that I thank you.~
        ...
\end{verbatim}

Finally, you may redirect the output to a file using {\tt --out} and
read from a different \ttref{TLK} file by adding it on the command line.

Once you have a \ttref{TRA} file with a few entries you can create a
\ttref{TLK} file from it:

  \CMD{ weidu --make-tlk my.tra --tlkout new.tlk }
\begin{verbatim}
  [c:\src\weidu\weidu.exe] WeiDU version 109
  [C:\Program Files\Black Isle\BGII - SoA/chitin.key] 182 BIFFs, 41793
  resources
  [C:\Program Files\Black Isle\BGII - SoA/dialog.tlk] 82405 string entries
  [my.tra] parsed
  [my.tra] has 100 translation strings
  New TLK will have 200 entries
  [new.tlk] created, 200 string entries
\end{verbatim}

String {\tt @1} in your \ttref{TRA} file will become string reference {\tt
\#1} in the \ttref{TLK} file. If your \ttref{TRA} file has ``holes'' the new
\ttref{TLK} file will have blank entries. You may specify {\tt --make-tlk}
multiple times: the last \ttref{TRA} file to define a translation string
determine that string reference.

\item Viewing Banter Offline with \DEFSYN{--transitive}

\CMD{ weidu --nocom --text --transitive banomen.dlg }

The \t{--transitive} flag tells WeiDU to follow \ttref{EXTERN}
references when emitting \ttref{D} files. So the resulting \t{BANOMEN.D}
file has lines like this:

\begin{verbatim}
IF WEIGHT #31 ~InParty("Edwin")
See("Edwin")
Gender("Edwin",FEMALE)
!StateCheck("Edwin",STATE_SLEEPING)
Global("BAnomen1","LOCALS",0)~ THEN BEGIN 10
  SAY ~Hey, Edwina!  I shall be your champion at the next tournament that
  we come to if only you give me a piece of your robe, uh, that is, dress
  to adorn my shield.~ [ANOMEN49]
  IF ~~ THEN DO ~SetGlobal("BAnomen1","LOCALS",1)~ EXTERN ~BEDWIN~ 104
END

IF ~~ THEN BEGIN BEDWIN 104
  SAY ~(My condition draws fools like flies to honey).  Silence, you idiot!
  You've a death wish that is larger than your swollen head.~ [EDWINW39]
  IF ~~ THEN GOTO 11
END

IF ~~ THEN BEGIN 11
  SAY ~Fair Edwina, I am truly bereft by your non-acceptance.  It is tragic
  when a knight has no fair maiden to moon over.  Heh he he...~
  IF ~~ THEN EXIT
END
\end{verbatim}

Note that both lines from both Edwin and Anomen are presented. The
resulting ``D'' file is not valid in that it cannot be fed back to WeiDU
directly, but it should make it easier for you to read all of the jokes
offline.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{WeiDU Tutorials}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This section includes tutorials on specific parts of WeiDU. Many of them
were contributed by users like you.

\subsection{\t{Multisay}}
\label{Multisay}
This tutorial was thoughtfully provided by Jason Compton.

Although a single \ttref{SAY} line can be of any length, for style purposes
(particularly in BG2) it is considered good form to break up very large
lines into smaller chunks.

One can easily create a series of simple \ttref{SAY} blocks, one doing
\ttref{GOTO} to the next, but if there are no special conditions being
checked or actions being taken, you can very easily string several lines
together.

Let's say you have a scenery NPC teaching a lesson about the Bill of Rights
to the US Constitution.
\begin{rawhtml}
<pre width="80"><font color="#3159D1">BEGIN</font> TEACHER

<font color="#3159D1">IF</font> <font color="#868626">~NumTimesTalkedTo(0)~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> constitution_1
  <font color="#3159D1">SAY</font> <font color="#868626">~On September 25, 1789, the First Congress of the United States
    therefore proposed to the state legislatures 12 amendments to the
    Constitution that met arguments most frequently advanced against it. The
    first two proposed amendments, which concerned the number of constituents
    for each Representative and the compensation of Congressmen, were not
    ratified. Articles 3 to 12, however, ratified by three- fourths of the
    state legislatures, constitute the first 10 amendments of the
    Constitution, known as the Bill of Rights.~</font>
  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">EXIT</font>
<font color="#3159D1">END</font> </pre>
\end{rawhtml}
This is a perfectly valid block of dialogue, but it is extremely long, and
would likely scroll out of the text window for players with lower
resolution.

Rather than break each sentence up into a new explicit \ttref{state}, we
can use \ttref{Multisay} and save a lot of typing. \ttref{Multisay} is
invoked with the \t{=} (equals) sign, which tells WeiDU that, "the current
speaker should say another line here."

Here's how that \ttref{D} \ttref{state} would look with \ttref{Multisay}:
\begin{rawhtml}
<pre width="80"><font color="#3159D1">IF</font> <font color="#868626">~NumTimesTalkedTo(0)~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> constitution_1
  <font color="#3159D1">SAY</font> <font color="#868626">~On September 25, 1789, the First Congress of the United States
  therefore proposed to the state legislatures 12 amendments to the
  Constitution that met arguments most frequently advanced against it.~</font>
      =
  <font color="#868626">~The first two proposed amendments, which concerned the number of
  constituents for each Representative and the compensation of Congressmen,
  were not ratified.~</font>
      =
  <font color="#868626">~Articles 3 to 12, however, ratified by three-fourths of the state
  legislatures, constitute the first 10 amendments of the Constitution,
  known as the Bill of Rights.~</font>
  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">EXIT</font>
<font color="#3159D1">END</font>
</pre>
\end{rawhtml}
This will create three dialogue \ttref{state}s, separated by simple "click
to continue" transitions.

And that's \ttref{Multisay} in a nutshell. Note that (as always with WeiDU)
the line break and spacing before and after the \t{=} are totally optional,
and used here only for illustration.
\begin{rawhtml}
<pre width="80"><font color="#3159D1">SAY</font> <font color="#868626">~One~</font> = <font color="#868626">~Two~</font> = <font color="#868626">~Three~</font> </pre>
\end{rawhtml}
is perfectly valid as well.

You may \ttref{Multisay} inside almost any \ttref{state}, so you may use it
within an \ttref{APPEND} \ttref{D Action}. This is valid:
\begin{rawhtml}
<pre><font color="#3159D1">APPEND</font> J#KLSYJ
  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> Renal1_1
    <font color="#3159D1">SAY</font> <font color="#868626">~All right, CHARNAME. I can accept that... you are right, there
    are bigger issues to consider.~</font>
      =
    <font color="#868626">~But I hope you do understand why I said something, why it would be
    upsetting to have someone so close to me, in a role like that.~</font>
    <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">EXIT</font>
  <font color="#3159D1">END</font>                            <font color="#219121">// end of state Renal1_1
</font><font color="#3159D1">END</font>                             <font color="#219121">// end of APPEND J#KLSYJ
</font></pre>
\end{rawhtml}
However, you {\em cannot} use Multisay inside \ttref{REPLACE}, because the
nature of \ttref{REPLACE} is to change (that is, replace) a {\em single}
\ttref{state}, while \ttref{Multisay}'s nature is to create
multiple \ttref{state}s.

\subsection{\ttref{CHAIN}}
This tutorial was thoughtfully provided by Jason Compton.

\ttref{CHAIN} is an extension of the Multisay concept, simply with multiple
participants. If you have two NPCs bantering back and forth for a prolonged
period of time, and you do not need to do any special condition checks or
actions as they babble, it can get very tedious to set up a separate
\t{IF}/\t{THEN}/\t{BEGIN}/\ttref{SAY} block for each line.

Imagine a conversation like this:

\begin{itemize}
\item Kelsey: Imoen, what do you like on your pizza?
\item Imoen: Oregano.
\item Imoen: Oh, and maybe with a little basil mixed in.
\item Kelsey: Well, yeah, but anything else?
\item Imoen: Sauce is good.
\item Kelsey: (laughs) You're not being very helpful, Imoen.
\item Imoen: Crust. I like crust on my pizza. Cooked crust is better.
\item Kelsey: Do you want me to make you this pizza or not?
\item Kelsey: It WAS your idea.
\item Imoen: I can't decide. Never mind, I'm just gonna have yogurt.
\item Kelsey: (sigh)
\end{itemize}

If you wanted to add this witty little banter to your game, you could do it
with 11 \ttref{APPEND} blocks for each line, or save a little time doubling
up the back-to-back Imoen and Kelsey lines with \ttref{Multisay} inside
their \ttref{APPEND}s, so you'd only need 9. In fact, you could get away
with 2 \ttref{APPEND} blocks (remember that the states don't have to appear
in the order they are spoken, so you could mention all of Kelsey's lines
first and then all of Immy's as long as the labels thread up the
conversation correctly), one with 5 \ttref{state} declarations and one 4. But
there's an {\em even better} way, and that's to use \ttref{CHAIN}. It works
very much like \ttref{Multisay}. You use \t{=} to indicate that the current
speaker should speak again, and \t{==} (that's two consecutive equal signs)
to indicate that a new speaker should take over.

Note that as of WeiDU 82, \ttref{CHAIN} can now define \ttref{state} triggers,
perform \ttref{DO} actions, and end with an \ttref{EXIT} or
\ttref{COPY!TRANS}. This means that for most simple NPC/NPC banters, where
the PC does not have an opportunity to speak, you no longer need to use
anything else.

Watch and see how this dialogue works using a \ttref{CHAIN}.
\begin{rawhtml}
<pre width="80"><font color="#3159D1">CHAIN</font>
  <font color="#3159D1">IF</font> <font color="#868626">~Global("KelseyImoenPizza","LOCALS",0)
      InParty("Imoen2")
      See("Imoen2")
      !StateCheck("Imoen2",STATE_SLEEPING)~</font> <font color="#3159D1">THEN</font> BJKLSY pizzachain
  <font color="#868626">~Imoen, what do you like on your pizza?~</font>
<font color="#3159D1">DO</font> <font color="#868626">~SetGlobal("KelseyImoenPizza","LOCALS",1)~</font>
  == IMOEN2J
  <font color="#868626">~Oregano.~</font>
  =
  <font color="#868626">~Oh, and maybe with a little basil mixed in.~</font>
  == BJKLSY
  <font color="#868626">~Well, yeah, but anything else?~</font>
  == IMOEN2J
  <font color="#868626">~Sauce is good.~</font>
  == BJKLSY
  <font color="#868626">~(laughs) You're not being very helpful, Imoen.~</font>
  == IMOEN2J
  <font color="#868626">~Crust. I like crust on my pizza. Cooked crust is better.~</font>
  == BJKLSY
  <font color="#868626">~Do you want me to make you this pizza or not?~</font>
  =
  <font color="#868626">~It WAS your idea.~</font>
  == IMOEN2J
  <font color="#868626">~I can't decide. Never mind, I'm just gonna have yogurt.~</font>
  == BJKLSY
  <font color="#868626">~(sigh)~</font>
<font color="#3159D1">EXIT</font> </pre>
\end{rawhtml}
Note how this dialogue works.

We use the \ttref{CHAIN} statement to define the state trigger (the
starting conditions that must be true) and assign it to BJKLSY.DLG. The
"pizzachain" label is mostly just for internal reference. Kelsey delivers
the first line, then we use \t{==} \t{IMOEN2J} to allow her to answer,
"Oregano." Then, we can use the single = to indicate that the current
speaker (Imoen) has two consecutive lines.

Then it's Kelsey's turn to speak, so we use \t{== BJKLSY} to tell WeiDU to
tell WeiDU to switch to the {\em other} speaker (which is Kelsey, since we
specified \t{BJKLSY}).  They banter back and forth for a while, and then
when it is Kelsey's turn to have back-to-back lines \t{Do you want me to
make you this pizza or not?} and \t{It WAS your idea.}, we separate with a
single \t{=} to indicate that the current speaker (Kelsey) has two
consecutive lines.

After Kelsey's final, exasperated sigh, we use the \ttref{EXIT} command to
terminate the \ttref{CHAIN}, and exit the dialogue.

And that's all you need to know to use \ttref{CHAIN}. It saves a {\em
tremendous} amount of time over setting up individual \ttref{APPEND}
blocks, even \ttref{Multisay} blocks, for each NPC.

Advanced \ttref{CHAIN}ing:

You may include \ttref{DO} actions and conditionals inside
\ttref{chainText}, as in:
\begin{rawhtml}
<pre width="80"><font color="#3159D1">CHAIN</font>
  <font color="#3159D1">IF</font> <font color="#868626">~Global("KelseyImoenPizza","LOCALS",0)
      InParty("Imoen2")
      See("Imoen2")
      !StateCheck("Imoen2",STATE_SLEEPING)~</font> <font color="#3159D1">THEN</font> BJKLSY pizzachain
  <font color="#868626">~Imoen, what do you like on your pizza?~</font>
<font color="#3159D1">DO</font> <font color="#868626">~SetGlobal("KelseyImoenPizza","LOCALS",1)~</font>
  == IMOEN2J
    <font color="#868626">~Oregano.~</font>
    =
    <font color="#868626">~Oh, and maybe with a little basil mixed in.~</font>

  == BJKLSY
    <font color="#868626">~Well, yeah, but anything else?~</font>

  == IMOEN2J
    <font color="#868626">~Sauce is good.~</font>

    == BJKLSY   <font color="#3159D1">IF</font> <font color="#868626">~PartyHasItem("pepperoni")~</font> <font color="#3159D1">THEN</font>
      <font color="#868626">~Look, we HAVE pepperoni. Why don't I just use that? I'll eat it,
      anyway. If you don't like it, have yogurt instead.~</font>

    == IMOEN2J  <font color="#3159D1">IF</font> <font color="#868626">~!PartyHasItem("pepperoni")~</font> <font color="#3159D1">THEN</font>
      <font color="#868626">~Crust. I like crust on my pizza. Cooked crust is better.~</font>
    == BJKLSY <font color="#3159D1">IF</font> <font color="#868626">~!PartyHasItem("pepperoni")~</font> <font color="#3159D1">THEN</font>
      <font color="#868626">~Do you want me to make you this pizza or not?~</font>
      =
      <font color="#868626">~It WAS your idea.~</font>

    == IMOEN2J  <font color="#3159D1">IF</font> <font color="#868626">~!PartyHasItem("pepperoni")~</font> <font color="#3159D1">THEN</font>
      <font color="#868626">~I can't decide. Never mind, I'm just gonna have yogurt.~</font>
    == BJKLSY <font color="#3159D1">IF</font> <font color="#868626">~!PartyHasItem("pepperoni")~</font> <font color="#3159D1">THEN</font>
      <font color="#868626">~(sigh)~</font>
<font color="#3159D1">EXIT</font></pre>
\end{rawhtml}
In this case, the dialogue changes if the party has the pepperoni item. If
it does, Kelsey says the \t{we HAVE pepperoni} and then \t{(sigh)} and then
the dialogue ends. If not, the dialogue works as before. The
\ttref{chainText} lines with \t{IF}s in them are only spoken if their
conditionals are true.

\subsection{\ttref{COPY!TRANS}}

This tutorial was thoughtfully provided by Jason Compton.

There are some complex branching dialogues in Infinity Engine games that
you, as a mod creator, may wish to add to. Consider Baldur's Gate 2 and the
"Arrival In Hell" dialogue. There is a brief internal dialogue as the
protagonist comes to terms with the fact that he/she is now in Hell, and
then all of the companions coded by Bioware have a chance to speak.
(\t{PLAYER1.DLG} state 25. It will help the rest of this explanation if you
go use WeiDU to decompile \t{PLAYER1.DLG} into \t{PLAYER1.d}, and/or open
up \t{PLAYER1.DLG} in Near Infinity and look at state 25.)

After the PC's internal voice says \t{You doubt they will be pleased with
their present circumstance, when you don't even know why you are here
yourself.}, every Bioware NPC has the opportunity to speak. If you are
creating a new NPC and want it to have that full, rich Bioware flavor, you
may wish to let your character speak here as well. For that, a simple
\ttref{EXTEND!BOTTOM} will do the job.

Here's the example of how Weimer does this with Solaufein:
\begin{rawhtml}
<pre width="80"><font color="#3159D1">EXTEND_BOTTOM</font> PLAYER1 <font color="#0000FF">25</font>
  <font color="#3159D1">IF</font> <font color="#868626">~IsValidForPartyDialogue("Sola")
      Global("SolaWelcomeHell","GLOBAL",0)~</font> <font color="#3159D1">THEN</font>
    <font color="#3159D1">DO</font> <font color="#868626">~SetGlobal("SolaWelcomeHell","GLOBAL",1)~</font> <font color="#3159D1">EXTERN</font> SOLA inHell1
<font color="#3159D1">END</font></pre>
\end{rawhtml}
This puts a new transition at the bottom of \t{PLAYER1 25} that tells the
game to branch to Solaufein's observation about your arrival in Hell, if he
is present (\t{IsValid}) and if we have not already seen his comment once
before (the check for \t{SolaWelcomeHell}=0, then setting it to 1. This
ensures that this path can only happen once, which is important for a
reason I will explain later.) \t{SOLA inHell1}, which we will define later,
contains Solaufein's comment.

Once Solaufein makes his comment, it would be very thoughtful of us to
allow the other Bioware NPCs to have their say as well, as Bioware intended
and as the experienced players out there expect. You {\em could} simply use the
decompiled \t{PLAYER1.D} and copy and paste the transition list out. But
there are some good reasons not to do that. On a trivial level, it's a big
waste of space in your \ttref{D} file.

The most important reason is this: If {\em another} mod NPC has come along
and done their {\em own} \ttref{EXTEND!BOTTOM}, you would have no way of
knowing that. By putting the Bioware stock transition list in, you would
ensure that {\em only} your mod NPC got to have their say. The rest would be
silent. So if you were the developer of Solaufein, and Solaufein were
installed after Kelsey and Tashia in a game, Kelsey and Tashia would be
skipped, because {\em you} only copied the Bioware transition list. That's a
heavy responsibility.

That's why \ttref{COPY!TRANS} exists. \ttref{COPY!TRANS} pulls the entire
transition list from a specified state and makes it the transition list for
{\em your} new state.

To illustrate, look at \t{SOLA inHell1} :
\begin{rawhtml}
<pre><font color="#3159D1">APPEND</font> SOLA
  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> inHell1
    <font color="#3159D1">SAY</font> @<font color="#0000FF">2</font> = @<font color="#0000FF">3</font>         <font color="#219121">// use strings @2 and @3 from translation file
</font>    <font color="#3159D1">COPY_TRANS</font> PLAYER1 <font color="#0000FF">25</font>
  <font color="#3159D1">END</font>
<font color="#3159D1">END</font> </pre>
\end{rawhtml}
Instead of copying and pasting that huge list of \t{IF "" THEN EXTERN}
transitions from the \t{PLAYER1.D}, we let WeiDU do it for us.
\ttref{COPY!TRANS} \t{PLAYER1 25} tells WeiDU to grab the current list of
\ttref{transition}s from \t{PLAYER1} \ttref{state} 25, and use it as the
\ttref{transition} list for \t{SOLA inHell1}. This ensures that Solaufein
will be able to properly branch out to Imoen, Aerie, Minsc, and the rest of
the gang, {\em as well as} grabbing the transitions that may have been
added by other NPCs such as Kelsey, Valen, or Tashia.

\ttref{COPY!TRANS} can form all of your new \ttref{state}'s
\ttref{transition} list, or only part of it.  This would be valid, for
example:
\begin{rawhtml}
<pre width="80"><font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> commentary
  <font color="#3159D1">SAY</font> <font color="#868626">~Hey, I think I might like to run the transition list from TOLGER
    75... or I might want to do something else, if I'm in chapter six!~</font>
  <font color="#3159D1">COPY_TRANS</font> TOLGER <font color="#0000FF">75</font>
  <font color="#3159D1">IF</font> <font color="#868626">~Global("Chapter","GLOBAL",6)~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">GOTO</font> chapter6commentary
<font color="#3159D1">END</font></pre>
\end{rawhtml}
This would make the \ttref{GOTO} \t{commentary2} transition show up at the
bottom of the transition stack (below the list copied from \t{TOLGER 75}).
Remember that transition triggers are read {\em bottom to top}, so it would
be the first transition evaluated. If you want it to be evaluated {\em
after} the list of transitions in the \ttref{COPY!TRANS}, put it above.
Note, however, that Bioware usually structures its transition lists so that
the topmost trigger will always be true (in fact, sometimes it {\em is}
\t{"True()"}) so it is somewhat unlikely you would ever want to put a new
transition trigger {\em above} the \ttref{COPY!TRANS}.

Now, that explanation for why the \t{SolaWelcomeHell} variable check is
important: if a user accidentally installs the same mod more than once, and
it employs \ttref{COPY!TRANS}, the list the second time around will {\em
include} our new trigger:
\begin{rawhtml}
<pre><font color="#3159D1">IF</font> <font color="#868626">~IsValidForPartyDialogue("Sola")
      Global("SolaWelcomeHell","GLOBAL",0)~</font> <font color="#3159D1">THEN</font>
    <font color="#3159D1">DO</font> <font color="#868626">~SetGlobal("SolaWelcomeHell","GLOBAL",1)~</font> <font color="#3159D1">EXTERN</font> SOLA inHell1
</pre>
\end{rawhtml}
If there was no flag being set to ensure that the \ttref{transition} could
only run once, the user would get stuck in a loop. This can and has
happened with mods in the wild. The end result would be Solaufein or Kelsey
or whomever constantly offering their commentary, over and over again.

Important note: The WeiDU \ttref{D} compiler runs \ttref{COPY!TRANS} {\em
before} other actions that you might take to affect a transition list
within the same \ttref{D} file (like \ttref{EXTEND!TOP} and
\ttref{EXTEND!BOTTOM}).  This is a good thing.

\subsection{\ttref{INTERJECT}}
This tutorial was thoughtfully provided by Jason Compton.

Interjections, the little comments party members make, are a great way to
spice up a new NPC or a new quest you create. It shows that the characters
are paying attention to their game world, and that they have an opinion
about what goes on around them.

Through interjections, an NPC can advise a course of action, complain about
a decision, force your hand... fun things.

The traditional way to do an interjection is to find a state of a dialogue
where another NPC might comment, and use \ttref{EXTEND!BOTTOM} and
\ttref{APPEND} in conjunction.

Here's an old-school example:
\begin{rawhtml}
<pre width="80"><font color="#3159D1">EXTEND_BOTTOM</font> SAHPR4 <font color="#0000FF">7</font>
     <font color="#3159D1">IF</font> <font color="#868626">~IsValidForPartyDialog("J#Kelsey")~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">EXTERN</font> J#KLSYJ KelseySAHPR4
<font color="#3159D1">END</font>

<font color="#3159D1">APPEND</font> J#KLSYJ
  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> KelseySAHPR4
    <font color="#3159D1">SAY</font> <font color="#868626">~Urk. Who was the lucky donor?~</font>
    <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">EXTERN</font> SAHPR2 <font color="#0000FF">10</font>
  <font color="#3159D1">END</font>
<font color="#3159D1">END</font></pre>
\end{rawhtml}
This works, but it's also more work than it needs to be since the
introduction of \ttref{INTERJECT}. (Incidentally, for you WeiDU historians out
there, there are two main reasons advanced functions have been added to
WeiDU since the first versions of Solaufein and the original \ttref{CHAIN}
command: Either Weimer needed them for his own modding goals, or a mod
project, usually Kelsey, requested it. \ttref{INTERJECT} came about when
Westley finally decided that Solaufein and Valen should comment about
quests. On the other hand, \ttref{COPY!TRANS} and
\ttref{INTERJECT!COPY!TRANS} were my idea.)

\ttref{INTERJECT} simplifies this process considerably. To run an
\ttref{INTERJECT}, you
need to know the source state (the line after which you want one or more
NPCs to interject), and the destination state (where you want the dialogue
tree to go after the interjection.) Typically, but not necessarily, the
destination state will be wherever the dialogue was {\em originally}
planning to go, but if the NPC takes the conversation in a new direction,
that may change. We'll stick with the simpler cases for illustration.

\ttref{INTERJECT} is a specialized form of \ttref{CHAIN}.
So if you're familiar with \ttref{CHAIN}, this will look familiar.

Consider the dryads in the Irenicus start dungeon. Perhaps Minsc should say
something to them. \t{IDRYAD1.DLG} state 1 offers a good opportunity.
\begin{rawhtml}
<pre><font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> <font color="#0000FF">1</font> <font color="#219121">// from:
</font>  <font color="#3159D1">SAY</font> <font color="#0000FF">#11080</font> <font color="#219121">/* ~We are his possessions.~ */</font>
  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">EXTERN</font> <font color="#868626">~IDRYAD2~</font> <font color="#0000FF">1</font>
<font color="#3159D1">END</font></pre>
\end{rawhtml}
Minsc is outraged. Here's how he can express it. The idea is that we want
Minsc to comment, but for the dialogue to continue just as it would have if
he was not there.
\begin{rawhtml}
<pre><font color="#3159D1">INTERJECT</font> IDRYAD1 <font color="#0000FF">1</font> MinscDryad
  == MINSCJ <font color="#3159D1">IF</font> <font color="#868626">~IsValidForPartyDialog("Minsc")~</font> <font color="#3159D1">THEN</font>
    <font color="#868626">~Boo is outraged that the strange wizard would own these lovely ladies!
    Can Minsc and Boo help you nice girls?~</font>
<font color="#3159D1">END</font> IDRYAD2 <font color="#0000FF">1</font></pre>
\end{rawhtml}
Here's what's going on here.

Invoking \ttref{INTERJECT} requires three arguments: the dialogue name and
state we're interjecting into, plus a unique global variable name. This
variable will be set from 0 to 1 after the \ttref{INTERJECT} runs, to
ensure that it can only happen once.  (This is important in case players
accidentally install your mod twice, as it could create a looping problem
similar to the one described in \ttref{COPY!TRANS}.)

So \ttref{INTERJECT} \t{IDRYAD1 1 MinscDryad} tells WeiDU "Put this
dialogue after \t{IDRYAD1} \ttref{state} \t{1}. This dialogue will run if
\t{MinscDryad} is 0. After it runs, we will set \t{MinscDryad} to 1."

Then we need to define who is speaking. == (that's two consecutive equal
signs) is \ttref{CHAIN}-style notation for a new speaker, and \t{MINSCJ} is
the proper dialogue to use for Minsc's "joined-party" commentary. If Minsc
is in the party and valid for dialogue, he will say his line. After that,
we transition to \t{IDRYAD2} state \t{1} (\t{END IDRYAD2 1}), which is
where the dialogue was heading in the first place. We can make this more
complicated and let the dryad reply to his interruption before proceeding.
\begin{rawhtml}
<pre><font color="#3159D1">INTERJECT</font> IDRYAD1 <font color="#0000FF">1</font> MinscDryad
  == MINSCJ     <font color="#3159D1">IF</font> <font color="#868626">~IsValidForPartyDialog("Minsc")~</font> <font color="#3159D1">THEN</font>
    <font color="#868626">~Boo is outraged that the strange wizard would own these lovely ladies!
    Can Minsc and Boo help you nice girls?~</font>
  == IDRYAD1    <font color="#3159D1">IF</font> <font color="#868626">~IsValidForPartyDialog("Minsc")~</font> <font color="#3159D1">THEN</font>
    <font color="#868626">~Large mortal, we are having a dramatic scene. Please do not
    interrupt.~</font>
<font color="#3159D1">END</font> IDRYAD2 <font color="#0000FF">1</font></pre>
\end{rawhtml}
Note that we repeat the
\begin{rawhtml}
<pre><font color="#3159D1">IF</font> <font color="#868626">~IsValidForPartyDialog("Minsc")~</font> <font color="#3159D1">THEN</font></pre>
\end{rawhtml}
check for \t{IDRYAD1}. That is to ensure that she only says that line if
Minsc is there, and by extension has already made his little comment. So
now, Minsc interrupts, Dryad \#1 scolds him, and then we proceed to the
second dryad's line.

One general piece of advice: while it's not {\em necessary} to pick a state
that has only a single transition to another state, unless you're willing
to experiment (or you're intentionally trying to remove player choices from
the equation, by making the NPC say something that forces immediate action,
for instance), don't \ttref{INTERJECT} into a state that has player options
(\ttref{REPLY}s).

\label{sec-interject-copy-trans}\subsection{\t{INTERJECT!COPY!TRANS}}
This tutorial was thoughtfully provided by Jason Compton.

\ttref{INTERJECT} is good for creating interjections where none already
exist.  However, many of the really good opportunities for interjections in
game dialogue already {\em have} interjections in them. If you use standard
\ttref{INTERJECT}, chances are you'll skip right over them.

Consider \t{TOLGER.DLG} \ttref{state} \t{75}. After Tolgerias lays down the
law by saying \t{This is a sensitive matter, and I cannot tell all to every
curious soul.  I must have your commitment that you agree to the task,}
four NPCs (Edwin, Jaheira, Yoshimo, Korgan) will tell you what they think
of {\em that} rotten arrangement. What's more, Bioware structured the dialogue
transitions so that they {\em all} can get their comment in, if all four of
them are in the party.

However, using a standard \ttref{INTERJECT} for a new NPC line would skip
over those four comments, which is rather impolite.
\ttref{INTERJECT!COPY!TRANS} works much like regular \ttref{INTERJECT}, but
instead of defining a state to transition to after \t{END}, WeiDU will
\ttref{COPY!TRANS} the transition list from the state you are
\ttref{INTERJECT}ing into.

This is not as confusing as it sounds. Watch as hypothetical new NPC
Aqualung responds to Tolgerias's terms:
\begin{rawhtml}
<pre width="80"><font color="#3159D1">INTERJECT_COPY_TRANS</font> TOLGER <font color="#0000FF">75</font> AquaTolger
  == AQUALUNJ   <font color="#3159D1">IF</font> <font color="#868626">~IsValidForPartyDialogue("Aqualung")~</font> <font color="#3159D1">THEN</font>
    <font color="#868626">~Hey, that's a really crummy offer! Where did those little girls go? I
    could be sitting on a park bench, I don't need this aggravation! Who
    are you, anyway?~</font>
  == TOLGER     <font color="#3159D1">IF</font> <font color="#868626">~IsValidForPartyDialogue("Aqualung")~</font> <font color="#3159D1">THEN</font>
    <font color="#868626">~You poor old sod, you see it's only me. Now, did anyone else have a
    smart remark they wanted to make?~</font>
<font color="#3159D1">END</font></pre>
\end{rawhtml}
So, if Aqualung is around, we'll hear from him and then Tolgerias will
respond to him. {\em After that}, the game will look for the presence of
Edwin, Jaheira, Yoshimo, and Korgan and we'll get {\em their} responses to
Tolgerias as well.

Hint: \ttref{INTERJECT!COPY!TRANS} is fine to use even if there were no other
interjections in the source state, i.e. if there's just a single \t{IF "" THEN
GOTO blah}. That is, as long as you plan to proceed to the original
destination. It saves you the trouble of having to look up and input the
destination.

\label{sec-interject-copy-trans2}\subsection{\t{INTERJECT!COPY!TRANS2}}
This tutorial was thoughtfully provided by Rastor.

There seems to be a great deal of confusion among the members of the modding
community regarding the purpose and overall function of
\ttref{INTERJECT!COPY!TRANS2}.  Allow me to take a moment to dispel the rumors
that you may have heard.

\ttref{INTERJECT!COPY!TRANS2} is not intended as a replacement for
\ttref{INTERJECT!COPY!TRANS}.  \ttref{INTERJECT!COPY!TRANS} is a great function
but it has a flaw in certain special cases.  That's what
\ttref{INTERJECT!COPY!TRANS2} is intended to remedy.  This difference between
the two is best illustrated with an example.

Let us suppose that you want to add an NPC response to \t{PPSAEM2} 8.  Here is
some of what that state looks like before any mods have been applied:

\begin{verbatim}
IF ~~ THEN BEGIN 8 // from: 7.0
  SAY #44931 /* ~Blah blah blah~ */
  IF ~!IsValidForPartyDialog("Jaheira")
!IsValidForPartyDialog("Anomen")
!IsValidForPartyDialog("Edwin")
IsValidForPartyDialog("Viconia")~ THEN DO ~SetGlobal("WackoArmy","GLOBAL",1)
OpenDoor("DOOR12")
EscapeArea()~ UNSOLVED_JOURNAL #7045 EXTERN ~VICONIJ~ 129
END
\end{verbatim}

Note that the \ttref{DO} actions include \t{EscapeArea()}. If you use
\ttref{INTERJECT!COPY!TRANS} to add an interjection here, the \ttref{DO}
actions will be performed by your interjector (usually a party member). The
result is that after encountering this dialogue in the game the party member
will leave the area (and Saemon will stay where he is!) promptly after
performing the interjection. Instead, we want to keep the \ttref{DO} action
associated with Saemon.

\ttref{INTERJECT!COPY!TRANS2} allows modders to remedy this problem.
\ttref{INTERJECT!COPY!TRANS2} does exactly the same thing as
\ttref{INTERJECT!COPY!TRANS} except that DO actions will be kept with their
original actor and not transferred to the interjector.

To code your interjection using \ttref{INTERJECT!COPY!TRANS2}, you would do
this:

\begin{verbatim}
INTERJECT_COPY_TRANS2 PPSAEM2 8
  ~Blah blah blah~
END
\end{verbatim}

The dialogue state that WeiDU will create from this
\ttref{INTERJECT!COPY!TRANS2} statement looks something like:

\begin{verbatim}
IF ~~ THEN BEGIN 133 // from:
  SAY #78199 /* ~Blah blah blah~ */
  IF ~!IsValidForPartyDialog("Jaheira")
!IsValidForPartyDialog("Anomen")
!IsValidForPartyDialog("Edwin")
IsValidForPartyDialog("Viconia")~ THEN UNSOLVED_JOURNAL #7045 EXTERN ~VICONIJ~ 129
END
\end{verbatim}

Note that \ttref{INTERJECT!COPY!TRANS2} is not intended as a universal
replacement for \ttref{INTERJECT!COPY!TRANS}.  This is most obvious when using
the command to interject into a state that starts a cutscene.  Here is an
example of an interjection into \t{PPIRENI2} 27.

The original, unmodded state:

\begin{verbatim}
IF ~~ THEN BEGIN 27 // from: 28.0 26.0
  SAY #44869 /* ~I bid you farewell, child of Bhaal. We shall not meet again.~
[IRENIC52] */
  IF ~~ THEN DO ~EraseJournalEntry(7252)
EraseJournalEntry(7253)
EraseJournalEntry(22952)
EraseJournalEntry(23306)
SetGlobal("AsylumPlot","GLOBAL",40)
StartCutSceneMode()
StartCutScene("Cut41j")~ SOLVED_JOURNAL #7255 EXIT
END
\end{verbatim}

Using \ttref{INTERJECT!COPY!TRANS2} to code your interjection into this state
will cause the game to crash when your interjection plays (because the special
\t{StartCutSceneMode()} action cannot occur in the middle of a dialogue,
loosely).  \ttref{INTERJECT!COPY!TRANS} will work properly, however.


\subsection{\ttref{state} \ttref{WEIGHT}s}

\ttref{stateTriggerString}s, the conditions that determine what
\ttref{state} should be used for the beginning of a dialogue, may have
\ttref{WEIGHT}s. These \ttref{WEIGHT}s are used by the Infinity Engine to
choose which state to pick if multiple state triggers evaluate to "true". [
In reality, the \ttref{WEIGHT}s are just the offsets within the state
trigger table in the \t{DLG} file, but this detail is not important unless
you are writing your own tool. ] \ttref{WEIGHT}s only make sense for
\ttref{stateTriggerString}s that are not empty.

If multiple \ttref{stateTriggerString}s evaluate to true, the Infinity
Engine will pick the \ttref{state} with the {\em lowest} \ttref{WEIGHT}.
Usually the weighting follows the order of state declaration in the
\ttref{D} file.  That is, the first \ttref{state} mentioned has the lowest
weight (i.e., will be picked first in case of a tie) and the last state
mentioned has the highest weight (i.e., will be picked last in case of a
tie). However, you may include an explicit \ttref{WEIGHT} directive to
change things around. For example, consider this \ttref{D} file:
\begin{rawhtml}
<pre width="80"><font color="#3159D1">BEGIN</font> foozle
  <font color="#3159D1">IF</font> <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> a <font color="#3159D1">SAY</font> <font color="#868626">~Jason~</font> <font color="#3159D1">END</font>
  <font color="#3159D1">IF</font> <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> b <font color="#3159D1">SAY</font> <font color="#868626">~yada~</font> <font color="#3159D1">END</font>
  <font color="#3159D1">IF</font> <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> c <font color="#3159D1">SAY</font> <font color="#868626">~Compton~</font> <font color="#3159D1">END</font>
  <font color="#3159D1">IF</font> <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> d <font color="#3159D1">SAY</font> <font color="#868626">~kelsey~</font> <font color="#3159D1">END</font></pre>
\end{rawhtml}
If you talk to \t{foozle}, it will always say \t{Jason}. However, you may
explicitly alter the weights so that the third state is picked first, as
in:
\begin{rawhtml}
<pre><font color="#3159D1">BEGIN</font> foozle
  <font color="#3159D1">IF</font> <font color="#3159D1">WEIGHT</font> <font color="#0000FF">#10</font> <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> a <font color="#3159D1">SAY</font> <font color="#868626">~Jason~</font> <font color="#3159D1">END</font>
  <font color="#3159D1">IF</font>            <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> b <font color="#3159D1">SAY</font> <font color="#868626">~yada~</font> <font color="#3159D1">END</font>
  <font color="#3159D1">IF</font> <font color="#3159D1">WEIGHT</font> <font color="#0000FF">#2</font>  <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> c <font color="#3159D1">SAY</font> <font color="#868626">~Compton~</font> <font color="#3159D1">END</font>
  <font color="#3159D1">IF</font>            <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> d <font color="#3159D1">SAY</font> <font color="#868626">~kelsey~</font> <font color="#3159D1">END</font></pre>
\end{rawhtml}
With this \ttref{D} file, foozle will always say \t{Compton}. All
\ttref{state}s with \ttref{WEIGHT} directives come before all states
without them. States without \ttref{WEIGHT} directives are ranked in order
of appearance. So the state order for \t{foozle.}\ttref{DLG} is \t{c-a-b-d}. Yes, this is
complicated.

{\em Strong Style Suggestion}: do {\em not} use the \ttref{WEIGHT}
directive in your hand-made \ttref{D} files. Just use the implicit ordering.

The \ttref{WEIGHT} directive was introduced to facilitate handling of
Bioware-created \ttref{DLG} files (e.g., \t{BJAHEIR.DLG}) that include
tricky weighting. Only states with non-empty triggers are given implicit
weights.  If you create a \ttref{D} file from a \ttref{DLG} that features
non-trivial weighting, WeiDU will emit comments like this:
\begin{rawhtml}
<pre><font color="#3159D1">IF</font> <font color="#3159D1">WEIGHT</font> <font color="#0000FF">#8</font> <font color="#219121">/* Triggers after states #: 11 12 24 25 26 36 58 even though
                they appear after this state */</font>
  <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> <font color="#0000FF">10</font> <font color="#219121">// from:
</font>    <font color="#3159D1">SAY</font> <font color="#0000FF">#52190</font> <font color="#219121">/* ~Please do not interrupt our thoughts. We must prepare
      carefully if we are to see a weakness in the illithid web. ~ */</font>
    <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">EXIT</font>
<font color="#3159D1">END</font></pre>
\end{rawhtml}
to remind you that the order is not what you think.

All non-empty state triggers in \ttref{DLG} files are given weights
counting up from 0 to the maximum number of state triggers in the
\ttref{DLG} file.  You may use any number you like (even a negative one):
WeiDU will simply sort them. \ttref{ADD!STATE!TRIGGER}does not change the
weight associated with that trigger. \ttref{APPEND} can be used to give a
non-trivial weight to a state, as in:
\begin{rawhtml}
<pre><font color="#3159D1">APPEND</font> BJAHEIR
  <font color="#3159D1">IF</font> <font color="#3159D1">WEIGHT</font> <font color="#0000FF">#-999</font> <font color="#868626">~MyCondition()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> mystate <font color="#3159D1">SAY</font> <font color="#868626">~My Stuff~</font> <font color="#3159D1">END</font>
<font color="#3159D1">END</font></pre>
\end{rawhtml}
Since \t{BJAHEIR} will have implicit \ttref{WEIGHT}s in the range from \#0 to
about \#50, this causes \t{mystate} to have priority over all states that
already exist in \t{BJAHEIR}. Without such drastic action,
\ttref{APPEND}ed states will
have use the implicit ordering, and will thus have the lowest priority
(because they appear at the end of the file). \ttref{Multisay} and
\ttref{CHAIN} also
append states, but since they always append states with empty
\ttref{stateTriggerString}s, \ttref{WEIGHT}s are not relevant.

Consider the following example:
\begin{rawhtml}
<pre><font color="#3159D1">BEGIN</font> foozle
  <font color="#3159D1">IF</font> <font color="#3159D1">WEIGHT</font> <font color="#0000FF">#10</font> <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> a <font color="#3159D1">SAY</font> <font color="#868626">~Jason~</font> <font color="#3159D1">END</font>
  <font color="#3159D1">IF</font>            <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> b <font color="#3159D1">SAY</font> <font color="#868626">~yada~</font> <font color="#3159D1">END</font>
  <font color="#3159D1">IF</font> <font color="#3159D1">WEIGHT</font> <font color="#0000FF">#2</font>  <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> c <font color="#3159D1">SAY</font> <font color="#868626">~Compton~</font> <font color="#3159D1">END</font>
  <font color="#3159D1">IF</font>            <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> d <font color="#3159D1">SAY</font> <font color="#868626">~kelsey~</font> <font color="#3159D1">END</font>
  <font color="#3159D1">ADD_STATE_TRIGGER</font> foozle <font color="#0000FF">1</font> <font color="#219121">/* state b */</font> <font color="#868626">~MyCondition()~</font></pre>
\end{rawhtml}
The resulting \t{foozle} dialogue will still have the \t{c-a-b-d} weighting
order.

Here's another example:
\begin{rawhtml}
<pre><font color="#3159D1">BEGIN</font> foozle
  <font color="#3159D1">IF</font>            <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> a <font color="#3159D1">SAY</font> <font color="#868626">~Jason~</font> <font color="#3159D1">END</font>
  <font color="#3159D1">IF</font>            <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> b <font color="#3159D1">SAY</font> <font color="#868626">~yada~</font> <font color="#3159D1">END</font>
  <font color="#3159D1">IF</font>            <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> c <font color="#3159D1">SAY</font> <font color="#868626">~Compton~</font> <font color="#3159D1">END</font>
  <font color="#3159D1">IF</font>            <font color="#868626">~True()~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> d <font color="#3159D1">SAY</font> <font color="#868626">~kelsey~</font> <font color="#3159D1">END</font>
  <font color="#3159D1">ADD_STATE_TRIGGER</font> foozle <font color="#0000FF">1</font> <font color="#219121">/* state b */</font> <font color="#868626">~MyCondition()~</font></pre>
\end{rawhtml}
The resulting \t{foozle} dialogue will have the (expected) \t{a-b-c-d}
ordering.

{\em However}, consider this evil example:
\begin{rawhtml}
<pre>  <font color="#219121">//////
</font>  <font color="#219121">// foozle.DLG contents, assume it has already been created and is
</font>  <font color="#219121">// sitting on your hard drive somewhere
</font>  <font color="#219121">// IF            ~True()~ THEN BEGIN a SAY ~Jason~ END
</font>  <font color="#219121">// IF            ~~ THEN BEGIN b SAY ~yada~ END
</font>  <font color="#219121">// IF            ~True()~ THEN BEGIN c SAY ~Compton~ END
</font>  <font color="#219121">// IF            ~True()~ THEN BEGIN d SAY ~kelsey~ END
</font>  <font color="#219121">//////
</font>
  <font color="#219121">// new D file
</font>  <font color="#3159D1">ADD_STATE_TRIGGER</font> foozle <font color="#0000FF">1</font> <font color="#219121">/* state b */</font> <font color="#868626">~MyCondition()~</font></pre>
\end{rawhtml}
This will update \t{foozle} and the resulting order will be \t{a-c-d-b}
(because when \t{foozle.}\ttref{DLG} was loaded from the disk, \t{a} \t{c}
and \t{d} were given weights but \t{b} was not (because it had an empty
trigger)).  Thus, you should avoid using \ttref{ADD!STATE!TRIGGER} on
states with empty triggers unless you know what you are doing.

\label{TRA}\subsection{\t{TRA} Translation Files}

If you are writing a mod and you would like to make it easier to translate
it into another language you can use "translation files" (much like BGII
itself uses \t{DIALOG.}\ttref{TLK}) to separate your dialogue structure and content.  A
translation file basically lists the string texts in order. For example,

\CMD{WeiDU --trans SCSARLES.DLG}

This creates \t{scsarles}.\ttref{D} and \t{scsarles.tra}.
\t{scsarles.}\ttref{D} now contains:
\begin{rawhtml}
<pre width="80"><font color="#3159D1">IF</font> <font color="#868626">~NumTimesTalkedTo(0)~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> <font color="#0000FF">0</font> <font color="#219121">// from:
</font>  <font color="#3159D1">SAY</font> @<font color="#0000FF">1</font> <font color="#219121">/* ~Who is it? Might I ask why you have disturbed my meditations?
    My creative muse must be gently awakened, and your stomping about is
    simply not conducive to this.~ [SARLES02] #28655 */</font>
  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">REPLY</font> @<font color="#0000FF">2</font>
    <font color="#219121">/* ~My apologies. I will leave you to your thinking.~ #28656 */</font> <font color="#3159D1">GOTO</font> <font color="#0000FF">1</font>
  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">REPLY</font> @<font color="#0000FF">3</font> <font color="#219121">/* ~I apologize, but I have come to request your
  talent on a commissioned artwork.~ #28657 */</font>
    <font color="#3159D1">DO</font> <font color="#868626">~SetGlobal("TalkedToSarles","GLOBAL",1)~</font> <font color="#3159D1">GOTO</font> <font color="#0000FF">2</font>
<font color="#3159D1">END</font> </pre>
\end{rawhtml}
Note that all of the strings have been replaced by \t{@number} and the texts
have been put in comments.

The translation file \t{scsarles.tra} contains all of those strings:
\begin{rawhtml}
<pre><font color="#219121">// SCSARLES translation file
</font>@<font color="#0000FF">1</font>   = <font color="#868626">~Who is it? Might I ask why you have disturbed my meditations?
My creative muse must be gently awakened, and your stomping
about is simply not conducive to this.~</font> [SARLES02]
@<font color="#0000FF">2</font>   = <font color="#868626">~My apologies. I will leave you to your thinking.~</font>
@<font color="#0000FF">3</font>   = <font color="#868626">~I apologize, but I have come to request your talent on a commissioned artwork.~</font> </pre>
\end{rawhtml}
You may then ask someone who speaks another language to write a new
translation file by translating every string in \t{scsarles.tra}. This
prevents the string text and the structure from getting out of sync
and simplifies translation; non-technical players can translate raw text
files easily.

When compiling a \ttref{D} file that contains \t{@number} translation
references you must supply (at least) one translation file. For example,
you might say:

\CMD{WeiDU SCSARLES.D italian.tra}

You may specify multiple translation files. The last one to define a string
wins. This is useful if one language is more up to date than the others. In
this example:

\CMD{WeiDU SCSARLES.D english.tra italian.tra}

Strings will be taken from the italian translation whenever possible, but
if they are not available it will fall back on the english versions.

You may use WeiDU to check and make sure that translations are up to date.
WeiDU will automatically generate a text file listing all of the strings
that are present in one translation (usually your native one) that are
missing in another. You can then send this file to your translators so that
they know what to do. This example command compares all of the \ttref{TRA}
files in the \t{american} and \t{french} directories and creates a file
called \t{MISSING}.

\CMD{weidu --tcmp-from american --tcmp-to french --out MISSING}

\subsection{Converting a ``hard-coded'' \ttref{D} to a \ttref{D}/\ttref{TRA} pair (Last Update: v200)}

This tutorial was thoughtfully provided by Jason Compton.

\ttref{D} and \ttref{TP2} files allow programmers to describe text either
literally:
\begin{rawhtml}
<pre width="80"><font color="#219121">// Greeting.d
</font><font color="#3159D1">SAY</font> <font color="#868626">~Hello.~</font>
</pre>
\end{rawhtml}
or with a companion \ttref{TRA} (translation) file that supports multiple
languages:
\begin{rawhtml}
<pre width="80"><font color="#219121">// Greeting.d
</font><font color="#3159D1">SAY</font> @<font color="#0000FF">1</font>

<font color="#219121">// Greeting.tra
</font>@<font color="#0000FF">1</font> = <font color="#868626">~Hello.~</font>
</pre>
\end{rawhtml}
The idea being that one can make a French version of \t{Greeting.tra} which
contains
\begin{rawhtml}
<pre width=80><font color="#219121">// French-Greeting.tra
</font>@<font color="#0000FF">1</font> = <font color="#868626">~Bonjour.~</font>
</pre>
\end{rawhtml}
However, some WeiDU users, for reasons of convenience or simply never
anticipating the opportunity to translate, may have originally chosen the
"hard-coded" approach but now regret that decision. \t{--traify} will break
out all the text in \ttref{SAY}, \ttref{REPLY}, and \ttref{JOURNAL} entries
into translation-ready format. \t{--traify} may also be used on \ttref{TP2}
files.

To turn the hard-coded \ttref{D} file \t{FWKI.d} into a new
\ttref{D}/\ttref{TRA} combo, use
\t{--traify} and \t{--out} to specify the input and output filenames,
respectively:

  \CMD{ weidu --traify fwki.d --out fwki-new.d}

After a brief pause, \t{fwki-new.d} and \t{fwki-new.tra} will be created.

The \t{--traify} process turns \t{fwki.d}'s
\begin{rawhtml}
<pre width="80"><font color="#3159D1">APPEND</font> J#KLSYJ
  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> KelseySAHPR4
    <font color="#3159D1">SAY</font> <font color="#868626">~Urk. Who was the lucky donor?~</font>
    <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">EXTERN</font> SAHPR2 <font color="#0000FF">10</font>
  <font color="#3159D1">END</font>
<font color="#3159D1">END</font> </pre>
\end{rawhtml}
into \t{fwki-new.d}'s
\begin{rawhtml}
<pre width="80"><font color="#3159D1">APPEND</font> J#KLSYJ
  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> KelseySAHPR4
    <font color="#3159D1">SAY</font> @<font color="#0000FF">0</font>
    <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">EXTERN</font> SAHPR2 <font color="#0000FF">10</font>
  <font color="#3159D1">END</font>
<font color="#3159D1">END</font> </pre>
\end{rawhtml}
and in the newly created \t{fwki-new.tra}, you will find
\begin{rawhtml}
<pre>@<font color="#0000FF">0</font>    = <font color="#868626">~Urk. Who was the lucky donor?~</font></pre>
\end{rawhtml}
and this dialogue file is now ready for translation.

{\tt --traify} works from the top of the \ttref{D} down, starting at \t{@0}. It
will NOT skip over any existing \t{@x} translation references it finds, so if
your \ttref{D} contains any translation support at all, it is best to use {\tt
--traify-old-tra} as well.

Because standard \t{--traify} starts at \t{@0} and is unaware of any any existing
\t{@x} entries in the \ttref{D}, if you have begun to convert a \ttref{D} to a
\ttref{D}/\ttref{TRA} pair by hand, you may have \t{@x} entries that clash with
\t{--traify}'s results.

In other words, if you already have a state that says
\begin{rawhtml}
<pre width="80"><font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">BEGIN</font> blah
  <font color="#3159D1">SAY</font> @<font color="#0000FF">0</font>
  <font color="#3159D1">IF</font> <font color="#868626">~~</font> <font color="#3159D1">THEN</font> <font color="#3159D1">EXIT</font>
<font color="#3159D1">END</font></pre>
\end{rawhtml}
\t{--traify} will not skip \t{@0} automatically, you will have two locations where
\t{@0} is used but you intended to use two different strings, and this will be
bad.

To avoid this problem, add the \t{--traify-old-tra} argument to specify the file
containing the already traified strings:

 \CMD{ weidu --traify fwki.d --traify-old-tra fwki.tra --out fwki-new}

will put the existing and new ones \t{@x} references in \t{fwki-new.tra}.

Finally, note that \t{--traify} works for \ttref{BAF} files as well.

Note: We were previously suggesting to use \t{--traify\#} here. Unless you want
for some reason to have new references starting at a given number, you should
use \ttref{--traify-old-tra} instead.

In all cases, you might also find it beneficial to put the
\ttref{--traify-comment} argument in your command line, so that you'll also have
the content of the @references in your file (which will make it easier to edit it later):

 \CMD{ weidu --traify fwki.d --traify-old-tra fwki.tra --out fwki-new --traify-comment}

In particular, using \ttref{--traify-comment} and \ttref{--traify-old-tra} together
will add the missing comments without doubling the existing ones.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\ttref{REPLACE!ACTION!TEXT}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This tutorial was thoughtfully provided by Japheth.

\ttref{REPLACE!ACTION!TEXT} can be used with regular expressions
(\ttref{regexp}).  So, some actions such as
\t{CreateCreature("blah",[0.0],1)} won't be matched by WeiDU because when
you say \t{[0.0]} it is looking for a character set.

Here's one dialogue that I'm fixing and how to do it correctly.

\t{Arghai.dlg} has this action trigger before
\ttref{REPLACE!ACTION!TEXT}ing it.

\begin{verbatim}
CreateCreature("OGREHA",[1351.1078])
\end{verbatim}

There's no point given, which makes WeiDU and NI angry. To fix it using
\ttref{REPLACE!ACTION!TEXT} this is what you have to do:

\begin{verbatim}
REPLACE_ACTION_TEXT arghai
~CreateCreature("OGREHA",\[1351.1078\])~
~CreateCreature("OGREHA",[1351.1078],0)~
\end{verbatim}

So, all you have to remember to do is escape the square brackets with a
backslash so WeiDU doesn't confuse them with a regular expression.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec-alter-trans}\subsection{\t{ALTER!TRANS} (Last Update: 204.)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This tutorial was thoughtfully provided by CamDawg.

ALTER_TRANS is a more compatibility-friendly way of changing transitions in an existing dialogue state. This is best illustrated with an example; let's use state 9 from doghma.dlg in BG2:

\begin{verbatim}
IF ~~ THEN BEGIN 9 SAY #45751
  IF ~~ THEN REPLY #45752 GOTO 2
  IF ~GlobalLT("chapter","GLOBAL",4)~ THEN REPLY #45753 GOTO 5
  IF ~~ THEN REPLY #45754 GOTO 4
  IF ~Global("RevealUmar","GLOBAL",1)
      PartyHasItem("miscbl")
      PartyHasItem("miscbm")
      PartyHasItem("miscbn")
      PartyHasItem("miscbo")~ THEN REPLY #57922 GOTO 10
  IF ~~ THEN REPLY #45755 GOTO 1
END
\end{verbatim}


The problem lies in transition 3, which should have an OR(4) before those four PartyHasItem checks. Before ALTER_TRANS, the least destructive way to fix it would be

\begin{verbatim}
ADD_TRANS_TRIGGER DOGHMA 9 ~False()~ DO 3
EXTEND_BOTTOM DOGHMA 9
IF ~Global("RevealUmar","GLOBAL",1)
OR(4)
PartyHasItem("miscbl")
PartyHasItem("miscbm")
PartyHasItem("miscbn")
PartyHasItem("miscbo")~ THEN REPLY #57922 GOTO 10
END
\end{verbatim}


This presents some compatibility issues though. If another mod has altered this transition (for example, a new action via ADD_TRANS_ACTION) then those changes are lost via this method. It also reorders the replies as they're displayed on-screen--not a big issue for transitions involving replies, but it is a big issue for non-reply transitions where they're evaluated from the bottom-up. It's also an issue for other mods that target this transition, as the False() essentially eliminates it. Enter ALTER_TRANS:

\begin{verbatim}
ALTER_TRANS DOGHMA // file name
BEGIN 9 END // state number (can be more than one)
BEGIN 3 END // transition number (can be more than one)
BEGIN // list of changes, see below for flags
  "TRIGGER" ~Global("RevealUmar","GLOBAL",1)
           OR(4)
             PartyHasItem("miscbl")
             PartyHasItem("miscbm")
             PartyHasItem("miscbn")
             PartyHasItem("miscbo")~
END
\end{verbatim}


There are eight flags you can use in the list of changes. If you do not use a particular flag, the previous value of the transition will be retained (i.e. not specifying an ACTION flag will preserve the current action of the transition).

\begin{itemize}
\item TRIGGER: The trigger condition for the transition.
 i.e \verb+"TRIGGER" ~Global("foo","GLOBAL",0)~+

\item ACTION: The action performed if the transition is selected.
  i.e. \verb+"ACTION" ~SetGlobal("foo","GLOBAL",1)~+

\item REPLY: The player's reply, if any.
  i.e. \verb+"REPLY" ~#57922~+

\item JOURNAL: Can add or change the journal entry.
  i.e. \verb+"JOURNAL" ~@100~+

\item SOLVED!JOURNAL: Same as JOURNAL, except for entries into the solved section of the journal.

\item UNSOLVED!JOURNAL: Same as JOURNAL, except for entries into the unsolved section of the journal.

\item EPILOGUE: Specifies where the transition leads to (GOTO, EXTERN, or EXIT)
  i.e. \verb+EPILOGUE" ~EXTERN BVICONI 0~+

\item FLAGS: Used to set transition flags manually, though I can't imagine why one would do this.
\end{itemize}

Let's try one last example. This is bviconi.dlg, state 103:

\begin{verbatim}
IF WEIGHT #22 ~Global("LoveTalk","LOCALS",46)~ THEN BEGIN 103 SAY #10537
  IF ~~ THEN REPLY #10538 GOTO 367
  IF ~~ THEN REPLY #10539 EXTERN ~~ 0
END
\end{verbatim}


As you can see the transition destination for the second transition is broken. In the olden days this would be fixed with

\begin{verbatim}
ADD_TRANS_TRIGGER BVICONI 103 ~False()~ DO 1
EXTEND_BOTTOM BVICONI 103
IF ~~ THEN REPLY #10539 GOTO 368
END
\end{verbatim}


With ALTER_TRANS, it becomes much easier:

\begin{verbatim}
ALTER_TRANS BVICONI BEGIN 103 END BEGIN 1 END BEGIN "EPILOGUE" ~GOTO 368~ END
\end{verbatim}

Addendum: please note that it's important to wrap the target (for example, REPLY or EPILOGUE)
in quotes, tildas, or percentage signs.

Further addendum: REPLY, JOURNAL and friends will remove the feature (rather than add an empty
journal line or whatever) if the associated string is empty.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Module Packaging: \DEFINE{TP2} Files}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{TP}

At some point you will be done with your mod (a collection of \t{CRE},
\t{ITM}, \ttref{D}, etc., files) and you will want to package it up so that
other users can install it (and then perhaps uninstall it later) easily.
WeiDU can handle this task for you (and you may freely distribute \t{WeiDU.exe}
with your module).

A \ttref{TP2} describes how to install components of your module. WeiDU
will read the file, ask the user questions, and then perform the
installation. Uninstallation and upgrading are also handled.

See the file \t{examples/mymod.tp2} for a commented example of how this all
works.

Here is the context-free grammar syntax for the \ttref{TP2} file format:

\begin{tabular}{cp{10in}|p{10in}}

\DEFINE{TP2 File}\label{TP2} & &
  A \ttref{TP2 File} is a text file that contains a number of
  mod \ttref{Component}s. \ttref{TP2 File}s tell WeiDU how to install
  various parts of your mod on an end-user's computer. \\

  is & \DEFINE{BACKUP} directoryName

       \DEFINE{AUTHOR} emailAddress

       \ttref{TP2 Flag} \Slist

       \ttref{Language} \Slist

       \ttref{Component} \Slist &

       A \ttref{TP2 File} is basically a prologue and then a list of
       \ttref{Component}s. The \ttref{BACKUP} declaration tells WeiDU where
       to put backed-up versions of files that would be overwritten so that
       they can be uninstalled later. This directory will be created
       automatically if it is missing. The \ttref{AUTHOR} directive gives an
       email address for users to send bugs to if there are problems during
       the installation. You may use \DEFINE{SUPPORT} as an alias for
       \ttref{AUTHOR}. The \DEFINE{TP2!AUTHOR} \ttref{variable} is set to
       the ``emailAddress'' value. The \DEFINE{TP2!FILE!NAME} \ttref{variable}
       is set to the name of the tp2 file. The \DEFINE{TP2!BASE!NAME}
       \ttref{variable} is set to the name of the tp2, excluding any initial
       ``setup-''. For ``setup-mymod.tp2'', \t{TP2!FILE!NAME} is set to
       ``setup-mymod.tp2'', while \t{TP2!BASE!NAME} is set to ``mymod.tp2''.
       The \DEFINE{MOD!FOLDER} \ttref{variable} is set to the
       directory containing the TP2 file, if there is one, otherwise
       it is set to the root directory of directoryName.
       \ttref{TP2 Flag}s set global options.
       \ttref{Language}s are
       the various languages in which your mod is available. The
       Finally, the \ttref{Component}s make up the actual meat of
       your mod. Different \ttref{Component}s can be installed or
       uninstalled separately, but all of the parts within a
       \ttref{Component} are treated as a unit.  \\
\\

\DEFINE{TP2 Flag} & & A \ttref{TP2 Flag} declaration tells WeiDU to apply some
global option to your \ttref{TP2} file. \\
  is & \DEFINE{AUTO!TRA} path &
       The \ttref{AUTO!TRA} flag is used
       with the \ttref{COMPILE} \ttref{TP2 Action}. It automatically loads
       \ttref{TRA} files that match your \ttref{D} files. The \ttref{TRA} file
       loaded by \ttref{AUTO!TRA} takes precedence over all other \ttref{TRA}
       files. \\
  or & \DEFINE{ALLOW!MISSING} file \Slist &
       \ttref{ALLOW!MISSING} directive allows you to specify files that can
       be missing (when you try to copy them or reference them from
       \ttref{D} files). Empty versions of those files will be created on
       demand. Try to use \ttref{ACTION!IF} instead of this. \\
  or & \DEFINE{ASK!EVERY!COMPONENT} &
       This flag instructs WeiDU to ask about installing every component in
       this \ttref{TP2} file individually, rather than asking questions
       like "Would you like to install them all?" \\
  or & \DEFINE{ALWAYS} \ttref{TP2 Action} \Slist \t{END} &
       This flag specified a \ttref{TP2 Action} that is executed at the beginning
       of each \ttref{Component}, before the component-specific \ttref{TP2 Action}.  \\
  or & \DEFINE{README} file \Slist &
       The given file is displayed to the user after choosing the language, but
       before installing any component. If more than one file name is provided,
       they are checked for existence in the order they're provided, and the first available
       one will be opened. If you wish to open multiple readme files, use multiple \t{README}
       statements.
  \\
  or & \DEFSYN{UNINSTALL!ORDER} String \Slist &
		\emph{Do not use this without a real reason.}

		Specifies the order in which uninstallation operations are handled.
		The operations are STRSET (uninstall \ttref{STRING!SET} and
                \ttref{ALTER!TLK}), MOVE
		(uninstall \ttref{MOVE}), AT (perform \ttref{AT!UNINSTALL} and
                \ttref{AT!INTERACTIVE!UNINSTALL}) and
		COPY (uninstall all various file operations).

		If not specified, the order is MOVE - STRSET - COPY - AT.

		If this is specified, then ALL operations must be specified
		(if any isn't, a warning is printed). Please note that this means that
		your mod might start printing warnings three years down the line if
		a new uninstall action is coded.
  \\
  or & \DEFINE{MODDER} String \Slist &
       Enable additional debug info. By default, these messages are verbose but do
       not halt the installation. Some options are configurable, see the \ahrefloc{sec-modder}
       {in-depth description}.
       \\
  or & \DEFINE{VERSION} String &

  "String" (variables evaluated) will be appended to every component's
  name in the weidu.log file. The \ttref{variable}
  \DEFINE{MOD!VERSION} evaluates to the string set by \ttref{VERSION}
  or to the empty string if the \ttref{VERSION} flag is not present. \\

  or & \DEFINE{SCRIPT!STYLE} style &
       This flag determines how WeiDU will read in \ttref{BAF} and
       \ttref{BCS} files and
       write out \ttref{BAF} and \ttref{BCS} files. Possible options for
       ``style'' include \t{BG} (the default), \t{IWD1}, \t{IWD2}, and \t{PST}.
       See \ahrefloc{sec-scripting-styles}{the Scripting Styles tutorial}. \\
  or & \DEFINE{NO!IF!EVAL!BUG} & this action solves a long-standing bug with
    the \t{IF!EVAL} action. Since solving it is not directly possible without
    damaging backwards compatibility, you have to use this action (preferably
    in an \ttref{ALWAYS} statement) to solve the bug for yourself. \t{IF!EVAL} will not
    work with this action in the TP2 - use \ttref{PATCH!IF} and
    \ttref{BUT!ONLY!IF!IT!CHANGES} instead. \\

  or & \DEFINE{QUICK!MENU} lots of parameters &
    Used to specify one or more groups of components that can be installed in
    a single step. See the \ahrefloc{sec-quick-menu}{\t{QUICK!MENU} tutorial} for syntax, usage
    instructions, and caveats. \\

  or & \DEFINE{AUTO!EVAL!STRINGS} &

    \t{EVALUATE!BUFFER} is used whenever variables are evaluated. In
    particular, you can now "forget" about using it in FUNCTIONs and
    arrays. Note, TP2 defines multiple instances of
    \t{EVALUATE!BUFFER}, like \ttref{EVALUATE!BUFFER}, but these are
    not affected by \ttref{AUTO!EVAL!STRINGS}. \emph{N.B.} This adds
    an additional level of \t{EVAL} to \ttref{OUTER!TEXT!SPRINT} and
    \ttref{TEXT!SPRINT}, but not to \ttref{OUTER!SPRINT} or
    \ttref{SPRINT}. \\

\\

\DEFINE{Language} & &
  A \ttref{Language} declaration tells WeiDU where to find \ttref{TRA}
  files. \\

  is & \DEFINE{LANGUAGE} languageName
       languageDirectory
       defaultLanguageTRA \Slist &
       The languageName is the name of the language as it is presented to
       the user. "American English" and "Italiano" are
       examples. The languageDirectory is the name of the subdirectory in
       which you have stored the \ttref{TRA} files for that language.
       Examples include "american" and "spanish". The \ttref{variable}
       named \t{LANGUAGE} is set to languageDirectory if the user selects
       this language.. Finally, all of the \ttref{TRA} files in the
       defaultLanguageTRA list are loaded as soon as the user selects a
       language.  \\
\\

\DEFINE{Component}\label{component} & &
  A \ttref{Component} is a contiguous group of files and actions that a
  user can install, uninstall or upgrade. \\

  is & \DEFSYN{BEGIN} componentName
    \ttref{Component Flag} \Slist
    \ttref{TP2 Action} \Slist &
    Basically, if componentName is "Foo", the user will be asked: "Do you
    want to install Foo?". If so, all of the associated \ttref{TP2 Action}s
    are performed. If not, they are skipped. \\

\\

\DEFINE{Component Flag} &&
  A \ttref{Component Flag} determines how WeiDU treats a component. \\

  is & \DEFINE{DEPRECATED} \ttref{String} &
      Mark the given component as deprecated. If it is currently installed,
      it will be uninstalled and the given \ttref{String} will be
      displayed. The user will never be asked to install the given
      component -- it will be silently skipped in all listings. However, it
      will still take up a ``component number''. \\

  or & \DEFINE{REQUIRE!COMPONENT} modToUninstall modComponent
      \ttref{String} &
      Make this component so that it can only be installed if another
      component is installed. If that other component is not installed, the
      \ttref{String} will be displayed and the user will not get a chance
      to install this component. This is in some sense the opposite of the
      \ttref{UNINSTALL} \ttref{TP2 Action}. For example,
      \t{REQUIRE!COMPONENT "setup-ease.tp2" "0" "You must have infinite
      stacking installed!"} prevents a component from being installed
      unless the infinite stacking part of the Ease-of-Use mod is
      installed.  \\

  or & \DEFINE{FORBID!COMPONENT} modToUninstall modComponent
      \ttref{String} &
      Make this component so that it can only be installed if another
      component is \emph{not} installed. This does the opposite of
      \ttref{REQUIRE!COMPONENT}.  \\

  or & \DEFINE{REQUIRE!PREDICATE} \ttref{value} \ttref{String} &
      This component can only be installed if the \ttref{value}
      evaluates to true (non-zero). \\

  or & \DEFINE{SUBCOMPONENT} \ttref{String} \Ob \ttref{value} \Oe &
      At most one component of the given subcomponent group can be
      installed at any time. All subcomponents of the same group are
      listed together for the user. See the \ahrefloc{sec-subcomponent}{\t{SUBCOMPONENT} tutorial}. \\

  or & \DEFINE{FORCED!SUBCOMPONENT} \ttref{String} \Ob \ttref{value} \Oe &
      See the \ahrefloc{sec-subcomponent}{\t{SUBCOMPONENT} tutorial}. \\

  or & \DEFINE{GROUP} \ttref{String}\Ob \ttref{value} \Oe & Used for grouping components; the user
      will be asked to display these or not. See the \ahrefloc{sec-group}{\t{GROUP}} tutorial. \\

  or & \DEFINE{INSTALL!BY!DEFAULT} &
      If WeiDU would ask the user whether to install this component or not,
      and this component is not already installed, WeiDU will instead
      install it by default (without asking the user). If there is an error
      or the component is already installed, WeiDU will ask the user. The
      \ttref{--uninstall} command-line argument overrides this. See also
      \ttref{REQUIRE!COMPONENT} and \ttref{ALWAYS}.  \\

  or & \DEFINE{DESIGNATED} forcedNumber &
      Normally module components are numbered based on their order in the
      \ttref{TP2} file (starting from 0). This flag sets the current
      component number to forcedNumber. The next component (if it lacks a
      \ttref{DESIGNATED} flag) will be forcedNumber+1. You can easily shoot
      yourself in the foot by setting forcedNumber too low (e.g., so that
      multiple components have the same number). \\

  or & \DEFINE{NO!LOG!RECORD} &
      Normally all module components are recorded in \t{WeiDU.log} and can
      be uninstalled later. This component flag prevents this component
      from writing a log record when it is successfully installed. As a
      result it is ``invisible'' to WeiDU, can be installed multiple times,
      and cannot be uninstalled with WeiDU. \emph{Do not use this flag without
	  a real reason.} \\
  or & \DEFINE{LABEL} \ttref{String} &
      Defines the \t{LABEL}, or unique textual identifier, of this
      module. Any component can have zero or more \t{LABEL}s. Will
      print a warning if two components in the same tp2 share a
      \t{LABEL}. \emph{Do not alter a component's \t{LABEL} once you
        publish that mod}. \\

  or & \DEFINE{METADATA} \ttref{String} &
      Associates a string of metadata with this component. WeiDU does
      not use the metadata for anything, but external programs might.
      \t{METADATA} may be used multiple times per component.\\ \\

\DEFINE{TP2 Action} & &
  A \ttref{TP2 Action} tells WeiDU how to install a component. This usually
  involves copying files and writing in new string references. \\

  is & \DEFINE{COPY} \ttref{optNoBackup}
                     \ttref{optGlob} fromFile toFile ...
       \ttref{patch} \Slist
       \ttref{when} \Slist &

       You may specify as many fromFile-toFile pairs as you like. Each
       fromFile is copied to its associated toFile. If there are any
       WeiDU variables inside explicit \t{\%}s in toFile or fromFile,
       they are replaced by their values. All of the \ttref{patch}es
       are applied. If there are any \ttref{when} conditions and any
       of them are false, the copy does not happen. If fromFile is a
       directory, toFile is also taken to be a directory and all files
       (but not subdirectories) in fromFile are copied to toFile.  A
       typical example is \t{COPY "mymod/sword.itm"
         "override/m\#sword.itm"}.


       \ttref{COPY} commands set the user-defined \DEFINE{SOURCE!DIRECTORY},
       \DEFINE{SOURCE!FILESPEC}, \DEFINE{SOURCE!FILE},
       \DEFINE{SOURCE!RES}, \DEFINE{SOURCE!EXT},
       \DEFINE{DEST!DIRECTORY}, \DEFINE{DEST!FILESPEC},
       \DEFINE{DEST!FILE},\DEFINE{DEST!RES} and \DEFINE{DEST!EXT}
       \ttref{variable}s based on fromFile and toFile as follows. If
       fromFile is \t{mymod/cre/bigboss.cre}, then
       \ttref{SOURCE!DIRECTORY} is \t{mymod/cre},
       \ttref{SOURCE!FILESPEC} is \t{mymod/cre/bigboss.cre},
       \ttref{SOURCE!FILE} is \t{bigboss.cre},
       \ttref{SOURCE!RES} is \t{bigboss} and \ttref{SOURCE!EXT} is \t{cre}.
       The \t{DEST!} variables
       are similarly based on toFile. In addition, \DEFINE{SOURCE!SIZE} is
       set to the size (in bytes) of the source file.


       This is generally only useful if you have enabled globbing. Any
       user-defined \ttref{variable}s in toFile are replaced with their
       values. You may also reference these \ttref{variable}s in
       \ttref{patch}es.


       See the \ahrefloc{sec-module-distribution}{Module Distribution} section for information about
       finding a good unique prefix for your mod-created resources.
       \\
  or & \DEFINE{COPY!EXISTING} \ttref{optNoBackup} fromFile toFile ...
        &
       Behaves like \ttref{COPY} except that the fromFiles are drawn from
       the game \ttref{BIFF}s or \t{override} directory. This is useful for
       making changes to files that other mods may have changed as well.
       \\
  or & \DEFINE{COPY!EXISTING!REGEXP} \ttref{optNoBackup} \ttref{optGlob}
       fromFileRegexp toDirOrFile ... \ttref{patch} \Slist
       \ttref{when} \Slist &
       Behaves like \ttref{COPY!EXISTING} except that fromFileRegexp may
       contain regular expressions (\ttref{regexp}s). Additionally, toDirOrFile
       may reference matched groups in fromFileRegexp with $\backslash$1,
       $\backslash$2, etc. If toDirOrFile is an existing directory or lacks a
       file extension, it will be treated as a directory and all matching files
       in the game \ttref{BIFF}s will be copied there. Otherwise, toDirOrFile
       will be treated as a file.


       If \ttref{GLOB} is specified, matching files in \t{override} will
       also be patched and copied. If a file appears in both the
       \ttref{BIFF}s and the \t{override} folder, it will only be copied
       once. For example, if \t{HARM.ITM} is in the \ttref{BIFF}s and
       \t{HARM2.ITM} is in \t{override}, this code will copy and patch them
       both:

\begin{verbatim}
COPY_EXISTING_REGEXP GLOB ~HARM.*.ITM~ ~override~
  SAY // ... whatever
\end{verbatim}
       \\
  or & \DEFINE{COPY!LARGE} \ttref{optNoBackup} \ttref{optGlob} fromFile toFile ...
       &
       Behaves like \ttref{COPY} except that the fromFiles can be of arbitrary
       size (the limit should be over a Gigabyte), but on the other side of
       the coin you can't apply patches to the copying.

       Like \ttref{COPY}, \ttref{COPY!LARGE} sets the variables
       \ttref{SOURCE!DIRECTORY}, \ttref{SOURCE!FILESPEC}, \ttref{SOURCE!FILE},
       \ttref{SOURCE!RES}, \ttref{SOURCE!EXT}, \ttref{SOURCE!SIZE},
       \ttref{DEST!DIRECTORY}, \ttref{DEST!FILESPEC}, \ttref{DEST!FILE},
       \ttref{DEST!RES} and \ttref{DEST!EXT}.
       \\
  or & \DEFINE{COPY!RANDOM} \t{(} file1 \Slist \t{)}
    \Ob \t{(} fileN \Slist \t{)} \Slist \Oe
       \ttref{patch} \Slist
       \ttref{when} \Slist &
      This command works like \ttref{COPY!EXISTING} but the destination
      for any given source file in the file1-list is some other different
      file in the file1-list. Similarly, the destination for any file in
      the fileN-list is some other file in the fileN-list. This allows you
      to randomly shuffle categories of game resources. \\
  or & \DEFINE{COPY!ALL!GAM!FILES}
       \ttref{patch} \Slist
       \ttref{when} \Slist &
       Copies Default.gam from the biff and the ones in the save/ and mpsave/ saved
       games, applying the list of patches. If there are any \ttref{when} conditions
       and any of them are false, the copy does not happen. \emph{NO BACKUP is applied
       to files in the save/ and mpsave/ directories. The savegame from the biffs is
       backed up as usual.}  \\

  or & \DEFINE{MOVE} \ttref{optNoBackup} fromFile toFile ... \verb+(+ \ttref{directory-file-regexp} \verb+)+ toFile ... &
       If optNoBackup is specified, in addition to the usual effects, fromFile may be moved to toFile even if
       one or both contain spaces in their names. \emph{Do not use this feature without a real reason.}

       You may specify as many fromFile--toFile pairs as you like. Each
       fromFile is moved to its associated toFile.

	   If fromFile is a file, toFile can be a file or a directory; if fromFile is a
	   directory, toFile must be a directory; if fromFile doesn't exist, an error is
	   raised. If toFile already exists, \t{MOVE} is equivalent to \ttref{COPY!LARGE}.

	   \t{MOVE} also supports the \ttref{directory-file-regexp} construct
	   in place of fromFile; in this form, it must be wrapped in parenthesis,
	   toFile must be a directory, and no error is raised if no file is matched. Examples:

\begin{verbatim}
MOVE ~sourceFile~ ~destinationFile~
MOVE ~sourceFile~ ~destinationDirectory~
MOVE ~sourceDirectory~ ~destinationDirectory~
MOVE (~sourceDirectory~ ~^[A-M].*\.itm$~) ~destinationDirectory
\end{verbatim}

       Safety notes: when uninstalling, MOVE is restored first,
       then all generic actions are restored, then \t{AT!*!UNINSTALL} is handled.
       As such, do your \ttref{AT!NOW}, then do your \ttref{COPY}, then do your \t{MOVE}s
       (exception: if you \t{MOVE} for biffing purposes, it is safe to call
       \ttref{MAKE!BIFF} after \t{MOVE}. \emph{Do not use the --make-biff command-line argument}).
       \\

  or & \DEFINE{DELETE} \ttref{optNoBackup} file ... &
  Removes one or more files from the file system. If file is a
  directory, it will be recursively deleted together with anything
  it contains.

        \emph{Do not use without a real reason.}
       \\

  or & \DEFINE{DISABLE!FROM!KEY} file ... &
		Removes one or more files from the chitin.key, while leaving the
		containing bif file itself untouched.

		\emph{Do not use without a real reason.}
       \\

  or & \DEFINE{CREATE} type \Ob \t{VERSION} version \Oe resref \Ob \ttref{patch} \Slist \Oe &

      Creates a new file of the specified type with the resource
      reference resref and a correct file extension for the file
      type. If there are any patches, they are applied to contents of
      the new file. Any existing file with the same name will be
      backed up, as normal. The file will be created structurally
      correct but will contain no non-zero data aside from the
      structural details. The file version will be native to the
      current game, or default to \t{"V1.0"}, but can be overridden
      with the \t{VERSION} option, which takes a string specifying the
      desired version. \ttref{CREATE} supports the file types \t{ARE},
      \t{CRE}, \t{EFF}, \t{ITM}, \t{SPL} and \t{STO} and all their
      known file versions (aside from EFF V1.0, which is never found
      as a file).  \\

  or & \DEFINE{COMPILE} \Ob \t{EVALUATE!BUFFER} \Oe sourceFile \Slist
       \Ob \ttref{patch} \Slist \Oe \Ob \DEFINE{USING} traFile \Slist \Oe &
      This command compiles \ttref{D} and \ttref{BAF} source files. If
      sourceFile is a directory, all \ttref{D} and \ttref{BAF} files within
      that directory are processed individually. If there is \ttref{EVALUATE!BUFFER},
      all \verb+%variables%+ in the files are substituted with their values.

      After the special \ttref{EVALUATE!BUFFER} is executed, all other patches are executed.


      First, this loads all of the traFiles presented. If any of their
      paths contain \t{\%s}, the \t{\%s} is replaced with the
      languageDirectory of from the  \ttref{Language} the user selected.
      If you specified \ttref{AUTO!TRA} \t{mymod/\%s} above, WeiDU will
      also attempt to load \t{mymod/languageDirectory/sourceFile.tra} for
      every sourceFile in the list. Once all of the \ttref{TRA} files are
      loaded, the \ttref{D} and \ttref{BAF} files are compiled. Any
      \ttref{DLG}s or \ttref{BCS}s they create or modify are placed in the
      \t{override} directory.  \\
  or & \DEFINE{CLEAR!MEMORY} & removes all variables from the memory, then
      reloads the automatic ones (\ttref{TP2!AUTHOR}, \ttref{TP2!FILE!NAME}, \ttref{TP2!BASE!NAME},
      \ttref{MOD!FOLDER}, \ttref{LANGUAGE}, \ttref{WEIDU!ARCH},
      \ttref{WEIDU!OS}, \ttref{COMPONENT!NUMBER}, all numeric constants such as \t{NAME1}, the soundsets, or
      \t{SCRIPT!OVERRIDE}). \ttref{INTERACTIVE} is automatically set when you call the
      next component. \emph{Do not use this feature without a real reason.} \\
  or & \DEFINE{CLEAR!ARRAYS} & removes the names and contents of all arrays
      from the memory (while still keeping their values). \\
  or & \DEFINE{CLEAR!CODES} & Removes all loaded functions and macros from the
      memory. \\
  or & \DEFINE{CLEAR!INLINED} & Removes all inlined files from the memory. \\
  or & \DEFINE{CLEAR!EVERYTHING} & Runs \ttref{CLEAR!MEMORY}, \ttref{CLEAR!ARRAY}, \ttref{CLEAR!CODES} and
      \ttref{CLEAR!INLINED}. \\
  or & \DEFINE{CLEAR!IDS!MAP} & force WeiDU to remove all loaded IDSes in memory
      (otherwise, if you compile a script, append to an IDS and compile another script, WeiDU
      will not handle the new IDS entry). \\
  or & \DEFINE{ACTION!CLEAR!ARRAY} \ttref{String} &
    `Forgets' that the array \t{string} exists until its values are recalled.
    The actual variables' values are kept, the only effect is that \t{*PHP!EACH}
    will not consider old values.
  \\
  or & \DEFINE{SILENT} & makes WeiDU skip all messages; it's reenabled once a component
      is installed (or fails to), or a \ttref{PRINT}, \ttref{PATCH!PRINT}, \ttref{VERBOSE} or \ttref{PATCH!VERBOSE} is found. \\
  or & \DEFINE{VERBOSE} & undoes the latest \ttref{SILENT} command. \\
  or & \DEFINE{MKDIR} dirName \Slist &
      Instructs WeiDU to create all of the directories in the list. \\
  or & \DEFINE{RANDOM!SEED} someInteger &
      Sets the random number generator seed to someInteger. This allows you
      to get reproducible results when using random functions. If you
      specify a string that is not a valid integer the system initializes
      itself (e.g., by using the current time).  \\
  or & \DEFINE{ACTION!READLN} \ttref{variable} &
      Waits for the user to provided an enter-terminated string and store it in
      variable. Said string will be stored and re-used during non-interactive reinstalls. See the
      \ahrefloc{sec-readln}{\t{READLN} tutorial}. \\
or & \DEFSYN{APPEND} \ttref{optNoBackup} filename newText \ttref{when} \Slist \Ob \t{KEEP!CRLF} \Oe  &
      If there are no \ttref{when} conditions or they are all true, the
      ASCII text newText is appended to the existing file filename (which
      is read from the game \ttref{BIFF}s or the \t{override} folder).
      Any variables in newText are replaced by their values.

      If \t{KEEP!CRLF} is not present, double newlines in the file
      (but not in newText) will be removed; otherwise, they're kept.

      In any event, if the file ends with CRLF only newText and an ending
      CRLF will be written; otherwise, if the file does not end with CRLF,
      it will be written before newText.
      \\
  or & \DEFINE{APPEND!OUTER} \ttref{optNoBackup} filename newText \ttref{when} \Slist \Ob \t{KEEP!CRLF} \Oe  &
      If there are no \ttref{when} conditions or they are all true, the
      ASCII text newText is appended to the existing file filename (which
      is treated as a path to a file).
      Any variables in newText are replaced by their values.

      If \t{KEEP!CRLF} is not present, double newlines in the file
      (but not in newText) will be removed; otherwise, they're kept.

      In any event, if the file ends with CRLF only newText and an ending
      CRLF will be written; otherwise, if the file does not end with CRLF,
      it will be written before newText.
      \\
  or & \DEFINE{APPEND!COL} \ttref{optNoBackup} filename newText \Ob prepend \Oe \ttref{when} \Slist &
      If there are no \ttref{when} conditions or they are all true, the
      string newText is appended column-wise to the existing file filename (which
      is read from the game \ttref{BIFF}s or the \t{override} folder).
      If filename was:
\begin{verbatim}
A B C
D E F
X Y Z
P Q R
\end{verbatim}
      and newText was \t{"0 1 2 3"}, the result would be:
\begin{verbatim}
A B C 0
D E F 1
X Y Z 2
P Q R 3
\end{verbatim}
      You must have the same number of whitespace-separated words in
      newText as there are columns in filename. Prepend empty cells are
	  assumed to be at the beginning of newText. A cell containing exactly
	  \verb+$+ is printed as empty. \\
  or & \DEFINE{APPEND!COL!OUTER} \ttref{optNoBackup} filename newText \Ob prepend \Oe \ttref{when} \Slist &
      If there are no \ttref{when} conditions or they are all true, the
      string newText is appended column-wise to the existing file filename (which
      is treated as a path to a file).
      If filename was:
\begin{verbatim}
A B C
D E F
X Y Z
P Q R
\end{verbatim}
      and newText was \t{"0 1 2 3"}, the result would be:
\begin{verbatim}
A B C 0
D E F 1
X Y Z 2
P Q R 3
\end{verbatim}
      You must have the same number of whitespace-separated words in
      newText as there are columns in filename. Prepend empty cells are
	  assumed to be at the beginning of newText. A cell containing exactly
	  \verb+$+ is printed as empty. \\

  or & \DEFSYN{EXTEND!TOP} existingBCS newFile \ttref{patch} \Slist \Ob \t{USING} traName \Slist \Oe &
    Loads existingFile (which may be \ttref{BAF} or \ttref{BCS}), prepends
    all of newBCS to the top of it, applies all of the \ttref{patch}es, and
    then copies it to the \t{override} folder. User variables in
    the filenames existingFile and newFile are replaced by their values.
    Use \ttref{EVALUATE!BUFFER} if you want to evaluate variables inside
    the body of newFile before parsing it. \\
  or & \DEFSYN{EXTEND!BOTTOM} existingBCS newFile \ttref{patch} \Slist \Ob \t{USING} traName \Slist \Oe &
    As \ttref{EXTEND!TOP}, but the newFile file is put at the bottom of the
    existingBCS file. User variables in the filenames existingFile and
    newFile are replaced by their values. \\
  or & \DEFINE{EXTEND!TOP!REGEXP} existingBCSregexp newFile \ttref{patch} \Slist \Ob \t{USING} traName \Slist \Oe &
    As \ttref{EXTEND!TOP}, but the newFile file is put at the top of the
    every \ttref{BCS} file that matches the \ttref{regexp}
    existingBCSregexp. \\
  or & \DEFINE{EXTEND!BOTTOM!REGEXP} existingBCSregexp newFile \ttref{patch} \Slist \Ob \t{USING} traName \Slist \Oe &
    See \ttref{EXTEND!TOP!REGEXP}.  \\
  or & \DEFINE{ACTION!IF} \ttref{value} \t{THEN BEGIN}
    \ttref{TP2 Action} \Slist \t{END}
    \Ob \t{ELSE BEGIN} \ttref{TP2 Action} \Slist \t{END} \Oe &
    If \ttref{value} evaluates to true (non-zero), the \ttref{TP2 Action}s
    in the \t{THEN}-branch are executed. Otherwise, if an \t{ELSE}-branch
    is present, its commands are executed. Otherwise nothing happens. \\

  or & \DEFINE{ACTION!MATCH} match-value \t{WITH} \Ob guard-value ...
    \Ob \t{WHEN} condition-\ttref{value} \Oe
    \t{BEGIN} \ttref{TP2 Action} \Slist \t{END} \Oe
    \Ob \t{ANY} condition-\ttref{value} \t{BEGIN} \ttref{TP2 Action}
    \Slist \t{END} \Oe ...
    \t{DEFAULT} \ttref{TP2 Action} \Slist \t{END} &

    The match-value is either a \ttref{value} or a literal expression
    (strings or integers); \ttref{value}s are evaluated, including for
    variables and the array construct, and the result obtained is used
    in the matching.

    Matching is done in order against guard-values for which any
    corresponding condition-value evaluates to true (not 0) and against
    guard-values that lack a condition-value.

    Guard-values are either \ttref{value}s or literal
    expressions. Values are evaluated, including for variables and the
    array construct, and the result is case-insensitively matched as a
    \ttref{regexp} against the match-value.

    Condition-values must be \ttref{value}s and must evaluate to integers.

    \t{ANY} matches any match-value for which the corresponding
    condition-value is true.

    If a match is found, the corresponding action list is executed and
    no further matching is done. If no match is found, the \t{DEFAULT}
    action list is executed.

    See the \ahrefloc{sec-match-and-try}{\t{MATCH} and \t{TRY} tutorial}
    for additional information. \\

  or & \DEFINE{ACTION!TRY} \ttref{TP2 Action} \Slist \t{WITH}
    \Ob guard-\ttref{value} ... \Ob \t{WHEN} condition-\ttref{value}
    \Oe \t{BEGIN} \ttref{TP2 Action} \Slist \t{END} \Oe \Ob \t{ANY}
    condition-\ttref{value} \t{BEGIN} \ttref{TP2 Action} \Slist \t{END}
    \Oe ... \t{DEFAULT} \ttref{TP2 Action} \Slist \t{END} &
    If evaluating the action list results in an error, the error is matched, as per \ttref{ACTION!MATCH}.

    \textbf{N.B.} \t{TRY} is generally \emph{not safe} to use because
    many errors are intended to be fatal and if the mod installation
    were to proceed anyway, it might do so in an inconsistent state,
    with resource leaks or with other errors. \ttref{ACTION!RERAISE}
    mitigates or eliminates these risks, since the unsafe part is
    allowing the installation to continue and re-raising the error
    allows it to fail, like intended.

    See the \ahrefloc{sec-match-and-try}{\t{MATCH} and \t{TRY} tutorial} for additional information.
  \\
  or & \DEFINE{ACTION!RERAISE} &
     When used inside an \ttref{ACTION!TRY}, the matched error is re-raised.

     See the \ahrefloc{sec-match-and-try}{\t{MATCH} and \t{TRY} tutorial} for additional information.
  \\
  or & \DEFINE{AT!EXIT} commandToRun \Ob \t{EXACT} \Oe &
    Whenever this \ttref{component} attempts to be installed, commandToRun
    is executed.  Variables (e.g., \t{\%LANGUAGE\%}) in the string
    commandToRun are replaced by their values. Note that the command is
    executed even if the component does not install correctly, so
    \ttref{AT!EXIT} should probably be the last command in a component.
    \begin{itemize}
    \item
    If commandToRun consists of a single \ttref{TP2} filename, WeiDU will
    enqueue that \ttref{TP2} file and run it when the current one is done
    (asking the user all the standard questions about languages and which
    components to install).
    \item
    If commandToRun consists of the word \t{VIEW} followed by a file, a
    system-specific viewer will be used to present the file to the user.
    For example, on Windows systems \t{notepad} will be used to view
    \t{txt} files and a web browser will be used to view \t{html} files.
    Note: also NOTEPAD and EXPLORER work like this, but use of those are
    reserved to differently able modders.
    \item
    Otherwise, commandToRun is executed by the underlying operating system
    (and is thus system dependant). If you want to do something that
    WeiDU doesn't handle, like extracting WAVs from an MP3, make a batch
    file and run it from here.
    \end{itemize}
    Slashes and backslashes will be converted appropriately for the
    underlying operating system. If \t{EXACT} is specified, \verb+/+
    and \verb+\+ will instead be preserved as they are. The most common usage is:
\begin{verbatim}
AT_INTERACTIVE_EXIT ~VIEW mymod\README.txt~
\end{verbatim}
    This causes your README file to be displayed using a system appropriate
    viewer. Here's a more complicated example that pulls up a
    language-specific README if one is available:
\begin{verbatim}
ACTION_IF FILE_EXISTS ~mymod\README.%LANGUAGE%.txt~ THEN BEGIN
  AT_INTERACTIVE_EXIT ~VIEW mymod\README.%LANGUAGE%.txt~
END ELSE BEGIN
  AT_INTERACTIVE_EXIT ~VIEW mymod\README.txt~
END
\end{verbatim}
    \\
  or & \DEFINE{AT!INTERACTIVE!EXIT} commandToRun \Ob \t{EXACT} \Oe &
    As \ttref{AT!EXIT}, but the command is only executed if the user
    specifically asked for the \ttref{component} to be installed or
    upgraded. \\
  or & \DEFINE{AT!UNINSTALL} commandToRun \Ob \t{EXACT} \Oe &
    As \ttref{AT!EXIT}, but when this \ttref{component} is removed,
    commandToRun is executed.\\
  or & \DEFINE{AT!INTERACTIVE!UNINSTALL} commandToRun \Ob \t{EXACT} \Oe &
    As \ttref{AT!EXIT}, but whenever the user specifically asks for this
    \ttref{component} to be removed, commandToRun is executed.
    Only the \t{\%LANGUAGE\%} variable is guaranteed to be
    replaced, so do not count on any others. \\
  or & \DEFINE{AT!UNINSTALL!EXIT} commandToRun \Ob \t{EXACT} \Oe &
    As \ttref{AT!UNINSTALL}, but executed at the end of the WeiDU run (after
	printing 'SUCCESFULLY INSTALLED xyz').\\
  or & \DEFINE{AT!INTERACTIVE!UNINSTALL!EXIT} commandToRun \Ob \t{EXACT} \Oe &
    As \ttref{AT!UNINSTALL!EXIT}, but only whenever the user specifically asks for this
    \ttref{component} to be removed. \\
  or & \DEFINE{AT!NOW} \Ob \ttref{variable} \Oe commandToRun \Ob \t{EXACT} \Oe &
    As \ttref{AT!EXIT}, but commandToRun is executed when found,
    rather than at the end of the installation. Use with oggdec,
    tisunpack, wav2acm...  but not with readmes (you'll create dozens
    of windows), nor with --make-biff (you'll crash the
    installation). If the optional \ttref{variable} is provided, a TP2
    variable is of that name is assigned the return value of
    commandToRun. \\
  or & \DEFINE{AT!INTERACTIVE!NOW} \Ob \ttref{variable} \Oe commandToRun \Ob \t{EXACT} \Oe &
    As \ttref{AT!NOW}, but commandToRun is executed only if the installation is
    run interactively.\\
  or & \DEFINE{MAKE!BIFF} name-of-biff \t{BEGIN} \ttref{directory-file-regexp} \Slist \t{END} &
    Create a biff \t{Data/name-of-biff.bif} from the files that can be matched by
    directory-file-regexp. The chitin.key file is restored as a normal file, and
    reloaded whenever the component is installed or uninstalled (which means that its
    contents will be available exactly when the biff exists), while the .bif file
    itself is deleted or on uninstall as usual.  \\
  or & \DEFINE{LOAD!TRA} traName \Slist &
    Loads all traName files (variable substitution is done; the file can be inlined)
    to be used in the following tp2 actions, as if you had declared them in \ttref{LANGUAGE}. \\
  or & \DEFINE{WITH!TRA} traName \Slist \t{BEGIN} \ttref{TP2 Action} \Slist \t{END} &
    Creates a new \t{TRA} scope copied from the surrounding scope,
    loads all traName files (variable substitution is done; the file
    can be inlined) and evaluates the \t{TP2 Action}s.  When
    \ttref{WITH!TRA} exits, the new \t{TRA} scope is discarded, that
    is, all \t{TRA} changes made by \ttref{WITH!TRA} or any of its
    enclosed actions are forgotten. \\
  or & \DEFINE{WITH!SCOPE} \t{BEGIN} \ttref{TP2 Action} \Slist \t{END} &
    Creates a new variable scope copied from the surrounding scope
    and evaluates the \t{TP2 Action}s inside the new scope. When
    \ttref{WITH!SCOPE} exits, the new scope is discarded, all
    new variables defined inside the scope and all changes to existing variables
    are forgotten. \\
  or & \DEFINE{UNINSTALL} modToUninstall modComponent &
    If the given component of the given mod is currently installed,
    uninstall it before proceeding. \emph{Do not use this action without
	a real reason.} This
    should only be used if you release a new version of a component under a
    new name. For example, many Tactics Mod components replace old
    Solaufein mod components. In order to prevent such a component from
    being installed twice, the Tactics version uninstalls the Solaufein
    version.  \\
  or & \DEFINE{COPY!KIT} oldKit newKit \verb+(+ diffName diffValue \Slist
  \verb+)+ &
    Copies a copy of the oldKit kit called newKit. This copy is non-player
    selectable, while all other fields can be edited by setting diffName to
    the field to be changed and diffValue to the new value. Valid values for
    diffName are:
\begin{verbatim}
clasweap
weapprof
abclasrq
abclsmod
abdcdsrq
abdcscrq
dualclas
alignmnt
clab
lower
mixed
help
luabbr
25stweap
unusabilities
\end{verbatim}
    Currently, lower, mixed and help can only be numbers referring to a TLK
    string. Unusabilities requires to be both kit and class unusables, there
    isn't a way to \ttref{BAND} or \ttref{BOR} them.
    \\
  or & \DEFINE{ADD!KIT} internalKitName \t{\ttref{String}1}
       \t{\ttref{String}2} \t{\ttref{String}3} \t{\ttref{String}4}
       \t{\ttref{String}6} \t{\ttref{String}7} \t{\ttref{String}8}
       \t{\ttref{String}9} \t{\ttref{String}10} \t{\ttref{String}11}
       \t{\ttref{String}12} \t{\ttref{String}13} \t{SAY} \t{\ttref{text}1}
       \t{SAY} \t{\ttref{text}2} \t{SAY} \t{\ttref{text}3}
  &
    This command allows you to add new kits to the BGII.
    See the example file \t{mymod.tp2} or the tutorial at
    \ahrefurl{\url{http://gibberlings3.net/forums/index.php?showtopic=584}}
    for information on how to do this.

    \ttref{ADD!KIT} sets the variable \t{\%internalKitName\%} to the
    number your kit occupies in \t{kitlist.2da}. This value is exactly
    0x4000 less than the number your kit is assigned in
    \t{kit.ids}. Also observe that the kit DWORD in the \t{CRE} file
    format uses a reversed WORD order, unlike all other fields in the
    \t{CRE} file format.

    Most arguments to \ttref{ADD!KIT} are strings to be appended verbatim to
    \t{2DA} files, detailed as follows:
    \begin{tabular}{l l l}
      \textbf{Argument} & \textbf{\t{2DA} file} & \textbf{Verbatim} \\
      \t{String1} & \t{clasweap} & Yes \\
      \t{String2} & \t{weapprof} & Yes \\
      \t{String3} & \t{abclasrq} & Yes \\
      \t{String4} & \t{abclsmod} & Yes \\
      \t{String5} & \t{abdcdsrq} & Yes \\
      \t{String6} & \t{abdcscrq} & Yes \\
      \t{String7} & \t{alignmnt} & Yes \\
      \t{String8} & \t{dualclas} & Yes \\
      \t{String12} & \t{luabbr} & No \\
      \t{String13} & \t{25stweap} & No \\
    \end{tabular}
    Strings that are appended verbatim need to include the kit name at
    the very start of the string. Strings that are not appended verbatim
    should not include the kit name, as it is added automatically.

    \t{String9} is the path to the CLAB-style \t{2DA} file of your kit.

    \t{String10} is a list of which class and race combinations the kit
    should be available for, as per \t{kittable.2da}.

    \t{String11} is the unusability information and parent class used in
    \t{kitlist.2da}.

    Note that if \t{String12} denotes a custom HLA table, you need to copy
    the new \t{2DA} file into the game manually. \ttref{ADD!KIT} merely
    appends to \t{luabbr.2da}.

    \t{text1}, \t{text2} and \t{text3} are, respectively, the lower name,
    mixed name and description of your kit.

    The BG2: ToB engine cannot handle more than 255 kits installed (if you
    try to check \verb+Kit(Somebody,kit256)+ or \verb+AddKit(kit256)+, the
    game crashes to desktop). As such, WeiDU will currently refuse to
    install a 256th kit. This limitation is lifted on GemRB, or if suitable
    versions of ToB Hacks or ToBEx are installed,
    \\
  or & \DEFINE{ADD!MUSIC} internalMusicName newMUSFile &

     \t{newMUSFile} is copied to the \t{music} directory and added to
     \t{songlist.2da} under the name \t{internalMusicName}. The
     variable \t{\%internalMusicName\%} is set to the number of this
     new entry in \t{songlist.2da}. If \t{newMUSFile} already exists,
     the variable \t{\%internalMusicName\%} is set to the existing
     entry in \t{songlist.2da} and all other operations are
     skipped. Variables are evaluated.

     Some versions of the Infinity Engine cannot handle more than 100
     entries in \t{songlist.2da}. \t{ADD!MUSIC} will fail under
     those circumstances unless the appropriate versions of ToB Hacks
     or ToBEx are installed or the game is GemRB or BGEE.
     \\

  or & \DEFINE{ADD!SCHOOL} schoolName removalString &
	Creates a new (guaranteed-unique) spell school (as per mschool.2da),
	associate removalString (can be a tra reference) to its removal,
	and sets the schoolName variable to the school identifier.



	If  mschool.2da already contains schoolName, the variable is set to
	the school's current identifier and no other operation is performed.
	\\
  or & \DEFINE{ADD!SECTYPE} sectypeName removalString &
	Creates a new (guaranteed-unique) spell secondary type
	(as per msectype.2da), associate removalString (can be a tra reference)
	to its removal, and sets the sectypeName variable to the sectype
	identifier.



	If  msectype.2da already contains sectypeName, the variable is set to
	the sectype's current identifier and no other operation is performed.
	\\
  or & \DEFINE{ADD!AREA!TYPE} areaTypeName &
	Adds a new (guaranteed-unique) area type to areatype.ids, and sets
  the areaTypeName variable to the index of the bit the type is associated
  with: the type can be set with
  \verb+WRITE_SHORT 0x48 THIS | (1 << areaTypeName)+.



	If  areatype.ids already contains areaTypeName, the variable is set to
	the type's current identifier and no other operation is performed.



  Also note that only 8 area types can be added to an unmodded installation
  of BG2; as such, don't add a new area type type unless you really need it
  (most likely, another modder is already using a type with a similar name,
  and you can share the type between your mods without issue).
	\\

  or & \DEFINE{ADD!PROJECTILE} modpath/PROName.PRO &
    Appends an entry for PROName to \t{PROJECTL.IDS} and assigns it the next
    available ProRef number.  Then copies the file \t{modpath/PROName.PRO}
    to the \t{override} folder.  The new ProRef number can be accessed
    through the variable \t{\%PROName\%} and used to updated the
    \t{Projectile type} field of an ITM or SPL file's \t{Item Ability} or
    \t{Spell Ability} sub-structures.  (The hexadecimal offsets for these
    fields can be found using NearInfinity.) In the following example, a
    new PRO file and an ITM file that will use it are added to the game:
\begin{verbatim}
ADD_PROJECTILE      ~MyMod/MYDXP.PRO~
COPY ~MyMod/MYDART.ITM~ ~override/MYDART.ITM~
  WRITE_SHORT   0x09c ~%MYDXP%~
\end{verbatim}
  \\

  or & \DEFINE{ADD!SPELL} modpath/newSPLfile.SPL type level idsName
  \ttref{patch} \Slist \Ob \t{IF!EXISTING} \ttref{patch} \Slist
  \t{END} \Oe \Ob \t{ON!DISABLE} \ttref{patch} \Slist \t{END} \Oe &

  adds newSPLfile as a spell of type and level into the game (IE, SPPR102
  or whatnot), in the first empty slot possible, appends the idsName
  to spell.ids, and sets \verb+%idsName%+ to the 4-digit code
  associated with idsName in Spell.ids. While you copy newSPLfile to
  the override, you also apply the patches listed.



	If Spell.ids already contains a spell named idsName, of the same type and
	level than the one you're adding, then that spell is overwritten (rather
	than adding a duplicate version). If you have the \verb+IF!EXISTING+
	section, its patches are applied to the current version instead.



	If Spell.ids already contains a spell named idsName, but of of different
	type and/or level than the one you're adding, then the current reference
	is removed from spell.ids, and then the action proceeds as usual. In this
	case, if there is the \verb+ON!DISABLE+ section, the patches declared
	there will be applied to the older spell.
	\\

  or & \DEFINE{ADD!JOURNAL} \Ob \t{EXISTING} \Oe \Ob \t{MANAGED} \Oe \Ob
       \t{TITLE} \t{(} \ttref{text} \t{)} \Oe \ttref{reference} \Slist \Ob
       \t{USING} traFile \Slist \Oe &

    If the game is not of an EE-type, this action does nothing.  If
    the game is of an EE-type, this action patches BGEE.SQL or
    BGEE.LUA (depending on game version) with the provided quests and
    journal entries, so they will work with the EE-type journal
    system.

    For each of the provided \ttref{reference}s, which are taken to be
    journal entries, the first line of text, up to a newline character, is
    taken to be the title of the journal entry. Titles isolated in this way
    have any trailing whitespace and full stops trimmed. The title is added
    as a separate string to the TLK, together with the complete journal entry.
    The game files patched with the strrefs of the title and journal entry.
    Each unique title is given a unique quest id and journal entries that
    share titles end up sharing quest ids.

    If \t{EXISTING} is specified, the strref of the title is matched
    against the existing title strrefs. If a match is found, the
    journal entry is added under the quest id of the existing
    quest. Otherwise it is added as a new quest. Note that \t{TITLE}
    should be given a string reference in this case. \t{ADD!JOURNAL}
    cannot guarantee correct results if \t{EXISTING} is used without
    \t{TITLE} or if \t{TITLE} is given a string or tra reference
    instead of a string reference.

    If \t{MANAGED} is specified, all provided journal entries are given a
    unique, non-zero quest-group number. They share the same quest-group
    number regardless of whether they share the same title. If \t{EXISTING}
    is also specified, the quest-group numbers for all existing journal
    entries that match the provided titles are assigned a quest-group
    number, provided they do not already have one. This option does nothing
    unless the game version supports quest groups.

    If \t{TITLE} is specified, the provided \ttref{text} is used as the title
    for all provided journal entries. The titles of each individual journal
    entry remains unchanged, they are just all listed under the same title.

    For more information on \t{ADD!JOURNAL} and some usage examples, refer to
    the journal section of \ahref{\url{http://gibberlings3.net/forums/index.php?showtopic=26671}}{this tutorial}.
    \\

  or & \DEFINE{STRING!SET} indexOrString newValue \Slist
    \Ob \t{USING} traFile \Oe &
    This command replaces each given string in the user's \ttref{TLK} file
    with the associated newValue. If a
    traFile is given, that file is is read once before all of the
    replacements take place and its contents are forgotten after.  \\

  or & \DEFINE{STRING!SET!EVALUATE} \ttref{value} newValue \Slist
    \Ob \t{USING} traFile \Oe &
    This command replaces the string at index value in the user's
    \ttref{TLK} file with the associated newValue. If a traFile is
    given, that file is is read once before all of the replacements
    take place and its contents are forgotten after. If the index
    value equals the current number of strings in the \ttref{TLK} file
    (for example, through \ttref{NEXT!STRREF}), newValue will be added
    to the \ttref{TLK} file as a new string. This addition is made with
    no deduplication. Use with caution, as this will continue to grow
    the \ttref{TLK} file each time the mod is reinstalled.
    \\

  or & \DEFINE{STRING!SET!RANGE} \t{\#}min \t{\#}max \t{USING} traFile &
    For every integer i between min and max (inclusive) we do
    \t{STRING!SET i @i USING traFile} (except that this command should be
    executed more rapidly). The command will fail if \t{@}i is not defined
    (either by traFile or by some other tra file in scope) for some i
    between min and max.  \\

	or & \DEFINE{ALTER!TLK!RANGE} \ttref{value} \ttref{value} \t{BEGIN} \ttref{patch} \Slist \t{END} &
		Executes the given patch list on all the strings *currently* in dialog.tlk between the
		two given values (both inclusive).
		This means that strings added in the current mod installation will not
		be patched, and strings already altered via \ttref{ALTER!TLK}* and/or \ttref{STRING!SET}*
		will be patched from the pre-patch condition.\\

or & \DEFINE{ALTER!TLK!LIST} \t{BEGIN} \ttref{value} \Slist \t{END} \t{BEGIN} \ttref{patch} \Slist \t{END} &
		Executes the given patch list on all the strings *currently* in dialog.tlk from the given list.
		This means that strings added in the current mod installation will not
		be patched, and strings already altered via \ttref{ALTER!TLK}* and/or \ttref{STRING!SET}*
		will be patched from the pre-patch condition. \\

	or & \DEFINE{ALTER!TLK} \t{BEGIN} \ttref{patch} \Slist \t{END} &
		Executes the given patch list on all the strings *currently* in dialog.tlk.
		This means that strings added in the current mod installation will not
		be patched, and strings already altered via \ttref{ALTER!TLK}* and/or \ttref{STRING!SET}*
		will be patched from the pre-patch condition. Consider using
		\ttref{ALTER!TLK!RANGE} with the base game's boundaries instead. \\

  or & \DEFINE{REQUIRE!FILE} filename warningString &
    If filename does not exist (or the bif file is not referenced inside
    the chitin.key), warningString is displayed and this
    \ttref{component} cannot be installed. This is checked before any
    actions are executed. \\
  or & \DEFINE{FORBID!FILE} filename warningString &
    If filename does exist (or the bif file is referenced inside
    the chitin.key), warningString is displayed and this
    \ttref{component} cannot be installed. This is checked before any
    actions are executed. \\
  or & \DEFINE{FAIL} warningString &
    If this \ttref{TP2 Action} is executed, warningString is displayed and
    the \ttref{component} fails to install. \\
  or & \DEFINE{ABORT} string &
    The string is displayed and installation of the component is undone.
    No error is implied. \\
  or & \DEFINE{WARN} displayString &
    The string DisplayString is echoed to the user. Useful for debugging or
    status reports. If displayString contains \t{\%}\ttref{variable}\t{\%}
    references, their values will be displayed. Additionally, INSTALLED WITH
    WARNINGS is printed at the end of the install.
    \\
  or & \DEFINE{PRINT} displayString &
    The string DisplayString is echoed to the user. Useful for debugging or
    status reports. If displayString contains \t{\%}\ttref{variable}\t{\%}
    references, their values will be displayed. \\
  or & \DEFINE{LOG} displayString &
    The string DisplayString is echoed to setup-mymod.debug.
    If displayString contains \t{\%}\ttref{variable}\t{\%}
    references, their values will be displayed. \\
or & \DEFINE{OUTER!TEXT!SPRINT} \ttref{variable} stringWithVars &
  Any WeiDU variables (enclosed in \t{\%}s) inside stringWithVars are
  replaced by their values and the resulting string (constructed at
  mod-installation time!) is assigned to the variable \t{variable}. \\
or & \DEFINE{OUTER!SPRINT} \ttref{variable} stringWithVars &
  Like \ttref{OUTER!TEXT!SPRINT}, but stringWithVars can be an @reference, and will
  break --traify. Use \ttref{OUTER!TEXT!SPRINT} instead. \\
or & \DEFINE{OUTER!SNPRINT} \ttref{value} \ttref{variable} stringWithVars &
  If \ttref{value} evaluates to zero or a positive number, N, the first
  N characters of the evaluated contents of stringWithVars are
  assigned to \ttref{variable}. If \ttref{value} evaluates to a
  negative number, N, it's instead the last N characters. Thus:
\begin{verbatim}
SPRINT author Jason
SNPRINT 3 myvar "1:%author%"
\end{verbatim}
  ... assigns \t{1:J} to \t{myvar}.  \\
or & \DEFINE{OUTER!SET} \ttref{variable} \t{=} \ttref{value} &
  Update \ttref{variable} so that it is equal to \ttref{value}. \\
or & \ttref{OUTER!SET} \ttref{variable} \t{+=} \ttref{value} &
  Equivalent to \t{OUTER_SET variable = variable + value}. \\
or & \ttref{OUTER!SET} \ttref{variable} \t{-=} \ttref{value} &
  Equivalent to \t{OUTER_SET variable = variable - value}. \\
or & \ttref{OUTER!SET} \ttref{variable} \t{*=} \ttref{value} &
  Equivalent to \t{OUTER_SET variable = variable * value}. \\
or & \ttref{OUTER!SET} \ttref{variable} \t{/=} \ttref{value} &
  Equivalent to \t{OUTER_SET variable = variable / value}. \\
or & \ttref{OUTER!SET} \ttref{variable} \t{\&=} \ttref{value} &
  Equivalent to \t{OUTER_SET variable = variable BAND value}. \\
or & \ttref{OUTER!SET} \ttref{variable} \t{|=} \ttref{value} &
  Equivalent to \t{OUTER_SET variable = variable BOR value}. \\
or & \ttref{OUTER!SET} \ttref{variable} \t{<<=} \ttref{value} &
  Equivalent to \t{OUTER_SET variable = variable BLSL value}. \\
or & \ttref{OUTER!SET} \ttref{variable} \t{>>=} \ttref{value} &
  Equivalent to \t{OUTER_SET variable = variable BLSR value}. \\
or & \DEFINE{OUTER!INNER!PATCH} buffString \t{BEGIN} \ttref{patch} \Slist \t{END} &
  Any WeiDU variables inside \t{\%}s within buffString are replaced by
  their values. All of the \ttref{patch}es given are evaluated as if the
  contents of the current file were buffString. Any modifications to
  buffString are thrown away. This is considered an action, not a patch. \\
or & \DEFINE{OUTER!PATCH} buffString \t{BEGIN} \ttref{patch} \Slist \t{END} &
  Equal to \ttref{OUTER!INNER!PATCH}, if you feel that OUTER!INNER sounds wrong. \\
or & \DEFINE{OUTER!INNER!PATCH!SAVE} savevar buffString \t{BEGIN} \ttref{patch} \Slist \t{END} &
  As with \ttref{OUTER!INNER!PATCH}, except that any modifications to buffString are stored inside
  savevar. \\
or & \DEFINE{OUTER!PATCH!SAVE} savevar buffString \t{BEGIN} \ttref{patch} \Slist \t{END} &
  Equal to \ttref{OUTER!INNER!PATCH!SAVE}, if you feel that OUTER!INNER sounds wrong. \\
or & \DEFINE{OUTER!WHILE} \ttref{value} \t{BEGIN}
  \ttref{TP2 Action} \Slist \t{END} &
  If \ttref{value} is non-zero, execute the given \ttref{TP2 Action} \Slist and
  then repeat, re-evaluating the \ttref{value}.
  {\em Be very careful when using this command. } You can easily describe
  an infinite loop. See the \ahrefloc{sec-while}{\t{WHILE}} loop tutorial for more
  information.
  \\
or & \DEFINE{OUTER!FOR} \t{(} \ttref{patch} \Slist \t{;}
                        \ttref{value} \t{;}
                        \ttref{patch} \Slist \t{)}
                  \t{BEGIN} \ttref{TP2 Action} \Slist \t{END} &
  The \ttref{TP2 Action} \t{OUTER!FOR (init;pred;inc) BEGIN body END} is equivalent to
  \t{init WHILE pred BEGIN INNER!ACTION BEGIN body END inc END}, except that
  it's considered an action. Note that the predicate \ttref{value} cannot be empty.  \\
or & \DEFINE{ACTION!BASH!FOR} \ttref{directory-file-regexp} \t{BEGIN} \ttref{TP2 Action} \Slist \t{END} &
  for all files that match \ttref{directory-file-regexp}, sets a bunch of variables
  and executes the actions for each file found. Assuming the file being copied
  is somedir/yourfile.cre, the following variables will be set:
\begin{verbatim}
"%BASH_FOR_DIRECTORY%" = "somedir"
"%BASH_FOR_FILESPEC%" = "somedir/yourfile.cre"
"%BASH_FOR_FILE%" = "yourfile.cre"
"%BASH_FOR_RES%" = "yourfile"
"%BASH_FOR_EXT%" = "cre"
"%BASH_FOR_SIZE%" = <size of somedir/yourfile.cre>
\end{verbatim}                                           \\

or & \DEFINE{ACTION!DEFINE!ARRAY} \t{\ttref{String}1 BEGIN \ttref{String}2} \Slist \t{END} &
	Sets the array \verb+$string1(0)+,\verb+$string1(1)+ etc. to the various elements in string2.
\\
or & \DEFINE{ACTION!SORT!ARRAY!INDICES} \t{\ttref{String}
  \ttref{ArrayIndicesSortType}} &

  Sorts the indices of the array given by String according to the
  order \ttref{ArrayIndicesSortType}. String is evaluated for
  variables and you can use the array construct.\\

or & \DEFINE{GET!FILE!ARRAY} \ttref{String} path \ttref{regexp} &
  The array \verb+$string(0)+, \verb+$string{1}+ etc is set to the file names, including path, that match regexp in path. The path is relative to the installation directory (e.g. save/000000000-Auto-Save).\\
or & \DEFINE{GET!DIRECTORY!ARRAY} \ttref{String} path \ttref{regexp} &
  Like \ttref{GET!FILE!ARRAY} except regexp is matched against directories instead of files.\\
or & \DEFINE{ACTION!DEFINE!ASSOCIATIVE!ARRAY} \t{\ttref{String} BEGIN key1 \Ob , key2 ... \Oe => result1} \Slist \t{END} &
  Sets the array \verb+$string+, indexed by the keys, to the corresponding results. The results can either be \ttref{String}s or \ttref{value}s.
  Example:
\begin{verbatim}
ACTION_DEFINE_ASSOCIATIVE_ARRAY mix_with_blue BEGIN
  red => purple
  yellow => green
END
\end{verbatim}\\
or & \DEFINE{ACTION!FOR!EACH} \t{\ttref{String}1 IN \ttref{String}} \Slist
                              \t{BEGIN} \ttref{TP2 Action} \Slist \t{END} &
    will set the string1 variable to each value in string list and process each action. \\

or & \DEFINE{ACTION!PHP!EACH} \t{\ttref{String}1 AS \ttref{String}2 => \ttref{String}3} \Slist
                              \t{BEGIN} \ttref{TP2 Action} \Slist \t{END} &
    For every value of the string1 array that has been created or read, sets
    \verb+string2!0+ to the first array parameter, \verb+string2!1+ to the second array
    parameter, etc. and string3 to the result of the array. \verb+string2+ will also contain
		the first array parameter (as a synonym of \verb+string2!0+). then executes the
    actions listed. More exhaustive documentation will be provided by SConrad.
\\

or & \DEFINE{INCLUDE} \t{\ttref{String}} \Slist &
    loads the file string as if it were a list of tp2 actions and executes it (as if
		it had been typed inside your tp2).
    These files have by convenience tph as an extension, due to no reason other than
    randomness (you can use .tp1 or .xyzsucks if you're so oriented).
		Please note that, to speed up inclusions, tph files are stored in memory,
	  rather than re-read each time from the hard-disk. If you need automorphing code
		(IE, you want to edit your tph file), you can use \ttref{REINCLUDE} instead. \\
or & \DEFINE{ACTION!INCLUDE} \t{\ttref{String}} \Slist &
    A synonym of \ttref{INCLUDE}.
\\
or & \DEFINE{REINCLUDE} \t{\ttref{String}} \Slist &
    Works like \ttref{INCLUDE}, but loads each time the tph file from the hard disk.
    This is slower, but required if you want to edit your tph file between an
    inclusion and another.
    \\
or & \DEFINE{ACTION!REINCLUDE} \t{\ttref{String}} \Slist &
    A synonym of \ttref{REINCLUDE}.
    \\
  or & \t{<<<<<<<<} fileName fileBody \t{>>>>>>>>} &
    (That's eight (8) angle brackets on each side.)
    For the purposes of copying and compiling files, WeiDU will pretend
    that fileName is a real file with contents fileBody. This allows you to
    define \DEFINE{inlined}\label{inlined} files inside your TP2 file. Such definitions
    must be executed before the \ttref{inlined} file is used. Other operations
    on fileName (such as \ttref{FILE!EXISTS}, \ttref{FILE!MD5} or
    \ttref{FILE!SIZE}) are undefined. Inlined files will be skipped by
    \ttref{COPY!EXISTING!REGEXP} and other ``wildcard'' approaches: you
    must name them directly. Unlike most other WeiDU things,
    spacing matters here. After the initial \t{<<<<<<<<} there can be
    any number of spaces. The first non-space character after the
    \t{<<<<<<<<} is the first character of fileName. All other
    characters up to and excluding the newline on that line are part of
    fileName (and thus fileName cannot start with a space or contain a
    newline). All user variables (e.g., \t{\%foo\%}) in fileName will be
    replaced by their values.
    The fileBody contains all characters after that newline up to
    and excluding the \t{>>>>>>>>}. Note that a single inlined filename
    namespace is shared by WeiDU for all \ttref{TP2} files it reads (it
    might read other \ttref{TP2} files in the process of installing yours
    in order to uninstall or reinstall another mod's components), so it is
    \emph{critically} important that you use some sort of unique prefix.
    I also suggest that you avoid using your mod's actual directory
    structure (if any) in order to avoid confusion with real files.
    Consider using \t{.../yourmod-inlined/fileName}.  Here is a concrete
    working example:
\begin{verbatim}
BEGIN ~MyMod Component 1~

<<<<<<<< .../mymod-inlined/myfile.baf
IF
  True()
THEN
  RESPONSE #100
    Kill("Anomen")
END
>>>>>>>>

COMPILE ~.../mymod-inlined/myfile.baf~
\end{verbatim}
  This inclusion method is eight-bit clean, so if you are very careful you
  can \ahrefloc{inlined}{inline} a binary file (e.g., a \ttref{CRE} or \ttref{BAM}) with
  this method. Be careful to shave off the newline before the \t{>>>>>>>>}
  in such cases. Finally, note that \ttref{inlined} files have the same
  maximum size as other (non-BIFF) WeiDU files and strings (usually about
  16 megs).
\\
or & \DEFINE{ACTION!TO!UPPER} \ttref{variable} &
  Turns to upper-case the contents of \verb+%variable%+ and store the
  results in variable. \\
or & \DEFINE{ACTION!TO!LOWER} \ttref{variable} &
  Turns to lower-case the contents of \verb+%variable%+ and store the
  results in variable. \\
or & \DEFINE{ACTION!GET!STRREF} \ttref{value} \ttref{variable} &

  The string reference value is looked up in \t{DIALOG.TLK} and the
  (male) string (without any quotes) is stored in the variable. \\

or & \DEFINE{ACTION!GET!STRREF!F} \ttref{value} \ttref{variable} &

  The string reference value is looked up in \t{DIALOGF.TLK} and the
  female string (without any quotes) is stored in the variable. If
  there is no \t{DIALOGF.TLK}, the string from \t{DIALOG.TLK} is used
  instead. \\

or & \DEFINE{ACTION!GET!STRREF!S} \ttref{value} \ttref{variable} &

  The string reference value is looked up in \t{DIALOG.TLK} and the
  sound reference associated with the (male) string is stored in the
  variable. If the string has no sound, the empty string
  is used instead. \\

or & \DEFINE{ACTION!GET!STRREF!FS} \ttref {value} \ttref{variable} &

  The string reference value is looked up in \t{DIALOGF.TLK} and the
  sound reference associated with the female string is stored in the
  variable. If there is no \t{DIALOGF.TLK}, the sound reference
  associated with the string from \t{DIALOG.TLK} is used instead. If the
  string has no sound, the empty string is used instead. \\

or & \DEFINE{DECOMPRESS!BIFF} file ... &
  Decompresses one or more biff files from either \t{"BIF V1.0"} or \t{"BIFCV1.0"}
  into \t{"BIFFV1  "}.
  The biff file is looked for in /data and the CD paths specified in baldur.ini. You should
  consequently \emph{not} specify the biff path, merely the name. All matching biff files
  are decompressed, even ones that are duplicated between CD paths. The biff file is backed up
  to another file in the same directory before it is decompressed. Since multiple games
  can share the same biffs, this action is not uninstalled together with the mod.

  WeiDU will raise a Failure exception if the biff is not found in any of the paths.

  Decompressing a biff file can be helpful in preventing crashes related to area files,
  commonly \t{WAV} ambient sounds or \t{TIS} files. \emph{Do not use this action without a real reason.} \\

or & \DEFINE{DEFINE!ACTION!MACRO} \ttref{String} \t{BEGIN}
     \ttref{TP2 Action} \Slist \t{END} &
  Define an action macro. Refer to the \ttref{macros} section for
  additional information. \\
or & \DEFINE{DEFINE!PATCH!MACRO} \ttref{String} \t{BEGIN}
     \ttref{patch} \Slist \t{END} &
  Define a patch macro. Refer to the \ttref{macros} section for
  additional information. \\
or & \DEFINE{DEFINE!ACTION!FUNCTION} \ttref{String}
     \Ob \t{INT!VAR} \ttref{variable} \t{=} \ttref{value} ... \Oe
     \Ob \t{STR!VAR} \ttref{variable} \t{=} \ttref{String} ... \Oe
     \Ob \t{RET} \ttref{variable} ... \Oe
     \Ob \t{RET!ARRAY} \ttref{variable} ... \Oe
     \t{BEGIN} \ttref{TP2 Action} \Slist
     \t{END} &
  Define an action function. Refer to the \ahrefloc{sec-functions}{\t{Functions}} section for
  additional information. \\

or & \DEFINE{DEFINE!DIMORPHIC!FUNCTION} \ttref{String}
     \Ob \t{INT!VAR} \ttref{variable} \t{=} \ttref{value} ... \Oe
     \Ob \t{STR!VAR} \ttref{variable} \t{=} \ttref{String} ... \Oe
     \Ob \t{RET} \ttref{variable} ... \Oe
     \Ob \t{RET!ARRAY} \ttref{variable} ... \Oe
     \t{BEGIN} \ttref{TP2 Action} \Slist
     \t{END} &

     As \ttref{DEFINE!ACTION!FUNCTION}, except the function is additionally
     defined as a PATCH function. \\

or & \DEFINE{DEFINE!PATCH!FUNCTION} \ttref{String}
     \Ob \t{INT!VAR} \ttref{variable} \t{=} \ttref{value} ... \Oe
     \Ob \t{STR!VAR} \ttref{variable} \t{=} \ttref{String} ... \Oe
     \Ob \t{RET} \ttref{variable} ... \Oe
     \Ob \t{RET!ARRAY} \ttref{variable} ... \Oe
     \t{BEGIN} \ttref{patch} \Slist
     \t{END} &
  Define a patch function. Refer to the \ahrefloc{sec-functions}{\t{Functions}} section for
  additional information. \\
or & \DEFINE{LAUNCH!ACTION!MACRO} \ttref{String} &
  Launch an action macro. Refer to the \ttref{macros} section for
  additional information. You may use \DEFINE{LAM} as a synonym for
  \ttref{LAUNCH!ACTION!MACRO}.\\
or & \DEFINE{LAUNCH!ACTION!FUNCTION} \ttref{String}
     \Ob \t{INT!VAR} \ttref{variable} \Ob \t{=} \ttref{value} \Oe ... \Oe
     \Ob \t{STR!VAR} \ttref{variable} \Ob \t{=} \Ob \ttref{EVALUATE!BUFFER}
     \Oe \ttref{String} \Oe ... \Oe
     \Ob \t{RET} \ttref{variable} \Ob \t{=} \ttref{String} \Oe ... \Oe
     \Ob \t{RET!ARRAY} \ttref{variable} \Ob \t{=} \ttref{String} \Oe ... \Oe
     \t{END} &
  Launch an action function. Refer to the \ahrefloc{sec-functions}{\t{Functions}} section for
  additional information. You may use \DEFINE{LAF} as a synonym for
  \ttref{LAUNCH!ACTION!FUNCTION}.\\
or & \DEFINE{ACTION!TIME} \ttref{String} \t{BEGIN} \ttref{TP2 Action}
     \Slist \t{END} &
  Measure the time taken to execute the \ttref{TP2 Action}s and report
  it under the label \ttref{String} together with the other time
  measurements at the end of the mod's debug file.\\

\\

\DEFINE{optNoBackup} & &
  A \ttref{COPY}, \ttref{MOVE} or \ttref{DELETE} command normally makes a backup copy of its target (if one
  exists) so that the mod can be uninstalled later by restoring the backup.
  \\

  is &   & If you don't say anything here, WeiDU {\em will} make a backup
           copy of the file and the \ttref{COPY}, \ttref{MOVE} or \ttref{DELETE} will be undone if the mod
           is uninstalled. \\
  or & \t{+} & If you put a \t{+} here, WeiDU will {\em not} make a backup
           copy of the file and the \ttref{COPY}, \ttref{MOVE} or \ttref{DELETE} will {\em not} be
           undone if the mod is uninstalled. {\em Do not use this feature without
			a real reason.} \\
  or & \t{-} & If you put a \t{-} here, WeiDU will {\em not} copy the file,
           but only store it as an inlined file (so you can patch a file and
           then use it for \ttref{EXTEND!BOTTOM} or whatever).
           This option is not available for \ttref{COPY!LARGE}, \ttref{MOVE} or \ttref{DELETE}. \\
\\

\DEFINE{directory-file-regexp} & & This is a directory path and a \ttref{regexp} string.
It's used by \ttref{MAKE!BIFF}, \ttref{ACTION!BASH!FOR} and \ttref{PATCH!BASH!FOR}
for listing patterns to be matched. Please note that
the directory / filename distinction must be enforced. \\
is & directory \ttref{regexp} & get a list of all files in directory that match \ttref{regexp}.
Case doesn't matter. \\
or & directory \t{EVALUATE!REGEXP} \ttref{regexp} & get a list of all files in directory that match \ttref{regexp}.
Case doesn't matter. This is the same as the above item. \\
or & directory \t{EXACT!MATCH} name & get the file directory/name. Please note that
the directory / filename distinction must be enforced. \\

\\
\DEFINE{optGlob} & &
  A \ttref{COPY} command may use \emph{globbing} to expand filename
  wildcards with respect to files \emph{on the host filesystem}. Unlike
  \ttref{COPY!EXISTING!REGEXP}, glob wildcards do not range over game
  resources. Instead, they range over physical files actually on the disk.
  \\
  is & \DEFINE{GLOB} & Use local filesystem globbing. Globbing is
  generally architecture specific!

  Here is a concrete example. Imagine that \t{CHITIN.KEY} contains
  two files: C1.ITM and C2.ITM. The \t{override} contains C2.ITM and
  C\_MOD.ITM.
\begin{verbatim}
  COPY_EXISTING_REGEXP "C.*.ITM" "override"
    // catches C1.ITM, C2.ITM

  COPY_EXISTING_REGEXP GLOB "C.*.ITM" "override"
    // catches C1.ITM, C2.ITM, C_MOD.ITM

  COPY "override" "override"
    // catches C2.ITM, C_MOD.ITM
\end{verbatim}
  To put it another way: if you do not specify \ttref{GLOB} with
  \ttref{COPY!EXISTING}, WeiDU pretends that the \t{override} directory
  contains 0 files that are not in \t{CHITIN.KEY}. Finally, GLOB has no
  effect on wildcards in the "destination" part of the \ttref{COPY}:
\begin{verbatim}
  COPY GLOB "mymod/foo" "music/*"
    // this is illegal: DO NOT DO THIS
\end{verbatim}

  \\
  or & \DEFINE{NOGLOB} & Never use local file system globbing. \\
  or & & Use sane defaults: enable globbing with \ttref{COPY!EXISTING!REGEXP}, disable
  it with \ttref{COPY}. \\

\\

\DEFINE{optcase} && Allows you to decide whether regexp matching is case-sensitive
or not. \\
is  & & Uses the WeiDU default (which is undocumented and varies with the action).
      Please specify case-sensitiveness manually. \\
or & \DEFINE{CASE!SENSITIVE} & matching is case-sensitive. \\
or & \DEFINE{CASE!INSENSITIVE} & matching is case-insensitive. \\

\\

\\

\DEFINE{optexact} && Allows you to decide whether regexp matching is exact. \\
is  & & Uses the WeiDU default (which is undocumented and varies with the action).
      Please specify matching policy manually. \\
or & \DEFINE{EXACT!MATCH} & only the given string is searched for. \\
or & \DEFINE{EVALUATE!REGEXP} & matching is evaluated following the usual regexp
      conventions. \\

\\

\\

\DEFINE{ArrayIndicesSortType} && Allows you to select how the indices
in an array to be sorted are to be interpreted. \\

is && The default sort is lexicographic, see \ttref{LEXICOGRAPHICALLY}.\\

or & \DEFINE{LEXICOGRAPHICALLY} & The sorting is in ascending
lexicographical order. This means each row of indices are interpreted
as a string and that, for example, 10 is sorted before 2.\\

or & \DEFINE{NUMERICALLY} & The sorting is in ascending numerical
order. This requires that the first column of indices can be
interpreted as numbers; any strings will raise a warning and the sort
order will be undefined. \\

\\

\DEFINE{patch}\label{TP2 Patch} & & A \ttref{patch} tells WeiDU how to modify a file.  \\
is & \DEFSYN{SAY} \ttref{offset} \ttref{text} &
  The string-ref associated with \ttref{text} is written at
  \ttref{offset}. This is commonly used to change the name or
  description of a spell or item. \\
  or & \DEFINE{PATCH!FAIL} warningString &
    If this \ttref{TP2 Action} is execution, warningString is displayed and
    the \ttref{component} fails to install. \\
  or & \DEFINE{PATCH!ABORT} string &
    The string is displayed and installation of the component is undone.
    No error is implied. \\
  or & \DEFINE{PATCH!WARN} displayString &
    The string DisplayString is echoed to the user. Useful for debugging or
    status reports. If displayString contains \t{\%}\ttref{variable}\t{\%}
    references, their values will be displayed. Additionally, INSTALLED WITH
    WARNINGS is printed at the end of the install.
    \\
  or & \DEFINE{PATCH!PRINT} displayString &
  The string DisplayString is echoed to the user. Useful for debugging or
  status reports. If displayString contains \t{\%}\ttref{variable}\t{\%}
  references, their values will be displayed. See also \ttref{PRINT}.
  Example:
\begin{verbatim}
COPY_EXISTING_REGEXP ~.*\.CRE~ ~override~
  READ_BYTE 0x272 race
  READ_BYTE 0x273 class
  PATCH_IF class = 3 THEN BEGIN
    PATCH_PRINT
      ~%SOURCE_FILE% is a cleric with race = %race%.~
  END
\end{verbatim} \\
  or & \DEFINE{PATCH!LOG} displayString &
    The string DisplayString is echoed to setup-mymod.debug.
    If displayString contains \t{\%}\ttref{variable}\t{\%}
    references, their values will be displayed. \\
or & \DEFINE{SAY!EVALUATED} \ttref{offset} stringWithVars &
  Any WeiDU variables (enclosed in \t{\%}s) inside stringWithVars are
  replaced by their values and the resulting string (constructed at
  mod-installation time!) is added to \t{DIALOG.TLK} and its string
  reference it written to the \ttref{offset}. Example:
\begin{verbatim}
COPY_EXISTING_REGEXP ~RING.*.ITM~ ~override~
  READ_LONG 0x38 cost
  SAY_EVALUATED IDENTIFIED_DESC
    ~I Am %SOURCE_RES%, I Cost %cost%~
\end{verbatim} \\
or & \DEFINE{TO!UPPER} \ttref{variable} &
  Turns to upper-case the contents of \verb+%variable%+ and store the
  results in variable. \\
or & \DEFINE{TO!LOWER} \ttref{variable} &
  Turns to lower-case the contents of \verb+%variable%+ and store the
  results in variable. \\
or & \DEFINE{TEXT!SPRINT} \ttref{variable} stringWithVars &
  Any WeiDU variables (enclosed in \t{\%}s) inside stringWithVars are
  replaced by their values and the resulting string (constructed at
  mod-installation time!) is assigned to the variable \t{variable}. \\
or & \DEFINE{SPRINT} \ttref{variable} stringWithVars &
  Like \ttref{TEXT!SPRINT}, but stringWithVars can be an @reference, and will
  break --traify. Use \ttref{TEXT!SPRINT} instead. \\

  or & \DEFINE{SNPRINT} \ttref{value} \ttref{variable} stringWithVars &
  If \ttref{value} evaluates to zero or a positive number, N, the first
  N characters of the evaluated contents of stringWithVars are
  assigned to \ttref{variable}. If \ttref{value} evaluates to a
  negative number, N, it's instead the last N characters. Thus:
\begin{verbatim}
SPRINT author Jason
SNPRINT 3 myvar "1:%author%"
\end{verbatim}
  ... assigns \t{1:J} to \t{myvar}.  \\

or & \DEFINE{SPRINTF} \ttref{variable} stringWithVars
\t{(} \ttref{variable} or \ttref{value}  \Slist \t{)} &
In stringWithVars, any instance of \t{\%s}, \t{\%d} and \t{\%x} will consume
one variable of the list of variables and format the contents of the variable
as a string, decimal number or hexadecimal number, respectively. Any normal text
in stringWithVars is reproduced verbatim. Variables enclosed in \t{\%} are not
evaluated. The result is stored in the variable given as the first argument.
\begin{verbatim}
SET ten = 10
SPRINTF foo "%s %d %x quux" ("bar" 10 ten)
\end{verbatim}
will set the variable \t{foo} to the string \verb+~bar 10 0xa quux~+ \\

or & \DEFINE{SOURCE!BIFF} \ttref{variable} filename &
  If filename is in a biff (whether it is also in the override or not), sets
  variable to the name of the containing biff (the name is printed as E.G.
  \verb+data/items.bif+).
\\
or & \DEFINE{SPACES} \ttref{variable} stringWithVars &
  \verb+%variable%+ will be inited to a string the same length as stringWithVars,
  but made entirely of spaces. \verb+SPACES var ~123~+ will create \verb+%var% = "   "+.
\\
or & \DEFINE{QUOTE} \ttref{variable} stringWithVars &
  \verb+%variable%+ will be inited to a string that will match exactly stringWithVars.
  \verb+QUOTE var ~some\thing^~+ will create \verb+%var% = "some\\thing\^"+.
\\
or & \DEFSYN{REPLACE} \ttref{optcase} \ttref{optexact} \ttref{regexp} \ttref{text}
   &
  All occurrences of \ttref{regexp} in the file are replaced with the ASCII
  printing of the string reference for \ttref{text}. So if \ttref{regexp}
  is "FRED" and the \ttref{text} ends up being strref \#1234, "FRED" will
  be replaced with "1234". This is usually used to replace string
  references in \ttref{BCS} files (where they are stored textually). Put a
  command like \t{DisplayString(Myself,99999)} in your \ttref{BCS} file
  and use something like \t{REPLACE 99999 "Hello, World"}. \\
or & \DEFINE{REPLACE!TEXTUALLY} \ttref{optcase}  \ttref{optexact}
    \ttref{regexp} string \Ob \t{(} \t{sizeValue} \t{)} \Oe &
  All occurrences of the given \ttref{regexp} in the file are replaced with
  the given string.
  \ttref{variable}
  substitution (e.g., kit and music names) is performed on both the
  string and the regexp.
  If you use the sizeValue field, optexact is automatically set to true (IE
  without regexp patterns). The regexp and the string are padded by zeros to
  be long exactly sizeValue bytes. \\
or & \DEFINE{EVALUATE!BUFFER!SPECIAL} string &
  String must be one character long. Any WeiDU variables (like \t{XmyvarX})
	inside the current file are replaced by their values, where X is to be intended
	as string. Example:
\begin{verbatim}
<<<<<<<< .../mymod-inlined/script.baf
IF
  See($myvar$)
THEN
  RESPONSE #100
    Kill(%myvar%)
END
>>>>>>>>
EXTEND_TOP ~sola.bcs~ ~.../mymod-inlined/script.baf~
  SPRINT myvar = ~"Anomen"~
  EVALUATE_BUFFER_SPECIAL ~$~
\end{verbatim}
	\t{$myvar$} will be substituted with Anomen, but \t{\%myvar\%} will be not.

	\emph{Do not use this without a real reason.}
\\
or & \DEFINE{EVALUATE!BUFFER} &
  Any WeiDU variables (like \t{\%myvar\%}) inside the current file (which
  should probably be a plain text file in order for this to make much sense)
  are replaced by their values. Example:
\begin{verbatim}
<<<<<<<< .../mymod-inlined/script.baf
IF
  See(%myvar%)
THEN
  RESPONSE #100
    Kill(%myvar%)
END
>>>>>>>>
EXTEND_TOP ~sola.bcs~ ~.../mymod-inlined/script.baf~
  SPRINT myvar = ~"Anomen"~
  EVALUATE_BUFFER
\end{verbatim}
  Those two actions extend the top of \t{sola.bcs} with the script
  block \t{IF See("Anomen") THEN RESPONSE \#100 Kill("Anomen") END}.
  You can also use \ttref{EVALUATE!BUFFER} in \ttref{COMPILE} actions
  or before strings in \ttref{value}s. You may use \DEFINE{EVAL} as
  a synonym for \t{EVALUATE!BUFFER}.
  \\

or & \DEFINE{APPLY!BCS!PATCH} patchFile &
  Applies patchFile to the current file. See \ttref{--bcmp-from} and similar
  command-line arguments for constructing these patches. \\
or & \DEFINE{APPLY!BCS!PATCH!OR!COPY} patchFile copyFile &
  Applies patchFile to the current file, as \ttref{APPLY!BCS!PATCH}.
  However, if the patching fails the current file is replaced with copyFile
  instead. \\
or & \DEFINE{WRITE!BYTE} \ttref{offset} \ttref{value} &
  The first argument is the offset at which the second argument (an 8-bit
  byte value) is written. Performs \verb+READ!BYTE offset THIS+ and
  \verb+READ!SBYTE offset STHIS+ automatically (you can now write
  \verb+WRITE!BYTE 100 THIS + 2).  \\
or & \DEFINE{WRITE!SHORT} \ttref{offset} \ttref{value} &
  The first argument is the offset at which the second argument (a 16-bit
  short value) is written. Performs \verb+READ!SHORT offset THIS+ and
  \verb+READ!SSHORT offset STHIS+ automatically. \\
or & \DEFINE{WRITE!LONG} \ttref{offset} \ttref{value} &
  The first argument is the offset at which the second argument (a 32-bit
  long word value) is written. Performs \verb+READ!LONG offset THIS+ and
  \verb+READ!SLONG offset STHIS+ automatically. \\
or & \DEFINE{WRITE!ASCII} \ttref{offset} ascString
    \Ob \t{\#requiredSize} \Oe &
  The ASCII ascString is written to the file starting at offset.
  If you specify a \t{requiredSize} then exactly that many bytes are
  written (if ascString is smaller, it is padded with \t{NUL}s; if
  ascString is larger, it is truncated). If you do not specify a requiredSize,
  the terminating \t{NUL} is not written. \\
or & \DEFINE{WRITE!ASCII!LIST} \ttref{offset} ascString \Slist &
  The given ASCII strings are written at offset, offset + 8, offset + 16...
  Automatically evaluates variables. You may use \DEFINE{WRITE!ASCIIL}
  as a synonym for \ttref{WRITE!ASCII!LIST}.\\
or & \DEFINE{WRITE!ASCII!TERMINATE} \ttref{offset} ascString &
  The ASCII ascString is written to the file starting at offset.
  The terminating \t{NUL} \emph{is} written. You may use
  \DEFINE{WRITE!ASCIIT} as a synonym for \ttref{WRITE!ASCII!TERMINATE}. \\
or & \DEFINE{WRITE!EVALUATED!ASCII} \ttref{offset} ascString
    \Ob \t{\#requiredSize} \Oe &
  The ASCII ascString is evaluated (so \t{\%variable\%} is replaced by its
  value) and written to the file starting at offset (as in
  \ttref{WRITE!ASCII}). You may use \DEFINE{WRITE!ASCIIE} as a synonym
  for \ttref{WRITE!EVALUATED!ASCII}. \\
or & \DEFINE{WRITE!FILE} \ttref{offset} filename &
  The entire contents of ``filename'' (which may contain variables) are
  loaded and copied over the current file starting at offset
  \ttref{offset}. ``filename'' must be a literal filename like
  \t{mymod/data/file.bam}. If there is not enough room between
  \ttref{offset} and the end of the file for the contents of ``filename''
  the \ttref{patch} will fail with an error message. \\
or & \DEFINE{INSERT!FILE} \ttref{offset} filename &
  Just like \ttref{WRITE!FILE} except that the entire contents of
  ``filename'' are inserted at \ttref{offset}, just as if you had done an
  \ttref{INSERT!BYTES} with the size of ``filename'' to that \ttref{offset}
  followed by a \ttref{WRITE!FILE} to that \ttref{offset}. \\

  or & \DEFINE{APPEND!FILE} \Ob \t{TEXT} \Oe filename &

  Appends the contents of filename onto the current file. If \t{TEXT}
  is specified, the contents of filename and the current file is
  separated by a newline character (LF) unless the first character of
  filename or the last character of the current file is a newline
  character. \\

  or & \DEFINE{APPEND!FILE!EVALUATE} \Ob \t{TEXT} \Oe filename &

  Just like \ttref{APPEND!FILE} except that \verb+%variables%+ in the
  contents of filename are evaluated before the appending. \\

or & \DEFINE{REPLACE!BCS!BLOCK} \Ob \t{EVALUATE!BUFFER} \Oe \ttref{optcase}
     oldFile newFile \Ob \t{ON!MISMATCH} \ttref{patch} \Slist \t{END} \Oe &
  If the current file is a \ttref{BCS} file, the segment of it
  corresponding to oldFile is replaced with the contents of newFile.
  Multiple blocks can be replaced if they are contiguous and in order.
  oldFile and newFile may be \ttref{BCS} or \ttref{BAF} files. If they
  are \ttref{BAF} files they will not get the benefit of \ttref{AUTO!TRA}.

  If \ttref{EVALUATE!BUFFER} is given, variables inside oldFile and newFile are
  evaluated, but only they are \ttref{BAF} files.

  If the segment corresponding to oldFile is not found and the
  \t{ON!MISMATCH} section is present, those patches are run; if
  oldFile is not found and \t{ON!MISMATCH} is not present, a warning
  message is printed.

  You may use \DEFINE{R!B!B} as a synonym for \ttref{REPLACE!BCS!BLOCK}.
  \\
or & \DEFINE{INSERT!BYTES} \ttref{offset} \ttref{value} &
  The first argument is the offset, the second argument is the count.
  The file will be expanded at the given offset with count bytes worth of
  zeroes. \\
or & \DEFINE{DELETE!BYTES} \ttref{offset} \ttref{value} &
  The first argument is the offset, the second argument is the count.
  The file will shrink as count bytes are deleted starting at the given
  offset. \\
or & \DEFINE{READ!BYTE} \ttref{offset} \ttref{variable} \Ob \t{ELSE}
\ttref{value} \Oe &
  An 8-bit value is read from the file at the given \ttref{offset} and is stored
  in the given \ttref{variable}. If \ttref{offset} is out-of-bounds and the
  \t{ELSE} is present, the \t{ELSE}-\ttref{value} is assigned to
  \ttref{variable}. If \ttref{offset} is out-of-bounds and the \t{ELSE} is
  not present, the \ttref{patch} fails with a visible error.  \\
or & \DEFINE{READ!SBYTE} \ttref{offset} \ttref{variable} \Ob \t{ELSE}
\ttref{value} \Oe &
  As \ttref{READ!BYTE}, but the value is interpreted as signed. \\
or & \DEFINE{READ!SHORT} \ttref{offset} \ttref{variable} \Ob \t{ELSE}
\ttref{value} \Oe &
  A 16-bit value is read from the file at the given \ttref{offset} and is
  stored in the given \ttref{variable}. See \ttref{READ!BYTE}. \\
or & \DEFINE{READ!SSHORT} \ttref{offset} \ttref{variable} \Ob \t{ELSE}
\ttref{value} \Oe &
  As \ttref{READ!SHORT}, but the value is interpreted as signed. \\
or & \DEFINE{READ!LONG} \ttref{offset} \ttref{variable} \Ob \t{ELSE}
\ttref{value} \Oe &
  A 32-bit value is read from the file at the given \ttref{offset}
  and is stored in the given \ttref{variable}. See \ttref{READ!BYTE}. \\
or & \DEFINE{READ!SLONG} \ttref{offset} \ttref{variable} \Ob \t{ELSE}
\ttref{value} \Oe &
  As \ttref{READ!LONG}, but the value is interpreted as signed. \\
or & \DEFINE{READ!ASCII} \ttref{offset} \ttref{variable} \Ob \t{ELSE}
  \t{string} \Oe \Ob \t{(} \ttref{value} \t{)} \Ob \t{NULL} \Oe \Oe &
    A nul-terminated string is read from the file at
    the given \ttref{offset} and is stored in the given \ttref{variable}.
    The terminating nul is not stored. The default read size is 8 bytes.
    If an explicit size \ttref{value} is specified then that many bytes are read
    into the \ttref{variable}, even if some of them are nuls, except if \t{NULL}
    is present, in which case a nul-terminated string is read, without storing
    the terminating null. See
  \ttref{READ!BYTE}.  If the \ttref{offset} is out-of-bounds and the
  \t{ELSE} clause is present, the \t{string} is evaluated as in
  \t{WRITE!EVALUATED!ASCII} and then assigned into \ttref{variable}.
  \\
or & \DEFINE{READ!STRREF} \ttref{offset} \ttref{variable} \Ob \t{ELSE}
\t{string} \Oe &

  A 32-bit Infinity Engine string reference is read from the
  file at the given offset. The string reference is looked up in
  \t{DIALOG.TLK} and the (male) string (without any quotes) is
  stored in the variable. In some sense this is the opposite of
  \ttref{SAY!EVALUATED}. \\

or & \DEFINE{READ!STRREF!F} \ttref{offset} \ttref{variable} \Ob \t{ELSE} \t{string} \Oe &

  A 32-bit Infinity Engine string reference is read from the file at
  the given offset. The string reference is looked up in
  \t{DIALOGF.TLK} and the female string (without any quotes) is stored
  in the variable. \\

or & \DEFINE{READ!STRREF!S} \ttref{offset} \ttref{variable} \Ob \t{ELSE} \t{string} \Oe &

  A 32-bit Infinity Engine string reference is read from the file at
  the given offset. The string reference is looked up in
  \t{DIALOG.TLK} and the sound reference associated with the (male)
  string is stored in the variable. If the string has no sound, the
  empty string is used instead. \\

or & \DEFINE{READ!STRREF!FS} \ttref{offset} \ttref{variable} \Ob \t{ELSE} \t{string} \Oe &

  A 32-bit Infinity Engine string reference is read from the file at
  the given offset. The string reference is looked up in
  \t{DIALOGF.TLK} and the sound reference associated with the female
  string is stored in the variable. If there is no \t{DIALOGF.TLK},
  the sound reference associated with the string from \t{DIALOG.TLK}
  is used instead. If the string has no sound, the empty string is
  used instead. \\

or & \DEFINE{GET!OFFSET!ARRAY} \ttref{String} \t{seven \ttref{value}s} &
  The seven values are:
\begin{verbatim}
1. Offset
2. Read length of "Offset"
3. Iterations
4. Read length of "Iterations"
5. Index
6. Read length of "Index"
7. Length between iterations.
\end{verbatim}

WeiDU comes with a number of pre-defined sets of values for \t{GET!OFFSET!ARRAY}. These sets are:
\begin{verbatim}
ARE_V10_ACTORS (0x54 4 0x58 2 0 0 0x110)
ARE_V10_REGIONS (0x5c 4 0x5a 2 0 0 0xc4)
ARE_V10_SPAWN_POINTS (0x60 4 0x64 4 0 0 0xc8)
ARE_V10_ENTRANCES (0x68 4 0x6c 4 0 0 0x68)
ARE_V10_CONTAINERS (0x70 4 0x74 2 0 0 0xc0)
ARE_V10_AMBIENTS (0x84 4 0x82 2 0 0 0xd4)
ARE_V10_DOORS (0xa8 4 0xa4 4 0 0 0xc8)
ARE_V10_ANIMATIONS (0xb0 4 0xac 4 0 0 0x4c)

ARE_V91_ACTORS (0x64 4 0x68 2 0 0 0x110)

CRE_V10_KNOWN_SPELLS (0x2a0 4 0x2a4 4 0 0 0xc)
CRE_V10_SPELL_MEM_INFO (0x2a8 4 0x2ac 4 0 0 0x10)
CRE_V10_EFFECTS (0x2c4 4 0x2c8 4 0 0 0x108)
CRE_V10_ITEMS (0x2bc 4 0x2c0 4 0 0 0x14)

ITM_V10_HEADERS (0x64 4 0x68 2 0 0 0x38)
ITM_V10_GEN_EFFECTS (0x6a 4 0x70 2 0x6e 2 0x30)

SPL_V10_HEADERS (0x64 4 0x68 2 0 0 0x28)
SPL_V10_GEN_EFFECTS (0x6a 4 0x70 2 0x6e 2 0x30)

STO_V10_ITEMS_PURCHASED (0x2c 4 0x30 4 0 0 0x4)
STO_V10_ITEMS_SOLD (0x34 4 0x38 4 0 0 0x1c)
STO_V10_DRINKS (0x4c 4 0x50 4 0 0 0x14)
STO_V10_CURES (0x70 4 0x74 4 0 0 0xc)

WMP_AREAS (0x34 4 0x30 4 0 0 0xf0)
WMP_LINKS (0x38 4 0x3c 4 0 0 0xd8)
\end{verbatim}

\t{GET!OFFSET!ARRAY} performs "Iterations" number of reads and sets the array \verb+$string(0)+, \verb+$string(1)+ etc to the result of these reads. A more detailed explanation can be had in the \ahrefloc{sec-get-offset-array12}{\t{GET!OFFSET!ARRAY} and \t{GET!OFFSET!ARRAY2} tutorial}.\\

or & \DEFINE{GET!OFFSET!ARRAY2} \ttref{String} \t{eight \ttref{value}s} &
  The eight values are:
\begin{verbatim}
1. Offset2
2. Offset
3. Read length of "Offset"
4. Iterations
5. Read length of "Iterations"
6. Index
7. Read length of "Index"
8. Length between iterations
\end{verbatim}

WeiDU comes with a number of pre-defined sets of values for \t{GET!OFFSET!ARRAY2}. These sets are:
\begin{verbatim}
ARE_V10_ITEMS (0x78 4 0x44 4 0x40 4 0x14)
ARE_V10_REGION_VERTICES (0x7c 4 0x2a 2 0x2c 4 0x4)
ARE_V10_CONTAINER_VERTICES (0x7c 4 0x54 2 0x50 4 0x4)
ARE_V10_DOOR_OPEN_OUTLINE_VERTICES (0x7c 4 0x30 2 0x2c 4 0x4)
ARE_V10_DOOR_CLOSED_OUTLINE_VERTICES (0x7c 4 0x32 2 0x34 4 0x4)
ARE_V10_DOOR_OPEN_CELL_VERTICES (0x7c 4 0x4c 2 0x48 4 0x4)
ARE_V10_DOOR_CLOSED_CELL_VERTICES (0x7c 4 0x4e 2 0x50 4 0x4)

CRE_V10_SPELL_MEM (0x2b0 4 0xc 4 0x8 4 0xc)

ITM_V10_HEAD_EFFECTS (0x6a 4 0x1e 2 0x20 2 0x30)

SPL_V10_HEAD_EFFECTS (0x6a 4 0x1e 2 0x20 2 0x30)

WMP_NORTH_LINKS (0x38 4 0x54 4 0x50 4 0xd8)
WMP_WEST_LINKS (0x38 4 0x5c 4 0x58 4 0xd8)
WMP_SOUTH_LINKS (0x38 4 0x64 4 0x60 4 0xd8)
WMP_EAST_LINKS (0x38 4 0x6c 4 0x68 4 0xd8)
\end{verbatim}
As you can see, the value for Offset2 isn't included in the sets, since it varies.

"Offset2" corresponds to the result from \ttref{GET!OFFSET!ARRAY}. "Offset" is read from the start of the file. "Iterations" and "Index" are read from Offset2 + value. Apart from that \t{GET!OFFSET!ARRAY2} functions like \ttref{GET!OFFSET!ARRAY}. A more detailed explanation can be had in the \ahrefloc{sec-get-offset-array12}{\t{GET!OFFSET!ARRAY} and \t{GET!OFFSET!ARRAY2} tutorial}.\\

or & \DEFINE{DEFINE!ASSOCIATIVE!ARRAY} \t{\ttref{String} BEGIN key1 \Ob , key2 ... \Oe => result1} \Slist \t{END} &
  Sets the array \verb+$string+, indexed by the keys, to the corresponding results. The results can either be \ttref{String}s or \ttref{value}s.
  Example:
\begin{verbatim}
DEFINE_ASSOCIATIVE_ARRAY mix_with_blue BEGIN
  red => purple
  yellow => green
END
\end{verbatim}
You may use \DEFINE{PATCH!DEFINE!ASSOCIATIVE!ARRAY} as a synonym for \ttref{DEFINE!ASSOCIATIVE!ARRAY}.
\\

or & \DEFINE{GET!STRREF} \ttref{value} \ttref{variable} &

  The string reference value is looked up in \t{DIALOG.TLK} and the
  (male) string (without any quotes) is stored in the variable. \\

or & \DEFINE{GET!STRREF!F} \ttref{value} \ttref{variable} &

  The string reference value is looked up in \t{DIALOGF.TLK} and the
  female string (without any quotes) is stored in the variable. If
  there is no \t{DIALOGF.TLK}, the string from \t{DIALOG.TLK} is used
  instead. \\

or & \DEFINE{GET!STRREF!S} \ttref{value} \ttref{variable} &

  The string reference value is looked up in \t{DIALOG.TLK} and the
  sound reference associated with the (male) string is stored in the
  variable. If the string has no sound, the empty string
  is used instead. \\

or & \DEFINE{GET!STRREF!FS} \ttref{value} \ttref{variable} &

  The string reference value is looked up in \t{DIALOGF.TLK} and the
  sound reference associated with the female string is stored in the
  variable. If there is not \t{DIALOGF.TLK}, the sound reference
  associated with the string from \t{DIALOG.TLK} is used instead. If the
  string has no sound, the empty string is used instead. \\

or & \DEFINE{SET} \ttref{variable} \t{=} \ttref{value} &
  Update \ttref{variable} so that it is equal to \ttref{value}. \\
or & \ttref{variable} \t{=} \ttref{value} &
  Update \ttref{variable} so that it is equal to \ttref{value}. \\
or & \Ob \ttref{SET} \Oe \ttref{variable} \t{+=} \ttref{value} &
  Equivalent to \t{SET variable = variable + value}. \\
or & \Ob \ttref{SET} \Oe \ttref{variable} \t{-=} \ttref{value} &
  Equivalent to \t{SET variable = variable - value}. \\
or & \Ob \ttref{SET} \Oe \ttref{variable} \t{*=} \ttref{value} &
  Equivalent to \t{SET variable = variable * value}. \\
or & \Ob \ttref{SET} \Oe \ttref{variable} \t{/=} \ttref{value} &
  Equivalent to \t{SET variable = variable / value}. \\
or & \Ob \ttref{SET} \Oe \ttref{variable} \t{\&=} \ttref{value} &
  Equivalent to \t{SET variable = variable BAND value}. \\
or & \Ob \ttref{SET} \Oe \ttref{variable} \t{|=} \ttref{value} &
  Equivalent to \t{SET variable = variable BOR value}. \\
or & \Ob \ttref{SET} \Oe \ttref{variable} \t{<<=} \ttref{value} &
  Equivalent to \t{SET variable = variable BLSL value}. \\
or & \Ob \ttref{SET} \Oe \ttref{variable} \t{>>=} \ttref{value} &
  Equivalent to \t{SET variable = variable BLSR value}. \\

or & \DEFINE{WHILE} \ttref{value} \t{BEGIN}
  \ttref{patch} \Slist \t{END} &
  If \ttref{value} is non-zero, execute the given \ttref{patch} \Slist and
  then repeat, re-evaluating the \ttref{value}.
  {\em Be very careful when using this command. } You can easily describe
  an infinite loop. See the \ahrefloc{sec-while}{\t{WHILE}} loop tutorial for more
  information.
  \\
or & \DEFINE{FOR} \t{(} \ttref{patch} \Slist \t{;}
                        \ttref{value} \t{;}
                        \ttref{patch} \Slist \t{)}
                  \t{BEGIN} \ttref{patch} \Slist \t{END} &
  The \ttref{patch} \t{FOR (init;pred;inc) BEGIN body END} is equivalent to
  \t{init WHILE pred BEGIN body inc END}. Note that the predicate
  \ttref{value} cannot be empty.  \\
or & \DEFINE{PATCH!BASH!FOR} \ttref{directory-file-regexp} \t{BEGIN} \ttref{patch} \Slist \t{END} &
  for all files that match \ttref{directory-file-regexp}, sets a bunch of variables
  and executes the patches for each file found. Assuming the file being copied
  is somedir/yourfile.cre, the following variables will be set:
\begin{verbatim}
"%BASH_FOR_DIRECTORY%" = "somedir"
"%BASH_FOR_FILESPEC%" = "somedir/yourfile.cre"
"%BASH_FOR_FILE%" = "yourfile.cre"
"%BASH_FOR_RES%" = "yourfile"
"%BASH_FOR_EXT%" = "cre"
"%BASH_FOR_SIZE%" = <size of somedir/yourfile.cre>
\end{verbatim}            \\

or & \DEFINE{DEFINE!ARRAY} \t{\ttref{String}1 BEGIN \ttref{String}2} \Slist \t{END} &
	Sets the array \verb+$string1(0)+,\verb+$string1(1)+ etc. to the various elements in string2.
\\

or & \DEFINE{PATCH!DEFINE!ARRAY} \t{\ttref{String}1 BEGIN \ttref{String}2 \Slist END} &
	Same as \ttref{DEFINE!ARRAY}.
\\

or & \DEFINE{SORT!ARRAY!INDICES} \t{\ttref{String}} &

  Semantically identical to \ttref{ACTION!SORT!ARRAY!INDICES}\\

or & \DEFINE{PATCH!FOR!EACH} \t{\ttref{String}1 IN \ttref{String}} \Slist
                             \t{BEGIN} \ttref{patch} \Slist \t{END} &
    will set the string1 variable to each value in string list and process each patch. \\

or & \DEFINE{PHP!EACH} \t{\ttref{String}1 AS \ttref{String}2 => \ttref{String}3} \Slist
                       \t{BEGIN} \ttref{patch} \Slist \t{END} &
    For every value of the string1 array that has been created or read, sets
    string2!0 to the first array parameter, string2!1 to the second array
    parameter, etc. and string3 to the result of the array. \verb+string2+ will also contain
		the first array parameter (as a synonym of \verb+string2!0+). then executes the
    patches listed. More exhaustive documentation will be provided by SConrad.
\\

or & \DEFINE{PATCH!PHP!EACH} \t{\ttref{String}1 AS \ttref{String}2 => \ttref{String}3} \Slist
                             \t{BEGIN} \ttref{patch} \Slist \t{END} &
    A synonym of \ttref{PHP!EACH}.
\\

or & \DEFINE{CLEAR!ARRAY} \ttref{String} &
    `Forgets' that the array \t{string} exists until its values are recalled.
    The actual variables' values are kept, the only effect is that \t{*PHP!EACH}
    will not consider old values.
\\

or & \DEFINE{PATCH!CLEAR!ARRAY} \ttref{String} &
    A synonym of \ttref{CLEAR!ARRAY}.
\\


or & \DEFINE{PATCH!IF} \ttref{value} \Ob \t{THEN} \Oe \t{BEGIN}
  \ttref{patch} \Slist \t{END}
  \Ob \t{ELSE} \t{BEGIN} \ttref{patch} \Slist \t{END} \Oe
  &
  If \ttref{value} is non-zero, execute the first \ttref{patch} \Slist
  once. Otherwise, execute the second \ttref{patch} \Slist (if any). As a
  convenient shorthand, you may omit the \t{BEGIN}-\t{END} in the \t{ELSE}
  branch if the \t{ELSE} branch contains exactly one \t{patch}.
  \\
  or & \DEFINE{PATCH!MATCH} match-value \t{WITH} \Ob guard-value ...
    \Ob \t{WHEN} condition-\ttref{value} \Oe \t{BEGIN} \ttref{patch}
    \Slist \t{END} \Oe \Ob \t{ANY} condition-\ttref{value} \t{BEGIN}
    \ttref{patch} \Slist \t{END} \Oe ... \t{DEFAULT} \ttref{patch}
    \Slist \t{END} &

    The match-value is either a \ttref{value} or a literal expression
    (strings or integers); \ttref{value}s are evaluated, including for
    variables and the array construct, and the result obtained is used
    in the matching.

    Matching is done in order against guard-values for which any
    corresponding condition-value evaluates to true (not 0) and against
    guard-values that lack a condition-value.

    Guard-values are either \ttref{value}s or literal
    expressions. Values are evaluated, including for variables and the
    array construct, and the result is case-insensitively matched as a
    \ttref{regexp} against the match-value.

    Condition-values must be \ttref{value}s and must evaluate to integers.

    \t{ANY} matches any match-value for which the corresponding
    condition-value is true.

    If a match is found, the corresponding patch list is executed and
    no further matching is done. If no match is found, the \t{DEFAULT}
    patch list is executed.

    See the \ahrefloc{sec-match-and-try}{\t{MATCH} and \t{TRY} tutorial}
    for additional information. \\

  or & \DEFINE{PATCH!TRY} \ttref{patch} \Slist \t{WITH} \Ob guard-value ...
    \Ob \t{WHEN} condition-\ttref{value} \Oe \t{BEGIN} \ttref{patch}
    \Slist \t{END} \Oe \Ob \t{ANY} condition-\ttref{value} \t{BEGIN}
    \ttref{patch} \Slist \t{END} ... \t{DEFAULT} \ttref{patch} \Slist
    \t{END} &
    If evaluating the patch list results in an error, the error is matched, as per \ttref{PATCH!MATCH}.

    \textbf{N.B.} \t{TRY} is generally \emph{not safe} to use because
    many errors are intended to be fatal and if the mod installation
    were to proceed anyway, it might do so in an inconsistent state,
    with resource leaks or with other errors. \ttref{PATCH!RERAISE}
    mitigates or eliminates these risks, since the unsafe part is
    allowing the installation to continue and re-raising the error
    allows it to fail, like intended.

    See the \ahrefloc{sec-match-and-try}{\t{MATCH} and \t{TRY} tutorial} for additional information.
  \\
  or & \DEFINE{PATCH!RERAISE} &
     When used inside a \ttref{PATCH!TRY}, the matched error is re-raised.

     See the \ahrefloc{sec-match-and-try}{\t{MATCH} and \t{TRY} tutorial} for additional information.
  \\
or & \DEFINE{PATCH!INCLUDE} \t{\ttref{String}} \Slist &
    loads the file string as if it were a list of tp2 patches and executes it (as if
		it had been typed inside your tp2).
    These files have by convention tpp as an extension, due to no reason other than
    randomness (you can use .tp1 or .xyzsucks if you're so oriented).
		Please note that, to speed up inclusions, tpp files are stored in memory,
	  rather than re-read each time from the hard-disk. If you need automorphing code
		(IE, you want to edit your tpp file), you can use \ttref{PATCH!REINCLUDE} instead. \\
or & \DEFINE{PATCH!REINCLUDE} \t{\ttref{String}} \Slist &
    Works like \ttref{PATCH!INCLUDE}, but loads each time the tph file from the hard disk.
    This is slower, but required if you want to edit your tpp file between an
    inclusion and another.
    \\
or & \DEFINE{PATCH!WITH!TRA} traName \Slist \t{BEGIN} \ttref{patch} \Slist \t{END} &
    Creates a new \t{TRA} scope copied from the surrounding scope,
    loads all traName files (variable substitution is done; the file
    can be inlined) and evaluates the \t{patch}es. When
    \ttref{PATCH!WITH!TRA} exits, the new \t{TRA} scope is discarded,
    that is, all \t{TRA} changes made by \ttref{PATCH!WITH!TRA} or any
    of its enclosed patches are forgotten. \\
or & \DEFINE{PATCH!WITH!SCOPE} \t{BEGIN} \ttref{patch} \Slist \t{END} &
    Creates a new variable scope copied from the surrounding scope
    and evaluates the \t{patch}es inside the new scope. When
    \ttref{PATCH!WITH!SCOPE} exits, the new scope is discarded, all
    new variables defined inside the scope and all changes to existing variables
    are forgotten. \\
or & \DEFINE{SET!2DA!ENTRY} \ttref{value} \ttref{value} \ttref{value}
\ttref{value} &
  The first \ttref{value} is the row, the second is the column and the
  third is the \emph{required column count}. The entry on the given column
  of the given row is set to the fourth \ttref{value}, but only rows with
  at least as many columns as the required column count are considered.
  The fourth \ttref{value}, the new entry, is evaluated specially: if it
  can be evaluated like a value (e.g., \t{``3+4''}) it will be evaluated
  and its integer result will be written as an ASCII string. Otherwise if
  it is a single string (that is not a variable in scope) that string will
  be written at the new value.
  See
  the \ahrefloc{sec-set-2da-entry}{\t{SET!2DA!ENTRY} tutorial} for more information. \\

  or & \DEFINE{SET!2DA!ENTRY!LATER} string \ttref{value} \ttref{value}
  \ttref{value} &

  Defines an change to a 2DA file to be made at some point in the
  future. The change is stored in variables derived from the
  first parameter, string. The first two values are the row and column
  of the 2DA table to be changed and the third value the new value of
  the 2DA entry. Use \ttref{SET!2DA!ENTRIES!NOW} to flush the queued
  changes and update the 2DA table. If you use
  \ttref{SET!2DA!ENTRY!LATER} together with
  \ttref{READ!2DA!ENTRY!FORMER} you must use different string
  variables for the two. See the \ahrefloc{sec-set-2da-entry-later-now}{\tt{SET!2DA!ENTRY!LATER} tutorial}. \\

  or & \DEFINE{SET!2DA!ENTRIES!NOW} string \ttref{value} &

  Flush the changes to the 2DA table that have been queued by
  \ttref{SET!2DA!ENTRY!LATER}. The first parameter, string, should be
  the same string you used for \ttref{SET!2DA!ENTRY!LATER}. The second
  value is the required column count. Rows with fewer columns are
  disregarded. See the \ahrefloc{sec-set-2da-entry-later-now}{\tt{SET!2DA!ENTRIES!NOW} tutorial}. \\

or & \DEFINE{PRETTY!PRINT!2DA} & Indents the 3rd line in the current file (which
  should be a  2da file). \\
or & \DEFSYN{PRETTY!PRINT!2DA} \ttref{value} & Indents the value'th line
(counting from 0) in the current file (which should be a 2da file). \\
or & \DEFINE{INSERT!2DA!ROW} \t{\ttref{value}1 \ttref{value}2 \ttref{String}} &
  String (after variable substitution) will be inserted as a new line in the table.
  Value1 is the row count, value2 is the \emph{required column count}. If row count is
  the same as the number of long enough lines in the file, then the line will be inserted
  at the end; if row count is lesser than the number of lines, it will be inserted just before
  the nth line in the original file (starting count from 0); finally, if row count is greater
  than the number of lines, the component will fail to install.
\begin{verbatim}
<<<<<<<< ~.../mymod-inlined/2dafile~
asd foo
a b c
d e f
g h i
>>>>>>>>
COPY ~.../mymod-inlined/2dafile~ ~.../mymod-inlined/2dafile~
INSERT_2DA_ROW 3 3 ~4 4 4~
INSERT_2DA_ROW 2 3 ~3 3 3~
INSERT_2DA_ROW 1 3 ~2 2 2~
INSERT_2DA_ROW 0 3 ~1 1 1~
\end{verbatim}
will result in
\begin{verbatim}
asd foo
1 1 1
a b c
2 2 2
d e f
3 3 3
g h i
4 4 4
\end{verbatim} \\
or & \DEFINE{REMOVE!2DA!ROW} \t{\ttref{value}1 \ttref{value}2} &
  the Value1-th row from the 2da file containing at least value2 items will be removed.
\\
or & \DEFINE{PATCH!READLN} \ttref{variable} &
  Waits for the user to provided an enter-terminated string and store it in
  variable. Said string will be stored and re-used during non-interactive reinstalls. See the
  \ahrefloc{sec-readln}{\t{READLN} tutorial}. \\
or & \DEFINE{PATCH!RANDOM!SEED} \ttref{value} &
  See \ttref{RANDOM!SEED}. \\
or & \DEFINE{ADD!STORE!ITEM} \Ob \t{+} \Oe itemName \Ob position \Oe
  charge1 charge2 charge3 flags stack \Ob unlimited \Oe &

  Add the item itemName to the current STO file. An optional \t{+}
  signifies that the new instance of the item should overwrite any
  existing instance of the same item. The item's number of charges are
  given by the respective charge argument, which must take the form of
  \t{\#}integer or \t{(} \ttref{value} \t{)}. The optional position
  argument must be one of \t{AFTER} \ttref{String}, \t{BEFORE}
  \ttref{String}, \t{LAST}, \t{FIRST} or \t{AT}
  \ttref{value}. \t{AFTER} will place the new item behind the item
  given by \ttref{String}. \t{BEFORE} will place the item before the
  item provided by \ttref{String}. \t{LAST} will place the new item
  after all existing items. \t{FIRST} will place the new item as the
  first item in the store. \t{AT} will place the new item at the
  position given by \ttref{value}, with the first item having position
  0. If no position argument is given, \ttref{ADD!STORE!ITEM} defaults
  to \t{FIRST}. The argument flags must be a string consisting of one
  of \t{none}, \t{identified}, \t{unstealable}, \t{stolen},
  \t{identified\&stolen} or \t{identified\&unstealable}. The argument
  stack sets the number of item the store carries in the stack and
  must take the form of \t{\#}integer or \t{(} \ttref{value}
  \t{)}. The optional argument unlimited should be one of the strings
  \t{limited} or \t{unlimited} and controls whether the store should
  carry an inexhaustible stack of the new item, or not. \t{limited} is
  the default behaviour. See the \ahrefloc{sec-add-store-item}{\t{ADD!STORE!ITEM} tutorial} for
  more information. \textbf{Note:} The patch function \ttref{ADD_STORE_ITEM_EX}
  offers similar functionality. \\

or & \DEFINE{REMOVE!STORE!ITEM} itmName \Slist &
  Remove the listed items from the current store. Does nothing if an item is not for sale.
	Multiple instances are removed. \textbf{Note:} The patch function
  \ttref{REMOVE_STORE_ITEM_EX} offers similar functionality. \\

or & \DEFINE{READ!2DA!ENTRY} \ttref{value} \ttref{value} \ttref{value}
\ttref{variable} &
  The first \ttref{value} is the row, the second is the column and the
  third is the \emph{required column count}. The variable specified is set
  to the entry on the given column of the given row, but only column
  with at least as many columns as the required column count are
  considered. This is the reverse of \ttref{SET!2DA!ENTRY}. \\

  or & \DEFINE{READ!2DA!ENTRIES!NOW} string \ttref{value} &

  The contents of the 2DA table is read in one go into an array
  derived from the first parameter, string. The second parameter,
  value, is the required column count. Rows with fewer columns are
  disregarded. The parameter string is also used to set a variable
  named after string that is set to the number of rows in the 2DA
  table with the required number of columns. Retrieve values from the
  constructed array with \ttref{READ!2DA!ENTRY!FORMER}. If you use
  \ttref{READ!2DA!ENTRIES!NOW} together with
  \ttref{SET!2DA!ENTRY!LATER} you must use different string variables
  for the two. See the \t{READ!2DA!ENTRIES!NOW} tutorial. \\

  or & \DEFINE{READ!2DA!ENTRY!FORMER} string \ttref{value} \ttref{value}
  \ttref{variable} &

  Retrieves values from an array constructed by
  \ttref{READ!2DA!ENTRIES!NOW}. The first parameter, string, is the
  name of the array. The following two values are the 2DA row and
  column from which to read the entry. The value of the 2DA entry is
  stored in the last parameter, variable. See the
  \t{READ!2DA!ENTRY!FORMER} tutorial. \\

or & \DEFINE{COUNT!2DA!ROWS} \ttref{value} \ttref{variable} &
  The first \ttref{value} is the required column count. This command
  counts the number of rows in the current file (which should be a
  \ttref{2DA} file) that have at least as many columns as the required
  column count and stores the result in the variable. \\
or & \DEFINE{COUNT!2DA!COLS} \ttref{variable} &
  This command counts the number of columns in the current file (which should be a
  \ttref{2DA} file) and stores the result in the variable. \\
or & \DEFINE{COUNT!REGEXP!INSTANCES} \ttref{optcase} \ttref{optexact} \ttref{regexp}
    \ttref{variable} &
  This command counts the number of times regexp appears in the current file
  and stores the result in the variable. Variable substitution is performed
  on regexp prior to regexp handling (EG, if \verb+%var% = ~abc~+,
  \verb+~[%var%]~+ is evaluated as \verb+~[abc]~+). \\

or & \DEFINE{LOOKUP!IDS!SYMBOL!OF!INT} variable idsFile \ttref{value} &
  The symbolic constant associated with \ttref{value} in idsFile (which may
  contain user variables) is stored
  in variable. If that doesn't work, \ttref{value} is stored in variable.
  Example:
\begin{verbatim}
LOOKUP_IDS_SYMBOL_OF_INT foo ~spell~ 1101
SPRINT myfile "SPELL"
LOOKUP_IDS_SYMBOL_OF_INT bar ~%myfile%~ (0x44c + 1)
LOOKUP_IDS_SYMBOL_OF_INT baz ~spell~ 77777
\end{verbatim}
  Both \t{foo} and \t{bar} are \t{CLERIC\_BLESS} while \t{baz} is
  \t{777777}. \\

or & \DEFINE{COMPILE!BAF!TO!BCS} &
Consider using \ttref{DECOMPILE!AND!PATCH} instead.

  The current file, which must be a valid \ttref{BAF} script, is compiled
  to a \ttref{BCS}. In general you should use the \ttref{COMPILE}
  \ttref{TP2 Action} instead, unless you are using other \t{patch} commands
  to modify the file under consideration. \\
or & \DEFINE{DECOMPILE!BCS!TO!BAF} &
Consider using \ttref{DECOMPILE!AND!PATCH} instead.

  The current file, which must be a valid \ttref{BCS} script, is decompiled
  to a \ttref{BAF}. \\
or & \DEFINE{DECOMPILE!DLG!TO!D} &
Consider using \ttref{DECOMPILE!AND!PATCH} instead.

  The current file, which must be a valid \ttref{DLG} file, is decompile
  to a textual \ttref{D} file (with string refs and no comments). Once you
  have a \ttref{D} file you can use other \t{patch} commands to change the
  actions and triggers around. You should use \ttref{D} actions (like
  \ttref{REPLACE!ACTION!TEXT}) instead whenever possible.  \\
or & \DEFINE{COMPILE!D!TO!DLG} &
Consider using \ttref{DECOMPILE!AND!PATCH} instead.

  The current file, which must be a valid \ttref{D} file that defines
  a single \ttref{DLG} file (via an obvious \ttref{BEGIN} action) is
  compiled to a \ttref{DLG}. Typically this is only used after a
  \ttref{DECOMPILE!DLG!TO!D}.  \\
or & \DEFINE{DECOMPILE!AND!PATCH} \t{BEGIN} \ttref{patch} \Slist
  \t{END} &
  Acts like
\begin{verbatim}
DECOMPILE_BCS_TO_BAF // or DLG_TO_D
  patch list
COMPILE_BAF_TO_BCS // or D_TO_DLG
\end{verbatim}
  except it enforces that the DECOMPILE is followed by the compile,
  can indiscriminately patch BCS and DLG files, and is guaranteed not to leave
  a decompiled file in the override (if decompiling, patching or recompiling
  fails, a warning is printed and the original version of the file is left in
  the override).
\\
or & \DEFINE{REFACTOR!TRIGGER} \ttref{optcase} \ttref{optexact} String String &
  Works like \ttref{REPLACE!TEXTUALLY}, except that it only works on triggers
  (for both D and BAF files)
  and applies Boolean Algebra to ensure that the structure of the trigger is not
  broken (like \ttref{REPLACE!TEXTUALLY} would do if you are substituting one trigger with
  several and the matching trigger is inside an OR() block and/or negated).

  Caveats:
  \begin{itemize}
  \item this command is very slow, so you should use \ttref{REPLACE!TEXTUALLY} if
    you are substituting a trigger with another, as well as using \ttref{IF} to
	avoid calling this patch on script files that do not contain the trigger
	you are looking for.
  \item the resulting file will have messed up whitespace, so remember that if
    you plan on using \ttref{REPLACE!TEXTUALLY} later (the file will work correctly
	in-game). Applying another (empty) \ttref{DECOMPILE!AND!PATCH}
    will fix this issue.
  \item the searching regexp must match exactly against a single trigger
    (so \verb+REFACTOR!TRIGGER ~A() B()~ ~C()~+ or
	\verb+REFACTOR!TRIGGER ~A(~ ~C() A(~+ will not work). The substituting
	string can contain multiple triggers.
  \end{itemize}
\\
or & \DEFINE{REFACTOR!BAF!TRIGGER} \ttref{optcase} \ttref{optexact} String String &
  Synonym for \ttref{REFACTOR!TRIGGER}.
\\
or & \DEFINE{REFACTOR!D!TRIGGER} \ttref{optcase} \ttref{optexact} String String &
  Synonym for \ttref{REFACTOR!TRIGGER}.
\\
or & \DEFINE{REPLACE!EVALUATE} \ttref{optcase} findRegexp \t{BEGIN}
  \ttref{patch} \Slist \t{END} replaceRegexp &

  For every instance of the \ttref{regexp} findRegexp found, the
  \ttref{patch} list is evaluated (with the variable \t{MATCH}$i$ set
  to the $i$th matched group in findRegexp), variable substitution is
  performed on replaceRegexp, and then findRegexp is replaced by
  replaceRegexp. Note that \ttref{REPLACE!EVALUATE} defines up to 200
  \t{MATCH}$i$ variables, but that \t{MATCH1} is normally the variable
  matching the first group in findRegexp. Due to details of the
  implementation, \t{MATCH0} normally evaluates to the string matched
  by the whole of findRegexp. Any writes done by the \ttref{patch}
  list (e.g., \ttref{SAY} or \ttref{WRITE!ASCII}) are ignored:
  \ttref{SET} should be the main component of the \ttref{patch}
  list. For example:
\begin{verbatim}
COPY ~nice.baf~ ~mean.baf~
  REPLACE_EVALUATE
    ~Give(\([0-9]+\),\([0-9]+\))~
    BEGIN
      SET result = (MATCH1 + MATCH2) / 2
    END
    ~Take(%result%)~
\end{verbatim}
  This \ttref{COPY} \ttref{TP2 Action} would replace \t{Give(10,20)}
  with \t{Take(15)}.  optcase allows you to decide if the matching is
  case-sensitive or not. Matching is case-sensitive by default.  \\

  or & \DEFINE{ADD!GAM!NPC} npcCRE npcARE xCoord yCoord &
    See the \ahrefloc{sec-add-gam-npc}{\t{ADD!GAM!NPC} tutorial} for more information about this
    action, which is used when adding NPCs to Baldur's Gate 1. BG2 mods
    should not use this command.  \\

  or & \DEFINE{ADD!MAP!NOTE} xCoord yCoord color \ttref{String} &
    If the file currently being patched is an \ttref{ARE} area file, this
    patch command adds a map note to it. Valid colors include: gray,
    violent, green, orange, red, blue, darkblue, lightgray.
    Example:
\begin{verbatim}
COPY_EXISTING ~ar0202.are~ ~override/ar0202.are~
  ADD_MAP_NOTE #123 #777 ~violet~
  ~This is my new map note!  Yippee!~
\end{verbatim}
    Special thanks to Japh for coding this feature.  \\

or & \DEFINE{ADD!KNOWN!SPELL} splName spellLevel spellType &
  When applied to a CRE file, this \ttref{patch} causes the given spell to
  be known. Note that spellLevel counts from 0 (e.g., you should say
  \t{\#2} for a third-level Fireball). Possible values for spellType are
  \t{priest}, \t{innate} and \t{wizard}. Example:
\begin{verbatim}
COPY_EXISTING ~some.cre~ ~override/some.cre~
  ADD_KNOWN_SPELL ~SPPR314~ #2 ~priest~
  // Unholy Blight is now known as a 3rd level priest spell
\end{verbatim}
  Special thanks to Japh for coding this feature.  \\

or & \DEFINE{ADD!MEMORIZED!SPELL} splName spellLevel spellType
  \Ob \t{(} \ttref{value} \t{)} \Oe&
  When applied to a CRE file, this \ttref{patch} causes the given spell to
  be memorized one more time (or value times if specified).
  Note that spellLevel counts from 0 (e.g., you
  should say \t{\#2} for a third-level Fireball). Possible values for spellType
  are \t{priest}, \t{innate} and \t{wizard}. Example:
\begin{verbatim}
COPY_EXISTING ~some.cre~ ~override/some.cre~
  ADD_MEMORIZED_SPELL ~SPPR314~ #2 ~priest~ ( 5 )
  // Unholy Blight is now memorized five times as 3rd priest
\end{verbatim} \\

or & \DEFINE{REMOVE!KNOWN!SPELL} splName \Slist &
  When applied to a CRE file, this \ttref{patch} causes all of the
  listed spells to be removed. Example:
\begin{verbatim}
COPY_EXISTING ~aerie.cre~ ~override/aerie.cre~
  REMOVE_KNOWN_SPELL ~sppr101~ ~sppr102~
\end{verbatim}
  Special thanks to Japh for coding this feature.  \\

or & \DEFINE{REMOVE!MEMORIZED!SPELL} splName \Slist &
  When applied to a CRE file, this \ttref{patch} causes all of the
  listed spells to be removed from their memory. Example:
\begin{verbatim}
COPY_EXISTING ~aerie.cre~ ~override/aerie.cre~
  REMOVE_MEMORIZED_SPELL ~sppr101~ ~sppr102~
\end{verbatim}
 \\

or & \DEFINE{SET!BG2!PROFICIENCY} String \ttref{value} &
	Removes all effects from the current CRE file that alter the proficiency specified by
	String (relative to Stats.ids). After that, if value is different from zero, add an effect
	to set said proficiency to value. \\

or & \DEFINE{ADD!CRE!ITEM} itmName charge1 charge2 charge3 flags slot \Ob
\t{EQUIP} \Oe \Ob \t{TWOHANDED} \Oe \Ob \t{NOMOVE} \Oe &

Add the item itmName to the current CRE file, with the number of
charges determined by charge1, charge2 and charge3, respectively. Each
charge should be an integer, either in the form of \t{\#}integer or
\t{(} \ttref{value} \t{)}. The argument flags must be a string
consisting of one of \t{none}, \t{identified}, \t{unstealable},
\t{stolen}, \t{undroppable}, \t{identified\&stolen},
\t{identified\&unstealable}, \t{identified\&undroppable},
\t{unstealable\&undroppable}, \t{stolen\&undroppable},
\t{identified\&stolen\&undroppable},
\t{identified\&unstealable\&undroppable}. The argument slot should be
a whitespace-separated list of entries chosen from \t{helmet},
\t{armor}, \t{shield}, \t{gloves}, \t{lring}, \t{rring}, \t{amulet},
\t{belt}, \t{boots}, \t{weapon1}, \t{weapon2}, \t{weapon3},
\t{weapon4}, \t{quiver1}, \t{quiver2}, \t{quiver3}, \t{quiver4},
\t{cloak}, \t{qitem1}, \t{qitem2}, \t{qitem3}, \t{inv1}, \t{inv2},
\t{inv3}, \t{inv4}, \t{inv5}, \t{inv6}, \t{inv7}, \t{inv8}, \t{inv9},
\t{inv10}, \t{inv11}, \t{inv12}, \t{inv13}, \t{inv14}, \t{inv15},
\t{inv16}. On PST, there are the additional slots \t{tattoo1},
\t{tattoo2}, \t{tattoo3}, \t{earring1}, \t{earring2}, \t{inv17},
\t{inv18}, \t{inv19} and \t{inv20}. On IWD2, there are the additional
slots \t{shield1}, \t{shield2}, \t{shield3}, \t{shield4}, \t{inv17},
\t{inv18}, \t{inv19}, \t{inv20}, \t{inv21}, \t{inv22}, \t{inv23} and
\t{inv24}. \ttref{ADD!CRE!ITEM} will add the item to the first empty slot in
the list. If no slot is empty, the item will be placed in the first
slot in the list and the item that previously occupied the slot will
be moved to the general inventory. If the general inventory is full,
the moved item will be discarded. Additionally, slot may contain one
or more entries chosen from \t{inv}, \t{qitem}, \t{quiver},
\t{weapon}, \t{ring}. These entries unfold to the full range of
corresponding slots. For example, \t{qitem} unfolds to \t{qitem1},
\t{qitem2} and \t{qitem3}. On PST, you may additionally use \t{tattoo}
and \t{earring}. On IWD2, you may additionally use \t{shield}. The
optional argument \t{EQUIP} only applies to the weapon slots only and
will make the creature have the weapon selected. The optional argument
\t{TWOHANDED} also only applies to weapon slots and will cause items
in the shield slot to be unequipped. The optional argument \t{NOMOVE}
will cause the new item to be added to the specified slot(s) only if
there is an empty slot, otherwise the new item is placed in the
inventory. See \ahrefloc{sec-add-cre-item}{\t{ADD!CRE!ITEM} tutorial}. \\

or & \DEFINE{REPLACE!CRE!ITEM} itmName \t{\#}charge1 \t{\#}charge2 \t{\#}charge3 flags slot \Ob
\t{EQUIP} \Oe \Ob \t{TWOHANDED} \Oe &
  If there's an item in the slot position, replace it; otherwise, process \ttref{ADD!CRE!ITEM} \\

or & \DEFINE{REMOVE!CRE!ITEM} itmName \Slist &
  Remove the listed items from the current creature. Does nothing if an item is not possessed.
	Multiple instances are removed. \\

or & \DEFINE{REMOVE!CRE!ITEMS} &
  Remove all items from the current creature. \\
or & \DEFINE{REMOVE!CRE!EFFECTS} &
  Remove all effects from the current creature. \\
or & \DEFINE{REMOVE!KNOWN!SPELLS} &
  Remove all known spells from the current creature. \\
or & \DEFINE{REMOVE!MEMORIZED!SPELLS} &
  Remove all memorized spells from the current creature. \\
or & \DEFINE{PATCH!SILENT} & makes WeiDU skip all messages; it's reenabled once a component
    is installed (or fails to), or a \ttref{PRINT}, \ttref{PATCH!PRINT},
    \ttref{VERBOSE} or \ttref{PATCH!VERBOSE} is found. \\
or & \DEFINE{PATCH!VERBOSE} & undoes the latest \ttref{SILENT} or \ttref{PATCH!SILENT} command. \\

or & \DEFINE{INNER!PATCH} buffString \t{BEGIN} \ttref{patch} \Slist \t{END} &
  Any WeiDU variables inside \t{\%}s within buffString are replaced by
  their values. All of the \ttref{patch}es given are evaluated as if the
  contents of the current file were buffString. Any modifications to
  buffString are thrown away (making this mostly useful for reads).
  Example:
\begin{verbatim}
INNER_PATCH "ABC" BEGIN
  READ_BYTE 0x2 "myvar"
END
PATCH_PRINT "myvar is %myvar%"
\end{verbatim}
  This sequence will always print \t{myvar is 67} (since 67 is the ASCII
  code for \t{C}). \\

or & \DEFINE{INNER!PATCH!SAVE} savevar buffString \t{BEGIN} \ttref{patch} \Slist \t{END} &
  As with \ttref{INNER!PATCH}, except that any modifications to buffString are stored inside
  savevar.
  Example:
\begin{verbatim}
SPRINT foo "ABC"
INNER_PATCH_SAVE bar "%foo%" BEGIN
  WRITE_BYTE 0x2 65
END
PATCH_PRINT "foo is %foo%, bar is %bar%"
\end{verbatim}
  This sequence will always print \t{foo is ABC, bar is ABA } (since 65 is the ASCII
  code for \t{A}). \\


or & \DEFINE{INNER!PATCH!FILE} resource \t{BEGIN} \ttref{patch} \Slist \t{END} &
  Any WeiDU variables inside \t{\%}s within resource are replaced by
  their values. If the resulting resource is present in the game or in the
  override folder, the \ttref{patch}es given are evaluated as if the
  current file were that resource. If not, nothing happens. Any
  modifications to that resource are thrown away (making this mostly useful
  for reads).
  Example:
\begin{verbatim}
INNER_PATCH_FILE "SW1H01.ITM" BEGIN
  READ_BYTE 0x1 "myvar"
END
PATCH_PRINT "myvar is %myvar%"
\end{verbatim}
  This sequence will always print \t{myvar is 84} (since 84 is the ASCII
  code for \t{T} and \t{SW1H01.ITM} starts with \t{ITM}). \\

or & \DEFINE{INNER!ACTION} \t{BEGIN} \ttref{TP2 Action} \Slist \t{END} &
  See the \ahrefloc{sec-inner-action}{\t{INNER!ACTION} tutorial}, but loosely the current
  \ttref{COPY} is paused, the given \ttref{TP2 Action}s are executed, and
  then the current \ttref{COPY} is resumed. \emph{Note that an
  \ttref{INNER!ACTION} should never modify a file that is being modified by
  the current action. For example, never put \t{APPEND ~foo.2da~} inside of
  \t{COPY!EXISTING ~foo.2da~}. More formally, if the inner action and the
  outer action both modify the same file, the results are undefined.}\\

or & \DEFINE{EDIT!SAV!FILE} level \Ob \t{ADD!IF!MISSING} \Oe \Ob filename \Slist \Oe
\t{BEGIN} \ttref{TP2 Patch} \Slist \t{END} &

  The current file should be a \t{SAV} file. \ttref{EDIT!SAV!FILE}
  will iterate over the files contained within the \t{SAV} file, set
  the variable \t{SAV!FILE} to the name of the current file and
  evaluate the patch list against the decompressed contents of
  \t{SAV!FILE}. The file contents are then recompressed into the
  \t{SAV} file using the specified compression level. level can be 0
  to 9, where 0 means no compression, 1 is the fastest compression and
  9 is the best compression.

  If the list of filenames is non-empty, only files whose name appear
  in that list are patched (the comparison is case-insensitive,
  variables and arrays are parsed if using \ttref{EVALUATE!BUFFER} or
  \ttref{AUTO!EVAL!STRINGS}).  If the optional \t{ADD!IF!MISSING} is
  provided, the file will be loaded if it exists (determined with
  \ttref{FILE!EXISTS!IN!GAME}) and the patches are applied. If the
  file does not exist, the patches will instead be applied to the
  empty buffer. The resulting file is added to the SAV itself.\\


or & \DEFINE{DECOMPRESS!REPLACE!FILE} start length uncompressedlength &
	Decompress (ZLIB) the \verb/start...start+length-1/ portion of the current
	file (requires to specify the uncompressed length as well). The result overwrites
	the current file. It's equivalent to
	\verb+DECOMPRESS!INTO!FILE start length uncompressedlength 0 BUFFER!LENGTH+
\\
or & \DEFINE{DECOMPRESS!INTO!FILE} start length uncompressedlength overwritefrom
  overwriteto &
	Decompress (ZLIB) the \verb/start...start+length-1/ portion of the current
	file (requires to specify the uncompressed length as well). The result overwrites
	the overwritefrom...overwriteto-1 portion of the current file.
\\
or & \DEFINE{DECOMPRESS!INTO!VAR} start length uncompressedlength varName &
	Decompress (ZLIB) the \verb/start...start+length-1/ portion of the current
	file (requires to specify the uncompressed length as well). The result is stored
	into varName.
\\

or & \DEFINE{COMPRESS!REPLACE!FILE} start length level &
	Compress (ZLIB) the \verb/start...start+length-1/ portion of the current
	file (level is 0 to 9; 0 means don't compress, 1 is fastest compression, 9 is best
	compression). The result overwrites
	the current file. It's equivalent to
	\verb+DECOMPRESS!INTO!FILE start length uncompressedlength 0 BUFFER!LENGTH+
\\
or & \DEFINE{COMPRESS!INTO!FILE} start length level overwritefrom
  overwriteto &
	Compress (ZLIB) the \verb/start...start+length-1/ portion of the current
	file (level is 0 to 9; 0 means don't compress, 1 is fastest compression, 9 is best
	compression). The result overwrites
	the overwritefrom...overwriteto-1 portion of the current file.
\\
or & \DEFINE{COMPRESS!INTO!VAR} start length level varName &
	Compress (ZLIB) the \verb/start...start+length-1/ portion of the current
	file (level is 0 to 9; 0 means don't compress, 1 is fastest compression, 9 is best
	compression). The result is stored into varName.
\\
or & \DEFINE{LAUNCH!PATCH!MACRO} \ttref{String} &
        Launch a patch macro. Refer to the \ttref{macros} section for
        additional information. You may use \DEFINE{LPM} as a synonym
        for \ttref {LAUNCH!PATCH!MACRO}.
\\
or & \DEFINE{LAUNCH!PATCH!FUNCTION} \ttref{String}
     \Ob \t{INT!VAR} \ttref{variable} \Ob \t{=} \ttref{value} \Oe ... \Oe
     \Ob \t{STR!VAR} \ttref{variable} \Ob \t{=} \Ob \ttref{EVALUATE!BUFFER}
     \Oe \ttref{String} \Oe ... \Oe
     \Ob \t{RET} \ttref{variable} \Ob \t{=} \ttref{String} \Oe ... \Oe
     \Ob \t{RET!ARRAY} \ttref{variable} \Ob \t{=} \ttref{String} \Oe ... \Oe
     \t{END} &
        Launch a patch function. Refer to the \ahrefloc{sec-functions}{\t{Functions}} section for
        additional information. You may use \DEFINE{LPF} as a synonym
        for \ttref{LAUNCH!PATCH!FUNCTION}.
\\
or & \DEFINE{PATCH!TIME} \ttref{String} \t{BEGIN} \ttref{patch}
     \Slist \t{END} &
  Measure the time taken to execute the \ttref{patch}es and report
  it under the label \ttref{String} together with the other time
  measurements at the end of the mod's debug file.
\\
\\

\DEFINE{when} & & A \ttref{when} clause gives you local control over when a
  \ttref{COPY}, \ttref{COPY!EXISTING} or \ttref{APPEND!COL} happens. If the
  \ttref{COPY} or \ttref{COPY!EXISTING} contains multiple files, each one
  is checked against the \ttref{when} clauses separately.  \\
is & \DEFINE{IF!SIZE!IS} fileSize & True if the input file size is
fileSize. You may use \DEFINE{I!S!I} as a synonym for \ttref{IF!SIZE!IS}. \\
or & \DEFINE{IF} \ttref{regexp} & True if the input file contains
\ttref{regexp}. \\
or & \DEFINE{UNLESS} \ttref{regexp} & False if the input file contains
\ttref{regexp}.  \\
or & \DEFINE{BUT!ONLY!IF!IT!CHANGES} & True only if the file is actually
changed by patching actions. Unlike all other \ttref{when} clauses, this
one is evaluated just before the result would be written out to the disk.
You may use \DEFINE{BUT!ONLY} as a synonym for \ttref{BUT!ONLY!IF!IT!CHANGES}. \\
or & \DEFINE{IF!EXISTS} &

True only if the file exists. For \ttref{COPY}, this check is done
with \ttref{FILE!EXISTS}. For \ttref{COPY!EXISTING},
\ttref{COPY!EXISTING!REGEXP}, \ttref{COPY!RANDOM}, \t{APPEND} and
\ttref{APPEND!COL} this check is done with
\ttref{FILE!EXISTS!IN!GAME}. For \ttref{COPY!ALL!GAM!FILES}, this when
clause is redundant. \\

\\

\DEFINE{offset} & & A \ttref{offset} is a normal \ttref{value}.
\\

\\


\DEFINE{value} & & An expression that evaluates to an integer. See
\ttref{--debug-value}. \\
is & integer & An absolute location or amount. You may format your numbers
in decimal, hex, octal or binary. Use 0x for hex, 0o for octal and 0b for
binary. \\
or & \t{(} \ttref{value} \t{)} & \\
or & \ttref{value} \t{+} \ttref{value} & Addition. \\
or & \ttref{value} \t{-} \ttref{value} & Subtraction. \\
or & \ttref{value} \t{*} \ttref{value} & Multiplication. \\
or & \ttref{value} \t{/} \ttref{value} & Division. Division by zero yields
the value zero. Briefly, fractions are dropped and the result is an integer
(so 11 / 6 = 1). More technically, ``this division rounds the real quotient
of its arguments towards zero'' -- see
\ahrefurl{{http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html}}
for more information.
\\
or & \ttref{value} \DEFINE{MODULO} \ttref{value} & An operation that
returns the remainder of a division between two numbers. If the second
value is 0, the returned value is 0. You may use \tt{REM} as a synonym. \\
or & \DEFINE{BYTE!AT} \ttref{offset} &
  The 8-bit value from the file at the given \ttref{offset}.  \\
or & \DEFINE{SBYTE!AT} \ttref{offset} &
  The 8-bit signed value from the file at the given \ttref{offset}.  \\
or & \DEFINE{SHORT!AT} \ttref{offset} &
  The 16-bit value from the file at the given \ttref{offset}.  \\
or & \DEFINE{SSHORT!AT} \ttref{offset} &
  The 16-bit signed value from the file at the given \ttref{offset}.  \\
or & \DEFINE{LONG!AT} \ttref{offset} &
  The 32-bit value from the file at the given \ttref{offset}.  \\
or & \DEFINE{SLONG!AT} \ttref{offset} &
  The 32-bit signed value from the file at the given \ttref{offset}.  \\
or & \ttref{value} \DEFINE{**} \ttref{value} & Exponentiation. The first
value is raised to the power of the second. This is done by converting both
to floating point numbers, calculating the exponent, and converting the
answer back to a 32-bit integer. If anything goes wrong the value zero is
returned or the result is undefined. \\
or & \ttref{value} \DEFSYN{**} \t{(} \ttref{value} \ttref{value} \t{)} &
  Fractional exponentiation. \t{a ** (b c)} yields \t{a} raised to the
  power of \t{(b/c)}. All of the internal operations are done in floating
  point. If anything goes wrong, zero is returned or the result is
  undefined. Example:
\begin{verbatim}
SET x = 100 ** 2
SET y = 100 ** (1 2) // square root of 100 = 10
SET z = 100 ** (1 3) // cube root of 100 = 4.64
PATCH_PRINT "w = %w%, x = %x%, y = %y%, z = %z%"
\end{verbatim}
  yields \t{x = 10000, y = 10, z = 4}.  \\

or & \ttref{value} \DEFINE{=} \ttref{value} & \emph{Integer} Equality. If the two
values evaluate to equal integers, the result is 1. Otherwise, the result
is 0. See \ttref{STRING!COMPARE} for comparing \ttref{String}s. Synonym:
\DEFSYN{==}.
\\
or & \DEFINE{NOT} \ttref{value} & Negation. If the value is 0, the result is 1.
Otherwise the result is 0. \\
or & \DEFINE{ABS} \ttref{value} & Absolute value. If the value is >= 0, the result
is x. Otherwise the result is -x. \\
or & \ttref{value} \DEFINE{\textexcl=} \ttref{value} & \emph{Integer} Inequality. If
the two values evaluate to equal integers, the result is 0. Otherwise the
result is 1. See \ttref{STRING!COMPARE} for comparing \ttref{String}s. \\
or & \ttref{value} \DEFINE{OR} \ttref{value} & Disjunction. If either value is
non-zero, the result is 1. Otherwise, the result is 0. Synonym: \DEFSYN{\textpipe\textpipe}. \\
or & \ttref{value} \DEFINE{AND} \ttref{value} & Conjunction. If both values are
non-zero, the result is 1. Otherwise, the result is 0. Synonym: \DEFSYN{\&\&}. \\

or & \ttref{value} \DEFINE{BAND} \ttref{value} & Bitwise And.
\t{0b101 BAND 0b110 = 0b100}. Synonym: \DEFSYN{\&}.\\
or & \ttref{value} \DEFINE{BOR} \ttref{value} & Bitwise Or.
\t{0b101 BOR 0b110 = 0b111}. Synonym: \DEFSYN{\textpipe}. \\
or & \ttref{value} \DEFINE{BXOR} \ttref{value} & Bitwise Exclusive Or.
\t{0b101 BXOR 0b110 = 0b011}. Synonym: \DEFSYN{^^}.  \\
or & \DEFINE{BNOT} \ttref{value} & Bitwise Not.
\t{BNOT 0b111 = 0b1111111111111111111111111111000}. Synonym: \DEFSYN{\verb+`+}. \\
or & \ttref{value} \DEFINE{BLSL} \ttref{value} & Bitwise Logical Shift Left.
\t{0b101 BLSL 2 = 0b10100}. Synonym: \DEFSYN{<<}. \\
or & \ttref{value} \DEFINE{BLSR} \ttref{value} & Bitwise Logical Shift Right.
\t{0b101 BLSR 2 = 0b1}. Synonym: \DEFSYN{>>}. \\
or & \ttref{value} \DEFINE{BASR} \ttref{value} & Bitwise Arithmetic Shift Right.
This is an arithmetic shift: the sign bit of the first value is replicated
and inserted in the vacated bits. \t{0b101 BASR 2 = 0b1}.  \\

or & \ttref{value} \DEFSYN{>} \ttref{value} & If the first value is
greater than the second, the result is 1. Otherwise, the result is 0. \\
or & \ttref{value} \DEFSYN{>=} \ttref{value} & If the first value is
greater than or equal to the second, the result is 1. Otherwise, the result
is 0. \\
or & \ttref{value} \DEFSYN{<} \ttref{value} & If the first value is
less than the second, the result is 1. Otherwise, the result
is 0. \\
or & \ttref{value} \DEFSYN{<=} \ttref{value} & If the first value is
less than or equal to the second, the result is 1. Otherwise, the result
is 0. \\
or & \ttref{value} \DEFSYN{?} \ttref{value} \t{:} \ttref{value} &
An expression-valued conditional.  If the first value is not 0 then the
second value is evaluated and returned, otherwise the third value is
evaluated and returned.  \\

or & \ttref{String} \DEFINE{STRING!COMPARE} \ttref{String} &
This is legacy syntax for \ttref{STRING!EQUAL}:
This expression evaluates to 0 if and only if its two string arguments are
equal (have the same length and the same contents). Otherwise it will evaluate
to a negative or positive integer, depending on whether the first string argument
would sort lexicographically before or after the second string argument.
\ttref{variable}s within the strings (e.g., ``\t{\%mykit\%}'') are replaced by
their values. Note that variables that you want expanded \emph{must} be put in \%'s,
otherwise the raw text will be used.
You may use \DEFINE{STR!CMP} as a synonym for \ttref{STRING!COMPARE}. This
function works just like C's \t{strcmp}.
Note also that \ttref{STRING!EQUAL} and \ttref{STRING!COMPARE} are similar,
but \ttref{STRING!EQUAL} has more intuitive return values. \\

or & \ttref{String} \DEFINE{STRING!COMPARE!CASE} \ttref{String} &
This is legacy syntax for \ttref{STRING!EQUAL!CASE}:
As \ttref{STRING!COMPARE}, but the comparison ignores case. That is,
\t{"ANOMEN"} and \t{"aNoMeN"} are considered equal.\\

or & \ttref{String} \DEFINE{STRING!EQUAL} \ttref{String} &
This expression evaluates to 1 if and only if its two string arguments are
equal (have the same length and the same contents), otherwise it values to 0.
\ttref{variable}s within the strings (e.g., ``\t{\%mykit\%}'') are replaced
by their values.
Note that variables that you want expanded \emph{must} be put in \%'s,
otherwise the raw text will be used.
Note also that \ttref{STRING!EQUAL} and \ttref{STRING!COMPARE} are similar,
but \ttref{STRING!EQUAL} has more intuitive return values. \\

or & \ttref{String} \DEFINE{STRING!EQUAL!CASE} \ttref{String} &
As \ttref{STRING!EQUAL}, but the comparison ignores case. That is,
\t{"ANOMEN"} and \t{"aNoMeN"} are considered equal. You may use
\DEFINE{STR!EQ} as a synonym for \ttref{STRING!EQUAL!CASE}.\\

or & \ttref{String} \DEFINE{STRING!MATCHES!REGEXP} \ttref{String} &
As \ttref{STRING!COMPARE!CASE}, but the second string is treated as a
\ttref{regexp}. Thus \t{"AR1005" STRING!MATCHES!REGEXP "AR[0-9]+"}
evaluates to 0 (``no difference''). You may use
\DEFINE{STRING!COMPARE!REGEXP} as a synonym. \\

or & \ttref{String} \DEFINE{STRING!CONTAINS!REGEXP} \ttref{String} &
As \ttref{STRING!MATCHES!REGEXP}, but it evaluates to 0 if the first string
contains the second \ttref{regexp}. Thus \t{"AR1005" STRING!CONTAINS!REGEXP
"[w-z]"} evaluates to 1 (``mismatch'').

{\em Be warned that this does the exact opposite of what the name suggests.} \\

or & \DEFINE{GAME!IS} \ttref{String} & Returns true if the IE game variant
is one of the entries in String, otherwise it returns false. String is a list of
whitespace-separated entries, chosen from (case doesn't matter)
\verb+bg2=soa, tob, iwd2, pst, bg1, totsc, iwd=iwd1, how, totlm, tutu, tutu_totsc, bgt, ca, iwd_in_bg2, bgee, bg2ee, eet, iwdee, pstee+.
In the list, \verb+bg2=soa+ means that \verb+bg2+ and \verb+soa+ are synonyms,
and you can use whichever one you like. Please note that the items in the list are
defined to be mutually exclusive (except \verb+tob+ will detect both plain ToB
and ToB with BGT installed, for legacy purposes), so \verb+bg2+ will detect a
SoA-only game, without either ToB or Tutu installed. As such, a mod which is
usable with any flavor of BG2 and any flavor of Tutu or BG: EE would contain
\verb+REQUIRE_PREDICATE GAME_IS ~bg2 tob tutu tutu_totsc bgee bg2ee~+ . \\

or & \DEFINE{ENGINE!IS} \ttref{String} & Functions like \ttref{GAME!IS}
except \verb+bg2=soa+ will detect SoA-based Tutu games in addition to SoA games,
and \verb+tob+ will detect ToB-based Tutu games in addition to ToB and BGT games.
As such, a mod that requires Throne of Bhaal's engine enhancements could use
\verb+REQUIRE_PREDICATE ENGINE_IS ~tob~+ . \\

or & \DEFINE{GAME!INCLUDES} \ttref{String} &

Returns true if the IE game variant includes the game content
specified by String. String is a single game chosen from
\verb+bg1, totsc, bg2=soa, tob, pst, iwd=iwd1, how, totlm, iwd2, ca, sod+. In
the list, \verb+bg2=soa+ means that \verb+bg2+ and \verb+soa+ are
synonyms, and you can use whichever one you like. Please note that
unlike \ttref{GAME!IS} you only specify a single game, rather than a
list of games. As an example, \verb+GAME_INCLUDES ~tob~+ will return
true for any game which includes the ToB content, such as ToB itself,
BGT or BG2EE. \\

or & \DEFINE{IDS!OF!SYMBOL} \t{(} File \ttref{String} \t{)} &
Will return the number associated with String in File.ids,
or -1 if String is not associated in File.ids. \\

or & \DEFINE{VARIABLE!IS!SET} \ttref{String} &
Returns true if the variable String is set (there's a variable called either
\verb+String+ or \verb+%String%+, regardless of whether it is a string or an
integer).  \\

or & \DEFSYN{IS!AN!INT} \ttref{String} &
Returns true if the variable String is set to an integer (there's a variable called either
\verb+String+ or \verb+%String%+ with integer value).  \\
or & \DEFINE{TRA!ENTRY!EXISTS} \t{(} \ttref{String} \ttref{String} \Slist \t{)} &
	returns true if the variable String maps to a valid TRA entry.
	If the \ttref{String} list is empty the tra entry is looked for into the loaded TRAs,
	otherwise it's looked for into the listed TRA files.
\\
or & \DEFSYN{IS!SILENT} &
Returns true if the output is currently silenced, false otherwise.  \\

or & \DEFINE{MOD!IS!INSTALLED} modTp2Name modComponent &
Returns true if the modComponent of modTp2Name is installed. The syntax
is the same as with \ttref {REQUIRE!COMPONENT}.  \\

or & \DEFINE{INSTALL!ORDER} modTp2Name1 modComponent1 \t{AFTER} modTp2Name2 modComponent2 &
Returns true if the modComponent1 of modTp2Name1 is installed after the modComponent2
of modTp2Name2 (and both components are installed). The syntax
is the same as with \ttref {REQUIRE!COMPONENT}.  \\

or & \DEFSYN{INSTALL!ORDER} modTp2Name1 modComponent1 \t{BEFORE} modTp2Name2 modComponent2 &
Returns true if the modComponent1 of modTp2Name1 is installed before the modComponent2
of modTp2Name2 (and both components are installed). The syntax
is the same as with \ttref {REQUIRE!COMPONENT}.  \\

or & \DEFINE{ID!OF!LABEL} modTp2Name String &
  Returns the numerical identifier (component number) of the component
  in modTp2Name which has the given \ttref{LABEL}. Returns
  -2\textsuperscript{31} if no such tp2 exists, said tp2 has no
  component with that \ttref{LABEL}, or two or more components have
  that \ttref{LABEL}. In the last two cases will print a WARNING. \\

or & \DEFINE{STATE!WHICH!SAYS} \ttref{text} \t{FROM} \ttref{String} &
  String must be an in-game or in-override .dlg file. Returns:
  \begin{enumerate}
  \item Fails the installation if it can't evaluate the text (an \t{@x} reference out of bounds)
  \item -3 if the text is not currently in the tlk or in the list of strings to add
  \item -2 if the text is spoken (= \verb+SAY ~Foo~+) at least twice in the file String
  \item -1 if the text is never spoken in the file String
  \end{enumerate}
  Otherwise it returns the number of the state in which text is spoken in the file String.
  \t{@x} references are taken from the loaded TRA files (the ones defined in the
  \ttref{Language} part).
\\

or & \DEFSYN{STATE!WHICH!SAYS} \t{\ttref{value} IN \ttref{String}1 FROM \ttref{String}2} &
  As above, except that \t{@x} references are taken from
    the String1 tra file. In particular, one \verb+%s+ in String1 is expanded to the list
    of directories; for example (as of Sola v102), \verb+solarom/%s/epilogue.tra+ would match
\begin{verbatim}
    solarom/american/epilogue.tra
    solarom/french/epilogue.tra
    solarom/german/epilogue.tra
    solarom/italian/epilogue.tra
    solarom/polski/epilogue.tra
    solarom/portuguese/epilogue.tra
    solarom/russian/epilogue.tra
\end{verbatim}
\\
or & \DEFINE{RESOLVE!STR!REF} \t{(} \ttref{text} \t{)} &
Resolves the given text (adding it to the tlk), and returns its TLK index
(so you can pass the result of this command to a function which then uses
\ttref{WRITE!LONG} rather than \ttref{SAY}).
\\
or & \DEFINE{NEXT!STRREF} &
Returns the next available string reference in the TLK file.
\\
or & \DEFINE{RANDOM} \t{(} \ttref{value} \ttref{value} \t{)} &
A random-number generator. The first \ttref{value} is the lower bound, the
second value is the upper bound. A random integer between the lower bound
and the upper bound (inclusive) is returned. Thus \t{RANDOM(3 5)} can
return 3, 4 or 5. If the lower bound is greater than the upper bound, zero
is returned. See also \ttref{RANDOM!SEED}. \\

or & \DEFINE{BUFFER!LENGTH} &
Returns the length of the string currently being patched, or 0 if outside of
a patch expression. \\

or & \DEFINE{INDEX} \t{(} \ttref{optcase}  \ttref{optexact} \ttref{string}1
\ttref{string}2 \Ob \ttref{value} \Oe \t{)} &
Returns the index of the first regexp match of string1 inside string2, or
-1 if not found. If provided, value specifies from what point of string2
the searching should begin (instead of 0).
\\

or & \DEFINE{RINDEX} \t{(}  \ttref{optcase}  \ttref{optexact} \ttref{string}1
\ttref{string}2 \Ob \ttref{value} \Oe \t{)} &
Returns the index of the last regexp match of string1 inside string2, or
-1 if not found. If provided, value specifies from what point of string2
the searching should begin (instead of \ttref{STRING!LENGTH} string2).
\\

or & \DEFINE{INDEX!BUFFER} \t{(}  \ttref{optcase}  \ttref{optexact} \ttref{string}
\Ob \ttref{value} \Oe \t{)} &
Returns the index of the first regexp match of string inside the current string, or
-1 if not found. If provided, value specifies from what point of the string
the searching should begin (instead of 0\t).
\\

or & \DEFINE{RINDEX!BUFFER} \t{(}  \ttref{optcase}  \ttref{optexact} \ttref{string}
\Ob \ttref{value} \Oe \t{)} &
Returns the index of the last regexp match of string inside the current string, or
-1 if not found. If provided, value specifies from what point of the string
the searching should begin (instead of \ttref{BUFFER!LENGTH}).
\\


or & \DEFINE{STRING!LENGTH} \ttref{String} &
Returns the length of the argument \ttref{String} (after variable evaluation). \\

or & \DEFINE{FILE!CONTAINS} fileName \ttref{regexp} &

  Evaluates to 1 if the file \t{fileName} contains the regular
  expression \ttref{regexp} and 0 otherwise. Case is ignored. Use
  \ttref{RESOURCE!CONTAINS} if you want to search game resources;
  \t{FILE!CONTAINS} looks in the file system and does not search biff
  files. \\

or & \DEFINE{FILE!CONTAINS!EVALUATED} \t{(} fileName varsRegexp \t{)} &

  First, all WeiDU variables enclosed in \t{\%}s in \t{varsRegexp} and
  \t{fileName} are substituted. The expression is 1 if the resulting
  \ttref{regexp} occurs in \t{fileName} and 0 otherwise. If
  \t{fileName} does not exist or has size 0, the result is 0. The
  comparison ignores case.  See also \ttref{FILE!CONTAINS}. Use
  \ttref{RESOURCE!CONTAINS} if you want to search game
  resources. \t{FILE!CONTAINS!EVALUATED} will first search the file
  system and only load game resources if the file was not found in the
  file system.

  Example usage:

\begin{verbatim}
COPY_EXISTING_REGEXP ~.*\.CRE~ ~override~
  READ_BYTE   0x273 class
  READ_ASCII  0x280 deathvar
  PATCH_IF (class = 14) AND // class 14 = CLERIC_MAGE
           (NOT FILE_CONTAINS_EVALUATED(~pdialog.2da~
                                        ~%deathvar%~))
    THEN BEGIN
      ADD_CRE_ITEM ~POTN08~ #10 #10 #10 ~IDENTIFIED~ ~INV15~
    END
  BUT_ONLY_IF_IT_CHANGES
\end{verbatim}
The example gives ten healing potions to all cleric-mages who cannot join
the party. Notably it excludes Aerie
since she has the death variable \t{Aerie} and \t{pdialog.2da} contains
\t{AERIE}.  \\

or & \DEFINE{RESOURCE!CONTAINS} fileName varsRegexp &

fileName and varsRegexp are evaluated for variables. fileName is
loaded as a game resource (searching only the biffs and the override
directories) and a \ttref{regexp} search is performed on the file
contents. The result is 1 if the regexp varsRegexp occurs within
fileName, or otherwise 0. The comparison ignores case. If fileName
does not exist or has a file size 0, the result is 0. \\

is & \DEFINE{FILE!EXISTS} fileName & Evaluates to 1 if the file exists in the
filesystem (or the bif file is referenced inside
the chitin.key) and evaluates to 0 otherwise.
The results of \ttref{FILE!EXISTS} are undefined if fileName is a directory.
\\
or & \DEFINE{DIRECTORY!EXISTS} dirName & Evaluates to 1 if dirName is a
directory and exists in the filesystem and evaluates to 0 otherwise.
\\
or & \DEFINE{FILE!EXISTS!IN!GAME} fileName & Evaluates to 1 if the file
exists as a game resource and has non-zero size. Evaluates to 0 otherwise.
\ttref{BIFF}s and the \t{override} directory are searched in the standard
manner. Evaluates to 0 for a file that does not exist but has been
\ttref{ALLOW!MISSING}'d.\\
or & \DEFINE{FILE!MD5} fileName md5sum & Evaluates to 1 if the file exists
and has the given MD5 checksum. Evaluates to 0 otherwise. Two different
files are exceptionally unlikely to have the same MD5 checksum. In any
event, the discovered checksum is printed to the log. If the file does not
exist, it evaluates to 0. \\
or & \DEFINE{FILE!IS!IN!COMPRESSED!BIFF} fileName & Evaluates to 1 if the file
is stored in a compressed biff (ignoring copies in the override). Evaluates to
0 otherwise (the file is not in a biff, or it is in an uncompressed biff).
\\
or & \DEFINE{BIFF!IS!COMPRESSED} fileName & Evaluates to 1 if the file
is a compressed biff. Evaluates to 0 otherwise.

FileName must match against the contents of what is stored in chitin.key
(similar to how command-line arguments that touch bif files work). For
example, \verb+data/AREA000A.bif+. Notably, \ttref{SOURCE!BIFF} outputs
file names compatible with this command.
\\
or & \DEFINE{FILE!SIZE} fileName fileSize & Evaluates to 1 if the
size of the file \t{fileName} is exactly \t{fileSize}. Evaluates to 0
otherwise. \\

or & \DEFINE{SIZE!OF!FILE} fileName &
Returns the size of fileName or -1 if the file does not exist. Variables in
fileName are evaluated. fileName can be a file on the local file system or an
inlined file.
\\

or & \DEFINE{VALID!SCRIPT!ACTIONS} \ttref{variable} &

Variable can be an array construct and should be or evaluate to a
string of whitespace-separated \ttref{Infinity Engine action}s.
Returns true if the string compiles into BCS without
unrecoverable errors, otherwise false.\\

or & \DEFINE{VALID!SCRIPT!TRIGGERS} \ttref{variable} &

Variable can be an array construct and should be or evaluate to a
string of whitespace-separated \ttref{Infinity Engine trigger}s.
Returns true of the string compiles into BCS without
unrecoverable errors, otherwise false.\\

or & \t{\%}\ttref{variable}\t{\%}   &
    The value of the \ttref{variable} is used. \\

or & \DEFSYN{EVALUATE!BUFFER} \ttref{variable} &
    User variables inside the given string are evaluated one additional
    time. You may prepend \ttref{EVALUATE!BUFFER} when a \ttref{value} is
    called for and you would normally use a string. You may also use it for
\ttref{SET} and \ttref{SPRINT} statements. Example:
\begin{verbatim}
SPRINT x ~y~
SET y = 5
SPRINT z EVALUATE_BUFFER ~tricky %%x%%~
SET EVALUATE_BUFFER "%x%" += 77
PATCH_PRINT "y is %y% ; z is %z%"
\end{verbatim}
    This prints out \t{y is 82 ; z is tricky 5}. You may also do hackery like
    \t{FILE!SIZE "myfile" "\%\%indirection\%\%"}. Be very careful with this
    feature. \\
or & \verb+$array(index list)+ &
    The so-called \emph{array construct}. See the \ahrefloc{sec-array-construct}{tutorial}.
\\

or & \t{\%}\DEFINE{WEIDU!ARCH}\t{\%} & The special variable \t{WEIDU!ARCH}
is set to either \t{"x86"}, \t{"amd64"} or \t{"mac"} at WeiDU startup and can be used to
determine the architecture of the WeiDU binary. \\

or & \t{\%}\DEFINE{WEIDU!OS}\t{\%} & The special variable \t{WEIDU!OS} is set to either
\t{"win32"} or \t{"osx"} or \t{"unix"} at WeiDU startup and can be used to
determine the operating system for which the WeiDU binary was compiled. \\

or & \t{\%}\DEFINE{COMPONENT!NUMBER}\t{\%} & The special variable \t{COMPONENT!NUMBER}
is set to the number of the component being installed. \\

or & \t{\%}\DEFINE{INTERACTIVE}\t{\%} & The special variable \t{INTERACTIVE}
is set to 1 if the install is being done interactively (IE you launched setup-mymod.exe and you're
installing mymod), or is set to 0 if the install is being done non-interactively (IE you launched
setup-mymod.exe and now weidu is reinstalling othermod due to the domino uninstall and reinstall). \\

or & \ttref{variable} &
    The value of the \ttref{variable} is used.
  In a \ttref{patch} \ttref{value}, you may use either \t{\%myvar\%} or
  \t{myvar} to get the value of a variable, provided that your variable's
  name is not the same as a WeiDU syntactic keyword or known
  \ahrefloc{sec-constant}{constant}. Also note that while it is common to ``call out''
  variables by putting quotation marks around them, this is not necessary
  if the variable is unambiguous. Thus the following three \ttref{patch}es
  are all equivalent:
\begin{verbatim}
SET "x" = "%y%" + "%z%"       // these all
SET "x" = "y" + "z"           //    do the
SET x = y + z                 //  same thing
\end{verbatim} \\

or & \t{NAME1}   & The offset within an infinity engine resource where the unidentified general name (e.g., "Battle Axe") is stored. \\
or & \t{NAME2}   & The offset within an infinity engine resource where the identified general name (e.g., "K'logarath +4") is stored. \\
or & \t{UNIDENTIFIED!DESC}  & The offset within an infinity engine resource where the unidentified description (e.g., "The hand axe or throwing axe is also known as a hatchet ...") is stored. \\
or & \t{IDENTIFIED!DESC}    & As above ... ("Clans have gone to war to possess K'log...")\\
or & \t{BIO}                & As above ... NPC Biography\\
or & ...        & Almost everything in \t{SNDSLOT.IDS} or \t{SOUNDOFF.IDS}
works as well. \\

\\

\DEFINE{variable} & & A variable is a textual name that holds a
\ttref{value}. Variables are usually set with \ttref{READ!BYTE},
\ttref{SET} or \ttref{SPRINT}. \\
is & \ttref{String} & You may name the variable whatever you like, but stay
away from the special characters used in \ttref{regexp}s. When you want to
obtain the value of a variable, enclose it in \t{\%}s.


Example: If a file contains the two binary integers 33 and 77, then after
executing:

\begin{verbatim}
READ_LONG   0 ~myvar~
WRITE_LONG  4 ( ~%myvar%~ + 11 )
\end{verbatim}

The file will contain the two binary integers 33 and 44. \\

\end{tabular}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{WeiDU \ttref{TP2} Tutorials}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{TP Tutorials}

Note: it's advised to read these tutorials in the order they were written,
as often a tutorial depends on contents explained in the tutorials before
it. If the tutorial-writer is kind enough, they'll state dependencies while
introducing the subject.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\ttref{COPY!EXISTING!REGEXP} (Last update: v232)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This tutorial was thoughtfully provided by Japheth and edited by Wisp to
conform to contemporary good practices.

The purpose of \ttref{COPY!EXISTING} and \ttref{COPY!EXISTING!REGEXP} is to
patch a file for patching. It will grab the file out of the \ttref{BIFF}s,
or if an \t{override} version exists, it will grab it out of the override
folder.

\ttref{COPY!EXISTING!REGEXP}, \ttref{EXTEND!BOTTOM!REGEXP} and
\ttref{EXTEND!TOP!REGEXP} can be potentially powerful actions if you need
to make some changes to a certain set of files all in one shot.

Consider this example for \ttref{COPY!EXISTING!REGEXP}:

In my mod I want to make it so that all 1-handed swords only do D6 damage,
rather than the varying damages they do in SOA.  To do this with the
"normal" \ttref{COPY!EXISTING}, I would have to write out all the one
handed swords like this:

\begin{verbatim}
COPY_EXISTING ~sw1h01.itm~ ~override~
              ~sw1h02.itm~ ~override~
              etc...
\end{verbatim}

That could take a lot of time to do.  Using \ttref{COPY!EXISTING!REGEXP} I
can minimize writing 70+ lines of code into 3 lines of code.  Take a look
at this:

\begin{verbatim}
COPY_EXISTING_REGEXP ~sw1h..[^abc].*itm~ ~override~
  //our patching code goes here
\end{verbatim}

I'll explain how the \ttref{regexp} wildcards in the above example work:
I want to avoid copying over the files sw1h54a.itm, sw1h54b.itm and
sw1h54c.itm because they are the three components that make up the
Equalizer and are thus not actual swords. The regexp fragment \verb+[^abc]+
is an exclusion set that will match any character but ``a'', ``b'' and ``c''.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\ttref{EXTEND!TOP!REGEXP}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This tutorial was thoughtfully provided by Japheth.

Let's take this situation that I was in:

I am making a Hirelings mod, and in order to get non-party NPC's to
transition from area to area, I needed to make use of a combination of
MakeGlobal(), InMyArea(O:Object*) and MoveGlobalObject(O:Object*,O:Target*).

I originally put the script that moves them from area to area into
baldur.bcs (this script is constantly running in the game), but for some
strange reason, the cre's wouldn't move to smaller areas, only the large
"main" areas.  (Like The Docks, Temple District, Slums, etc.)  So I
figured, "Huh, guess I'm going to have to put the script in every area
script".  (Area scripts are scripts that are assigned to areas that are ran
while you are in the area.  Pretty obvious, right?)

Now, writing the code to \ttref{EXTEND!TOP} this little script into every area
script would of taken quite a while, and well, rather than do that, I
humbly requested Wes to implement the \ttref{regexp} feature of
\ttref{EXTEND!TOP} and \ttref{EXTEND!BOTTOM}, and Westley obliged.  (My penance
for that request is writing the docs you are reading right now.)

So now with Wes' help, I could \ttref{EXTEND!TOP} to every area in 1 fell
swoop.  If you were to open up NI and expand the \ttref{BCS} tree, you
would see a whole crapload of scripts that begin with the prefix AR.  These
are the area scripts I mentioned before.  They go from
AR0014 to AR6400.  So now, using \ttref{regexp}, here is how you would
extend the script to the top of every area script:

\begin{verbatim}
EXTEND_TOP_REGEXP ~ar[0-6].*bcs~ ~pathtoscript/patch.bcs~
\end{verbatim}

So there we are, instead of 100+ lines of code, I minimized it to 1 lines.
Now, if you are understanding regexp at all, you probably are going ``Hey
wait, why didn't you just go {\tt \ttref{EXTEND!TOP!REGEXP} "ar.*bcs"
"pathtoscript/patch.bcs"} ?''  Well, in fact, I did do that at first, but I
forgot to account that there are other ``normal'' scripts that begin with AR.
So, I had to write it so that the \ttref{regexp} had the number after the
initial AR so that WeiDU would know only to patch the script to area files.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\ttref{READ!BYTE} and \ttref{PATCH!IF} (Last update: v232)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This tutorial was thoughtfully provided by Japheth, and shamelessly edited
by Bigg to use PATCH!IF rather than IF!EVAL. It was then further edited by
Wisp to conform to contemporary good practices.

\ttref{READ!BYTE}, \ttref{READ!SHORT} and \ttref{READ!LONG} can be
potentially powerful functions when used in conjunction with
\ttref{PATCH!IF}.

Here's a brief demonstration.

The scenario: I want to make all longswords require 10 strength,
rather than their normal 6. To do that manually would be a pain, so why
not use the great feature of \ttref{READ!BYTE}/LONG/SHORT?

Here's how it's done.

First of all, we need to copy all the items so they are ready to be patched.
Here's how we do that:

\begin{verbatim}
COPY_EXISTING_REGEXP ~.*\.itm~ ~override~
\end{verbatim}

All this does is copy all files with a .itm extension to the override folder.

Next, we read the value of the item-type offset into a variable. We'll use the variable
name "type".

\begin{verbatim}
READ_SHORT 0x1c type
\end{verbatim}

I found the offset by looking at the file format for items in the IESDP:
\ahrefurl{\url{https://gibberlings3.github.io/iesdp/index.htm}}. The
variable "type" can really be anything, it's just what I've chosen.

We should edit the item only if the item is really a longsword:

\begin{verbatim}
PATCH_IF (type = 0x14) BEGIN
\end{verbatim}

0x14 is just the value for longsword. If you look at the item-type offset (which
is 0x1c) in the IESDP, you will see a link to a list of known values. 0x14 is the
value for large/long swords.

Now that we're done reading that into a variable and doing the checks, we can now
\ttref{WRITE!BYTE} the value we want to give our new longswords. That is, a strength
requirement of 10.

\begin{verbatim}
WRITE_BYTE 0x26 10
\end{verbatim}

0x26 is the offset for required strength.  Again, I found this offset by referring to the IESDP beforehand.

\begin{verbatim}
END
BUT_ONLY_IF_IT_CHANGES
\end{verbatim}

Finally, we close the BEGIN that was after PATCH!IF and tell WeiDU not to copy
the item if it didn't change (IE, if it wasn't a long sword).

So, to loop through the logic again, this is what we're saying:

If the category is longsword, set the required strength to 10. If
there are no changes, ignore the file and don't copy it over.

And that's it. Now all items with the category Longsword will have a required strength of 10.
Pretty neat, eh? Obviously you can do many, many other types of
thing with these functions. So go ahead and experiment.

Here's the full code:

\begin{verbatim}
COPY_EXISTING_REGEXP ~.*\.itm~ ~override~
  READ_SHORT 0x1c type

  PATCH_IF (type = 0x14) BEGIN
    WRITE_BYTE 0x26 10
  END
BUT_ONLY_IF_IT_CHANGES
\end{verbatim}

Oh yeah, and if you're going "But I don't know when to \ttref{READ!SHORT}
or \ttref{WRITE!LONG}. It's so confusing," don't worry, cause
it kind of is if you've never worked with bytes before. Here's a very brief
synopsis.

Use READ/WRITE!SHORT for anything that is two bytes. You can determine this
easily by looking at the field you want to change in the IESDP or the program
Near Infinity and subtracting the next listed field's offset from the offset
of the field you want to change.

For example, if I wanted to change Bodhi's Max HP here's what I would do.
First look at her creature file in NI. (She has many, but for the sake of
argument, we'll use bodhi.cre). If you look at the Max HP field, it says
it's offset is 26h. The next field in the creature file is Animation ID,
which is 28h. So, subtracting 28h from 26h gives you 2h. The perfect
\ttref{WRITE!SHORT} size.

Use READ/WRITE!LONG for anything that is 4 bytes. Use the above example to
figure this out as well.

Use READ/WRITE!BYTE for anything that is one byte. Again, use the
above example to figure this out.

Use \ttref{WRITE!ASCII} for things like script name, dialogues, scripts,
etc. Note, that if you're \ttref{WRITE!ASCII}ing to say, the script name,
and the previous script-name entry is longer than the one
you're writing, then you'll have spillover after \ttref{WRITE!ASCII}. To
avoid this, specify a required size that equals the length of the script-name field.
So, if I have
\begin{verbatim}
WRITE_ASCII 0x280 ~Guy~
\end{verbatim}
I would actually want to write this
\begin{verbatim}
WRITE_ASCII 0x280 ~Guy~ #32
\end{verbatim}

These are by no means "hard and fast" rules, but generally they ring true.

Also, if you tried to run the template, you'd have noticed that it didn't work
correctly. That's because there are some corrupt files in the key (that is,
files of size 0). To avoid that, WeiDU gives us the \verb+SOURCE_SIZE+ variable,
which is set to the original file size, in number of bytes. We can simply check that the
file is large enough. Using either NI or the IESDP, we see that a basic itm file must be
least 0x72 bytes long, so we can check that before doing anything:

\begin{verbatim}
COPY_EXISTING_REGEXP ~.*\.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) BEGIN
    READ_SHORT 0x1c type

    PATCH_IF (type = 0x14) BEGIN
      WRITE_BYTE 0x26 10
    END
  END
BUT_ONLY_IF_IT_CHANGES
\end{verbatim}

Again, we instruct WeiDU to not do a thing if the file is not large enough.

And that, as they say, is that.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\ttref{value}s and expressions  (Last update: v232)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This tutorial was thoughtfully provided by Japheth, and shamelessly edited
by Bigg to use PATCH!IF rather than IF!EVAL. It was then further edited by
Wisp to conform to contemporary good practices.

\textbf{Note well:} This tutorial can be considered an example of how to use
WeiDU's low-level functionality. The preferred way of accomplishing the task in
this tutorial (adding items to creatures) is with \ttref{ADD!CRE!ITEM}. Many
other things can and should today also be done with higher-level functionality.

Using expressions with WeiDU can get quite complex, however the power they
give you is more than worth the effort in learning how to use them.

Say, for instance, that you want to give a creature file a shield that
doesn't have one originally.  The old way to do this would be to add the
item to the creature file using Near Infinity or ShadowKeeper and then copy
that creature file over upon installation of your mod.  However, now that
INSERT/DELETE!BYTES and READ/WRITE!BYTE/LONG/SHORT take expressions, we can
do this "on the fly" when installing your mod.

The benefits of doing it this way should be obvious.  Now you no longer
have to overwrite someone else's modifications to that creature file.  You
can simply add your shield and leave their modifications intact.  (Unless
of course *they* also decided to give the exact same creature a shield.
And if that's the case, the shield you specify won't be used because of our
\ttref{PATCH!IF} statement.)

Anyways, on to the example.  I'll use acolyte1.cre as my example creature.

\textbf{Caveat:} This will only work on standard-ordered creature files, for
which
\begin{verbatim}
known_spells_offset <=
memorization_offset <=
memorized_spells_offset <=
effects_offset <=
items_offset <=
item_slots_offset
\end{verbatim}

The first thing we want to do is copy the creature over so it's ready for
patching, and ensure it isn't corrupt.  That's easy to do using a simple
\ttref{COPY!EXISTING} statement:

\begin{verbatim}
COPY_EXISTING ~acolyte1.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) BEGIN
\end{verbatim}

Next, we need to read in the offsets so we know where to insert our bytes and
where to update our number of items.  I figured out these offsets by simply
viewing the creature file in Near Infinity.

The offsets we need to read in are the item slots offset, the items offset and
the number of items.  This is how we do it:

\begin{verbatim}
READ_LONG 0x2bc itemsoffset
READ_LONG 0x2b8 itemslot
READ_LONG 0x2c0 numberofitems
\end{verbatim}

"itemsoffset", "itemslot" and "numberofitems" can be anything you choose, but I
would name them something that's easy to remember because we'll be using
them later.

Next, we're going to read in the shield slot to make sure that it's empty.
We do this by taking the "itemslot" variable and adding 0x04 to it which we
know is always going to be the shield slot.  (You can verify this by
looking at a creature file in NI.  If you look at the offset 0x2b8 it will
have the offset for item slots.  If you add 0x04 to that number, it should
equal the offset for the shield slot.)

This is done like so:

\begin{verbatim}
READ_SSHORT (itemslot + 0x04) shield
\end{verbatim}

We want to tell WeiDU only to do this if the shield slot is
*empty*.  This is where \ttref{PATCH!IF} comes in handy.  The way a creature
file is setup is that if a slot is set to -1, it means it's empty.  WeiDU can
read signed values with e.g., \ttref{READ!SSHORT}. Signed values are ones for
which a subset of values are interpreted as having a negative sign. In this
example, if we were to read the value with \t{READ!SHORT} instead, all values
would be interpreted as positive (so instead of -1, the value of "shield" would
be 65535).

\begin{verbatim}
PATCH_IF (shield = "-1") BEGIN
\end{verbatim}

Now, we have to update the shield slot to reflect that it's the newest item
out of all the items the creature has equipped.  This is a bit misleading
because in the slots part of the creature file, they count from 0.  So, all
we need to do is take the value of 0x2c0 (The number of items the creature
has.) and use that as our value to write.

To do that, this is what we do:

\begin{verbatim}
WRITE_SHORT (itemslot + 0x04) numberofitems
\end{verbatim}

Now we have to update the itemslot offset value to reflect the fact that
we're adding a new item to the creature.  An item is *always* 0x14 bytes.
We already know the offset of the itemslot offset and we've already read
it's value, so all we need to do is add 0x14 to it

\begin{verbatim}
WRITE_LONG 0x2b8 (itemslot + 0x14)
\end{verbatim}

The last step before inserting our bytes is to increase the numberofitems by 1 to
reflect the fact that we've added an item to the creature.  We've already
read in the number of items into "numberofitems" so this is dead easy:

\begin{verbatim}
WRITE_LONG 0x2c0 (numberofitems + 1)
\end{verbatim}

Now we can actually insert out bytes.  To do this we have to take the
number of items that the creature has multiplied by 0x14 and add that to
the itemsoffset.  (The reason we can't just insert it right at
"itemsoffset" is because it would mess up the order of the items in game.
If we inserted the shield at the beginning, then the creature would more
than likely have some items equipped in some weird places in the game.)

This is done like so:

\begin{verbatim}
INSERT_BYTES (itemsoffset + numberofitems * 0x14) 0x14
\end{verbatim}

Now we can actually write our information for our item.  You don't need the
.itm extension at all, just everything before the .itm.  And again, since
the item entry is always the first entry in an item field on a creature
file, we just need to use the same formula as above because we'll be
writing at the same offset that we inserted our bytes at:

\begin{verbatim}
WRITE_ASCII (itemsoffset + numberofitems * 0x14) ~shld01~
\end{verbatim}

If you wanted to add a magical shield to the creature file and wanted it to
be already identified in the slot, then you would simply have to add 0x10
bytes to the previous expression and \ttref{WRITE!LONG} the value of 1.
Like this:

\begin{verbatim}
WRITE_LONG (itemsoffset + (numberofitems * 0x14) + 0x10) 1
\end{verbatim}

Finally, we close the PATCH!IF statements and add BUT!ONLY!IF!CHANGES.

\begin{verbatim}
    END
  END
BUT_ONLY_IF_IT_CHANGES
\end{verbatim}

Here's the full code:

\begin{verbatim}
COPY_EXISTING ~acolyte1.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) BEGIN
    READ_LONG 0x2bc itemsoffset
    READ_LONG 0x2b8 itemslot
    READ_LONG 0x2c0 numberofitems
    READ_SSHORT (itemslot + 0x04) shield

    PATCH_IF (shield = "-1") BEGIN

      WRITE_SHORT (itemslot + 0x04) numberofitems
      WRITE_LONG 0x2b8 (itemslot + 0x14)
      WRITE_LONG 0x2c0 (numberofitems + 1)

      INSERT_BYTES (itemsoffset + numberofitems * 0x14) 0x14

      WRITE_ASCII (itemsoffset + numberofitems * 0x14) ~shld01~
    END
  END
BUT_ONLY_IF_IT_CHANGES
\end{verbatim}

Note that you can use the \ttref{PRINT} action in a \ttref{TP2} to debug
your code as well.  Like this:

\begin{verbatim}
COPY_EXISTING ~acolyte1.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) BEGIN
    READ_LONG 0x2bc itemsoffset
    READ_LONG 0x2b8 itemslot
    READ_LONG 0x2c0 numberofitems
    READ_SSHORT (itemslot + 0x04) shield

    PATCH_IF (shield = "-1") BEGIN

      WRITE_SHORT (itemslot + 0x04) numberofitems
      WRITE_LONG 0x2b8 (itemslot + 0x14)
      WRITE_LONG 0x2c0 (numberofitems + 1)

      INSERT_BYTES (itemsoffset + numberofitems * 0x14) 0x14

      WRITE_ASCII (itemsoffset + numberofitems * 0x14) ~shld01~
    END
  END
BUT_ONLY_IF_IT_CHANGES

PRINT ~The value of the items offset is %itemsoffset%~
\end{verbatim}

I should also mention that the above code for adding an item to a creature
file is "portable" in a sense.  You would only have to change a couple
things.  The changes that would have to be made are as follows:

\begin{enumerate}
\item Change acolyte1.cre to the actual creature that you want to modify
\item You'll have to change ("itemslot" + 0x04) to something else if you
are adding anything else but a shield.  You can figure this out by
subtracting the slot offset of the slot you want to modify from the item
slots offset.
\item You would need to change ~shld01~ to the item you are going to add.
\item You'd have to add your own flags if they need adding  (i.e.
Identified, Not Stealable, etc.).
\end{enumerate}

And that's the end of it.  All this can be a bit tricky, but as I mentioned
above, it can be quite powerful as well.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec-add-store-item}\subsection{\t{ADD!STORE!ITEM} (Last Update: v211)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This tutorial and this feature were thoughtfully provided by Japheth.

  Using ADD!STORE!ITEM is a relatively painless procedure. Consider this
  example: I want to add a new item to \t{ribald.sto} in BGII.  There were
  two ways of doing this before.

\begin{enumerate}
\item I could add the item to the store beforehand and then simply copy over
  the new store file upon installing my mod.

\item I could use WeiDU's \ttref{READ!BYTE} and \ttref{WRITE!BYTE} patch
      expressions to patch the item into the store while installing.
\end{enumerate}

  Now we can do \#2 rather easily thanks to ADD!STORE!ITEM.

  First off copy over the store file to set it up for patching as you
  normally would.

\begin{verbatim}
COPY_EXISTING ~ribald.sto~ ~override~
\end{verbatim}

  Next we issue the ADD!STORE!ITEM patch expression with the following
  arguments:

\begin{verbatim}
ADD_STORE_ITEM "myitem" #10 #0 #0 ~IDENTIFIED~ #5
\end{verbatim}

  "myitem" is the name of the item file that we will want to appear in the
  store without it's .itm extension.
  \#10 is the first extension headers number of charges
  The two \#0s that follow are the second and third extension headers number
  of charges.
  ~IDENTIFED~ is the flag that we want on the item.

  \#5 is the number of items that will be in stock.

  Pretty easy stuff right?

  You can also add an optional + after ADD!STORE!ITEM if you want to
  overwrite an item that already exists in the store.

  So, if we wanted to replace HAMM05.ITM in ribald.sto this is what we'd
  do:

\begin{verbatim}
ADD_STORE_ITEM + ~hamm05~ #10 #0 #0 ~IDENTIFIED~ #5
\end{verbatim}

  One final note: remember to copy over your new item because
  ADD!STORE!ITEM doesn't do that part for you.

  So, a complete set of actions that would patch a store file and copy over
  the new item would look like this:

\begin{verbatim}
COPY_EXISTING ~ribald.sto~ ~override~
ADD_STORE_ITEM ~myitem~ #10 #0 #0 ~IDENTIFIED~ #5

COPY ~mymod/myitem.itm~ ~override~
\end{verbatim}

  Note that you can also add a final optional string argument if you want
  the store to have unlimited copies of that item:

\begin{verbatim}
ADD_STORE_ITEM ~myitem~ #10 #0 #0 ~IDENTIFIED~ #1 ~UNLIMITED~
\end{verbatim}

Note that as of v188 you can specify the position of the item being added:
\begin{verbatim}
COPY_EXISTING ~ribald.sto~ ~override~
  ADD_STORE_ITEM ~myitem~   AFTER  ~olditem~ #10 #0 #0 ~IDENTIFIED~ #5
  ADD_STORE_ITEM ~otheritm~ BEFORE ~olditem~ #10 #0 #0 ~IDENTIFIED~ #5
\end{verbatim}
  Valid options for position are:

  \t{FIRST} will add the item at the top of the stack.
     This is the default, equivalent to putting nothing there.

  \t{LAST} will add the item to the bottom of the stack.

  \t{BEFORE ~olditem~} will add the item exactly before olditem,
    or to the top of the stack if olditem is missing.

  \t{AFTER  ~olditem~} will add the item exactly after olditem,
    or to the bottom of the stack if olditem is missing.

As of 192, if there's a list of items in BEFORE|AFTER olditem (IE \verb+~item1 item2 item3~+),
we add the new item BEFORE or AFTER the first item that is present in the list.

As of 211, you can specify a (zero-based) hardcoded position via \verb+AT position+.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec-add-gam-npc}\subsection{\t{ADD!GAM!NPC}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This tutorial and this feature were thoughtfully provided by Japheth.

In BGII, the game engine was refined so that when any NPC joined your party
they would be added to the baldur.gam file, regardless of the fact if they
were in there already or not.

Sadly, in BG1 this is not the case.  If you were to simply CreateCreature
any old NPC and add them to your party, as soon as you moved to another
area the game would crash and die.

This is where ADD!GAM!NPC comes in handy for all you BG1 modders out there.

By using ADD!GAM!NPC you can patch your NPC into all the \t{baldur.gam}
files on an end users install.  This includes the default \ttref{GAM} file
that's loaded up when you start a new game as well as all the \ttref{GAM}
files in the \t{save} and \t{mpsave} directories.

Note: However, there really is no foolproof way to back up all the save
games, so you may want to warn the end user in a readme to manually back
them up themselves beforehand.

Anyways, I digress.

To use ADD!GAM!NPC you have to first copy over the \ttref{CRE} file that
you will want to appear in the \ttref{GAM} file.  I'm pretty sure we all
know how to do this, but for completeness, here it is:

\begin{verbatim}
COPY ~mymod/mynpc.cre~ ~override~
\end{verbatim}

After the \ttref{COPY} statement, make sure you do all your \ttref{SAY}s
and any other type of patching that you'll want to do for your .cre file.
You will \emph{always} want to use ADD!GAM!NPC last since you want the
updates to your cre file to be reflected in the \ttref{GAM} file as well.

Here's a typical patch statement for most NPC mods:

\begin{verbatim}
COPY ~mymod/mynpc.cre~ ~override~
  SAY NAME1 ~Japh~
  SAY NAME2 ~Japh~
\end{verbatim}

So, after doing all that, we would issue ADD!GAM!NPC with the following
arguments:

\begin{verbatim}
ADD_GAM_NPC "mynpc" "ar2600" #123 #456
\end{verbatim}

"mynpc" is the name of your NPCs cre file that you're copying over without
the .cre extension.

"ar2600" is the area that you want him/her placed in.  In this case we're
placing the NPC in Candlekeep.

\#123 is the x co-ordinate on the map.

\#456 is the y co-ordinate on the map.

That's all there is to it.  Just to recap, here's the full set of
expressions we would use:

\begin{verbatim}
COPY ~mymod/mynpc.cre~ ~override~
  SAY NAME1 ~Japh~
  SAY NAME2 ~Japh~
  // Do any other patching stuff here

ADD_GAM_NPC ~mynpc~ ~ar2600~ #123 #456
\end{verbatim}

Note: Again, I have to stress the importance of warning the end users to
backup their save and mpsave directories beforehand.  There really is no
elegant way to do this via WeiDU (well, maybe there is, but I can't think
of a way) so I'd just warn them.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec-set-2da-entry}\subsection{\t{SET!2DA!ENTRY}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This tutorial was thoughtfully provided by Idobek.

There have been some queries about \ttref{SET!2DA!ENTRY} in the WeiDU
forum recently. This is a consolidation of my posts on the subject.
The command takes this form:

\begin{verbatim}
SET_2DA_ENTRY value value value newEntry
\end{verbatim}

The first value is the row, the second is the column and the third is the
required column count. The entry on the given column of the given row is
set to \t{newEntry}, but only rows with at least as many columns as the
required column count are considered. The upper-left entry is 0,0. For
example, given the following 2DA file:

\begin{verbatim}
2DA V1.0
*
     ROWNAME        LOWER MIXED HELP
0    RESERVE        *     *     *
1    BERSERKER      25179 25151 25201
2    WIZARD_SLAYER  25180 25152 25203
3    KENSAI         25181 25153 25204
4    CAVALIER       25182 25154 25206
\end{verbatim}

Then the patch:

\begin{verbatim}
SET_2DA_ENTRY 3 1 5 ~SAMURAI~
\end{verbatim}

would result in:

\begin{verbatim}
2DA V1.0
*
     ROWNAME        LOWER MIXED HELP
0    RESERVE        *     *     *
1    BERSERKER      25179 25151 25201
2    WIZARD_SLAYER  25180 25152 25203
3    SAMURAI        25181 25153 25204
4    CAVALIER       25182 25154 25206
\end{verbatim}

So the columns and rows you want WeiDU to consider are:

\begin{verbatim}
      Column0 Column1       Column2 Column3 Column4

              ROWNAME       LOWER   MIXED   HELP
Row0: 0       RESERVE       *       *       *
Row1: 1       BERSERKER     25179   25151   25201
Row2: 2       WIZARD_SLAYER 25180   25152   25203
Row3: 3       KENSAI        25181   25153   25204
Row4: 4       CAVALIER      25182   25154   25206
\end{verbatim}

The total number of columns is five. If, however, you put 1 as your
required column count then you tell WeiDU you want to consider all rows
with at least 1 column. So your row numbers change:

\begin{verbatim}
Row0: 2DA V1.0
Row1: *
Row2:      ROWNAME        LOWER MIXED HELP
Row3: 0    RESERVE        *     *     *
Row4: 1    BERSERKER      25179 25151 25201
Row5: 2    WIZARD_SLAYER  25180 25152 25203
Row6: 3    KENSAI         25181 25153 25204
Row7: 4    CAVALIER       25182 25154 25206
\end{verbatim}

So the required column count is what you use to tell WeiDU which row you
want to use as row0. So using the code
\begin{verbatim}
SET_2DA_ENTRY 3 1 1 ~SAMURAI~
\end{verbatim}
would result in:

\begin{verbatim}
2DA V1.0
*
     ROWNAME        LOWER MIXED HELP
0    SAMURAI        *     *     *
1    BERSERKER      25179 25151 25201
2    WIZARD_SLAYER  25180 25152 25203
3    KENSAI         25181 25153 25204
4    CAVALIER       25182 25154 25206
\end{verbatim}

Hopefully, that explains the required column count a little better.

%If you have tried any of the above code you will have found that the
%results are not quite as described.
%
%\begin{verbatim}
%SET_2DA_ENTRY 3 1 5 ~SAMURAI~
%\end{verbatim}
%actually resulted in:
%
%\begin{verbatim}
%2DA             V1.0
%*
%ROWNAME         LOWER           MIXED           HELP
%0               RESERVE         *               *               *
%1               BERSERKER       25179           25151           25201
%2               WIZARD_SLAYER   25180           25152           25203
%3               SAMURAI         25181           25153           25204
%4               CAVALIER        25182           25154           25206
%\end{verbatim}
%
%This, I imagine, is not what you were expecting. Well don't worry: Nothing
%is wrong and the file \emph{will work fine}. Not aesthetically pleasing
%though. To fix this all you need to do is add another column header using
%\ttref{SET!2DA!ENTRY} on a file and removing it once you are done, like so:
%
%\begin{verbatim}
%SET_2DA_ENTRY 0 0 4 ~IDOBEK ROWNAME~
%SET_2DA_ENTRY 6 1 1 ~SAMURAI~
%SET_2DA_ENTRY 0 0 5 ~~
%\end{verbatim}

Finally, if \t{newEntry} is a string that contains any
\t{\%WeiDU\_Variables\%} they are replaced by their values.
That's the end of this tutorial.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec-while}\subsection{\t{WHILE} Loops (Last update: v232)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This tutorial was thoughtfully provided by Idobek, and shamelessly edited
by Bigg to use PATCH!IF rather than IF!EVAL, and PATCH!IF rather than WHILE.
It was then further edited by Wisp to make it look slightly more contemporary.

\textbf{Note:} In almost all circumstances, it is preferable to use \ttref{FOR}
instead.

So what is a \t{WHILE} loop? Well, very simply put it is a way of
applying the same patch to a file multiple times under a different
condition each time. Or it is a way of applying different patches depending
upon the conditions. This example will show both of these methods. Keeping
in theme we are going to modify the damage done by axes. Now, some axes
have both a melee \emph{and} a ranged ability. We are going to want to
change both of these abilities but give different damage to ranged and
melee.


First, as always, we need to copy the files ready for patching, and throw
in the usual sanity check:
\begin{verbatim}
COPY_EXISTING_REGEXP ~.*\.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) BEGIN
\end{verbatim}
We only want to modify axes so let's find out what the item is:
\begin{verbatim}
READ_BYTE 0x1c category
\end{verbatim}
Once we are done with our patching we will use \ttref{PATCH!IF} to tell
WeiDU to only patch axes:

\begin{verbatim}
PATCH!IF (category = 25) BEGIN
\end{verbatim}
Now, we need to find out how many abilities there are and where they are
located:
\begin{verbatim}
READ_LONG 0x64 abilitiesoffset
READ_SHORT 0x68 numberofabilities
\end{verbatim}
So far, so good. Here's where the fun begins. We want to patch examine
every ability in the item. We use a \t{WHILE} loop to patch the
abilities one by one. We open the loop like so:
\begin{verbatim}
WHILE (numberofabilities > 0) BEGIN
\end{verbatim}
For the \t{WHILE} loop to progress and close we need to modify the
"numberofabilities" variable. We use the \ttref{SET} command to do this:

\begin{verbatim}
SET numberofabilities = (numberofabilities - 1)
END
\end{verbatim}
These lines are placed at the end of the \t{WHILE} loop. WeiDU will
process the abilities from last to first and reduce the "numberofabilities"
variable by one each time. Once the "numberofabilities" variable hits zero the
\t{WHILE} loop will stop.

OK, now we need to find out what type of ability we are looking at. Within
an item an ability is 0x38 bytes, abilities also count from 0 within items
so we must take this into account:
\begin{verbatim}
READ_BYTE (abilitiesoffset + (numberofabilities - 1) * 0x38) abilitytype
\end{verbatim}
Now we get to the meat of the patch. This patch is conditional on the
ability type we have just read. First we will deal with the melee damage
patch. We are going to be using a \ttref{PATCH!IF} command to do this

\begin{verbatim}
PATCHING (abilitytype = 1) BEGIN
\end{verbatim}
So we are patching when the ability type is 1 (melee). Time for the actual patch:
\begin{verbatim}
WRITE_SHORT (abilitiesoffset + (numberofabilities - 1) * 0x38 + 0x16) 6
WRITE_SHORT (abilitiesoffset + (numberofabilities - 1) * 0x38 + 0x18) 2
\end{verbatim}
Time to close the PATCH!IF statement.
\begin{verbatim}
END
\end{verbatim}
We use exactly the same method for ranged abilities:
\begin{verbatim}

PATCH!IF (abilitytype = 2) BEGIN
   WRITE_SHORT (abilitiesoffset + (numberofabilities - 1) * 0x38 + 0x16) 12
   WRITE_SHORT (abilitiesoffset + (numberofabilities - 1) * 0x38 + 0x18) 1
END
\end{verbatim}
We can now close the main loop (using the aforementioned method):
\begin{verbatim}
SET numberofabilities = (numberofabilities - 1)
END
\end{verbatim}
We are done with our patches so we can add our usual END and BUT!ONLY.
\begin{verbatim}
END
END
BUT!ONLY!IF!IT!CHANGES
\end{verbatim}
The full code is:
\begin{verbatim}
COPY_EXISTING_REGEXP ~.*\.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) BEGIN
    READ_BYTE 0x1c category
    PATCH_IF (category = 25) BEGIN
      READ_LONG 0x64 abilitiesoffset
      READ_SHORT 0x68 numberofabilities
      WHILE (numberofabilities > 0) BEGIN
        READ_BYTE (abilitiesoffset + (numberofabilities - 1) * 0x38) abilitytype
        PATCH_IF (abilitytype = 1) BEGIN
          WRITE_SHORT (abilitiesoffset + (numberofabilities - 1) * 0x38 + 0x16) 6
          WRITE_SHORT (abilitiesoffset + (numberofabilities - 1) * 0x38 + 0x18) 2
        END
        PATCH_IF (abilitytype = 2) BEGIN
          WRITE_SHORT (abilitiesoffset + (numberofabilities - 1) * 0x38 + 0x16) 12
          WRITE_SHORT (abilitiesoffset + (numberofabilities - 1) * 0x38 + 0x18) 1
        END
        SET numberofabilities = (numberofabilities - 1)
      END
    END
  END
BUT_ONLY_IF_IT_CHANGES
\end{verbatim}

So what have we done? Let's list the steps involved:
\begin{enumerate}
\item First off we copied all the item files ready for patching.
\item Then we the read in the item category.
\item We also read in the number of abilities and the file location of those abilities.
\item We open a \t{WHILE} loop based upon the number of abilities.
\item Within the \t{WHILE} loop, we read in the ability type.
\item Next we defined a new variable to indicate that we had not yet patched any melee type abilities.
\item We opened a \ttref{PATCH!IF} statement.
\item We patched melee abilities to do 2D6 damage.
\item We closed this \ttref{PATCH!IF} loop.
\item We repeated steps 6-9 to give the ranged abilities 1D12 damage.
\item We closed our main \t{WHILE} loop by reducing the number of abilities by 1 and indicating that it should stop if the number of abilities reached 0.
\item We used a \ttref{PATCH!IF} statement to ensure the patch is only applied to axes.
\end{enumerate}

That's the end of this tutorial.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Bitwise Operators (Last update: v232)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This tutorial was thoughtfully provided by CamDawg, and shamelessly edited
by Bigg to use PATCH!IF rather than IF!EVAL. It was then further edited by
Wisp to make it look slightly more contemporary.

This was a topic that I struggled with while trying to convert some kits
with unusual item restrictions. Thanks to WeiDU's new bitwise operators,
this is a process that can done dynamically and non-destructively and
affect all items of a particular type, even if added or altered by another
mod (assuming yours is installed after others of course  ). The basic idea
is to construct a function in WeiDU that:

\begin{enumerate}
\item Searches through all item files in the game
\item Reads selected data from an item (type, usability, etc)
\item Alters specific data on an item without changing anything else
\end{enumerate}

This tutorial is basically an expansion on Japheth's excellent
READ/BYTE/LONG/SHORT tutorial and I suggest you take a look at that before
going further.

My initial problem came about when trying to make specific items usable or
unusable by a particular class/race/kit. If you look at the item file
structure at IESDP, you see that all of the unusability flags of an item
are controlled by the individual bits of bytes 0x1E, 0x1F, 0x20 and 0x21
for class/race alignment restrictions and 0x29, 0x2B, 0x2D and 0x2F for the
individual kit restrictions. (Near Infinity combines and displays the four
bytes of class/race restrictions as a single chunk of data.)

A quick aside about notation before I proceed. Numbers in binary (the
strings of bits) are preceded with 0b and hexadecimal numbers (typically
the bytes) are preceded with 0x.  Eight bits make a byte and bits are read
right-to-left. So if the second bit is 1 and the rest 0, then the bit would
be written as 0b00000010.

If you were trying to alter the usability of a specific class or race,
simply using a \ttref{WRITE!BYTE} command on any of these particular bytes
would result in changing the usability of an item by all the classes in the
particular byte. The new bitwise operators provide an easier solution.

First we need to look at what the new operators \ttref{BAND} and
\ttref{BOR} do with bits.  They are both ways of combining two bytes, based
on different rules. Both \ttref{BAND} and \ttref{BOR} compare the
individual bits (bit 0 vs bit 0, bit 1 vs bit 1, etc. all the way through
bit 7 vs bit 7) of two bytes. For each individual bit, the following tables
are used to determine the value:

\begin{verbatim}
0 BAND 0 = 0
0 BAND 1 = 0
1 BAND 0 = 0
1 BAND 1 = 1

0 BOR 0 = 0
0 BOR 1 = 1
1 BOR 0 = 1
1 BOR 1 = 1
\end{verbatim}

So if byte 0x23 is 0b00110101 and byte 0x24 is 0b10010001, then 0x23 BAND
0x24 is 0b00010001 whereas 0x23 BOR 0x24 is 0b10110101.

Back to relating this to unusability in items. For an item to be flagged as
unusable, the corresponding bit must be set to 1. A 0 means a particular
item is usable by the class/race. Let's look at the example of changing
mage robes usable by bards. This would go into your TP2 file.

\begin{verbatim}
COPY_EXISTING_REGEXP GLOB ~.*\.itm~ ~override~ //copies all item files
  PATCH_IF (SOURCE_SIZE > 0x71) BEGIN // avoid crashing on empty items
    READ_BYTE    0x20 mage //reads the byte containing the mage usability flag
    PATCH_IF ((mage BAND 0b00000100) = 0b00000000) BEGIN // if it is usable by mages
      READ_BYTE    0x1E bard //reads the byte containing bard usability flag
      READ_SHORT    0x1C type //reads the byte containing item type
      PATCH_IF (type = 67) OR (type = 2) BEGIN // if it is a robe or armor
        WRITE_BYTE    0x1E (bard BAND 0b10111111)  // makes usable by bards
      END
    END
  END
BUT_ONLY_IF_IT_CHANGES
\end{verbatim}

This is the same basic idea in Japheth's BYTE tutorial , except now we're
utilizing the bitwise operators in the writing and evaluation commands. The
mage usability flag is the bit 2 in byte 0x20 (IESDP). By checking "mage"
BAND 0b00000100, the values of any of the 7 other bits (0-1,3-7) are set to
0, whereas bit 2 is equal to 0 if and only if it is 0 to begin with.
Therefore the statement will only be true if the item is usable by mages
(bit 2 = 0). If that is true and the item is a robe or armor, then we write
("bard" BAND 0b10111111) into the bard usability byte, 0x1E. By using 1
in bits 0-5 and 7, this ensures that the original value of the flag is
preserved, and using 0 in bit 6 ensures that bit 6 is set to 0 regardless
of its previous value--making it usable by bards whether it was before or
not.

Just as an aside, you could read the entire usability block with a
\ttref{READ!LONG} at 0x1E. However, it becomes a pain because then you need
to start writing out all 32 bits when doing the bitwise operations.

Let's try another example. Let's try making large weapons such as
two-handed swords and halberds unusable by short folks--gnomes, halflings,
and dwarves.

\begin{verbatim}
COPY_EXISTING_REGEXP GLOB ~.*\.itm~ ~override~ //copies all item files
  PATCH_IF (SOURCE_SIZE > 0x71) BEGIN // avoid crashing on empty items
    READ_BYTE    0x21 race //reads the byte containing race usability flags we're interested in
    READ_BYTE    0x31 prof //reads the byte containing item type
    PATCH_IF (prof = 93) OR    // two-handed sword
             (prof = 99) BEGIN // or halberd
      WRITE_BYTE    0x21 (race BOR 0b00010101)  // makes unusable by dwarves, halflings, and gnomes
    END
  END
BUT_ONLY_IF_IT_CHANGES

\end{verbatim}

In this case, rather than reading the 'type' byte of the item, I've opted
for the 'proficiency' byte. Many two-handed swords in BG2 are classed as
long swords for some reason so in this case proficiency is a better
indicator if it is a two-handed sword IMHO.

The unusability flags for dwarves, halflings and gnomes are all in byte
0x2F at bits 0, 2, and 4 respectively (thanks again IESDP). By writing
"race" BOR 0b00010101 to byte 0x2F we're preserving the values of bits
1,3, and 5-7 while setting the 0, 2, and 4 bits to 1 (unusable) regardless
of their previous values.

Thanks especially to Smoketest for helping me with this, Japheth for the
tutorial that inspired this and the help given, and the IESDP team.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec-scripting-styles}\subsection{Scripting Styles (Last Update: v232)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

While the \ttref{BCS} and \ttref{BAF} script formats are common to all
Infinity Engine games, there are three main variants. The variations deal
largely with how ``object parameters'' are expressed. The style used by
Baldur's Gate, Baldur's Gate 2, and Icewind Dale is considered to be the
default. This document will not explain Infinity Engine scripting -- look
for a tutorial elsewhere.

\begin{tabular}{cp{10in}|p{10in}}
BG BAF Object & \t{EA.GENERAL.RACE.CLASS.SPECIFIC.GENDER.ALIGN} \\
PST BAF Object & \t{EA.FACTION.TEAM.GENERAL.RACE.CLASS.SPECIFIC.GENDER.ALIGN} \\
IWD2 BAF Object & \t{EA.GENERAL.RACE.SUBRACE.CLASS.SPECIFIC.GENDER.ALIGNMNT} \\
\end{tabular}

If \t{SUBRACE.IDS} is present in \t{CHITIN.}\ttref{KEY}, the scripting
style is autodetected as IWD2. Otherwise, if \t{BONES.IDS} is present,
the scripting style is autodetected as PST. Otherwise, if \t{CLOWNRAN.IDS} is
present, the scripting syle is autodetected as IWD1. Otherwise, if \t{FLYTHR01.MVE}
is present, the scripting style is autodetected as BG2. Otherwise, if \t{OH1000.ARE}
or \t{OH6000.ARE} are present, the scripting style is autodetected as BGEE/BG2.
Otherwise the scripting style is set to BG1. The \t{--script-style} command-line
argument and the \ttref{SCRIPT!STYLE} \ttref{TP2} flag both override this default.
You should not need to use \t{--script-style} explicitly if the
\t{--game} is set correctly.

Furthermore, the scripting style is coupled with the format used for TLK strings. If
the scripting style is BG2, strings are stored in the BG2 format.

Also, \t{IWD1} and \t{IWD2} have different rules for parsing certain IDS files,
which contain spaces and/or commas in the tokens.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec-subcomponent}\subsection{TP2 \t{SUBCOMPONENT} Groups (Last Update: v192)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This tutorial was thoughtfully provided by CamDawg, and edited by the Bigg
to account for FORCED!SUBCOMPONENT.

\t{SUBCOMPONENT}s allow to group together a set of mutually exclusive mod
components into a single menu-style selection. The primary purpose of
\t{SUBCOMPONENT}s is to streamline mod installation and to make life easier for
end users. For example, \t{SUBCOMPONENT}s are ideal if you wish to provide
multiple portrait selections for an NPC mod, have several kits available to
one NPC, or for changes that conflict with one another (i.e. raising an XP
cap to 10 million or raising it to 20 million). We'll use the first
one (multiple portrait options) as an example.

Without \t{SUBCOMPONENT}s, the install dialogue would look something like this:

\begin{verbatim}
Install Component [Delainy Portrait 1 by Bob]?
[I]nstall, [N]ot Install, or [Q]uit

Install Component [Delainy Portrait 2 by Fred]?
[I]nstall, [N]ot Install, or [Q]uit

Install Component [Delainy Portrait 3 by Wilhelmus]?
[I]nstall, [N]ot Install, or [Q]uit
\end{verbatim}

The end user would need to click through the options each time. Worse,
conflicting components could be installed. These problems can be limited
somewhat by judicious use of predicates, but taking advantage of the
\t{SUBCOMPONENT} feature yields far superior results:

\begin{verbatim}
Install Component [Delainy Portrait]?
[N]o, [Q]uit, or choose one:
 1] Portrait 1 by Bob
 2] Portrait 2 by Fred
 3] Portrait 3 by Wilhelmus
\end{verbatim}

Only one of these options can be installed at any time; re-installing
and selecting a different \t{SUBCOMPONENT} will automatically uninstall the
previously installed one. Setting this up is dead simple:

\begin{verbatim}
BEGIN ~Portrait 1 by Bob~
/* The string above is displayed in the subcomponent listing, i.e. the list
with 1] 2] 3] etc. You can, of course, use TRA references instead for this
and the SUBCOMPONENT string below. */
SUBCOMPONENT ~ Delainy Portrait~
/* The string above is displayed as the component listing and must be the
same for each SUBCOMPONENT. The tp2 code that follows is only executed if
this SUBCOMPONENT is selected. */
COPY ~Delainy/portraits/opt1G.bmp~ ~override/CDDELAIG.bmp~
COPY ~Delainy/portraits/opt1M.bmp~ ~override/CDDELAIM.bmp~
COPY ~Delainy/portraits/opt1S.bmp~ ~override/CDDELAIS.bmp~

BEGIN ~Portrait 2 by Fred~
SUBCOMPONENT ~ Delainy Portrait~
COPY ~Delainy/portraits/opt2G.bmp~ ~override/CDDELAIG.bmp~
COPY ~Delainy/portraits/opt2M.bmp~ ~override/CDDELAIM.bmp~
COPY ~Delainy/portraits/opt2S.bmp~ ~override/CDDELAIS.bmp~

BEGIN ~Portrait 3 by Wilhelmus~
SUBCOMPONENT ~ Delainy Portrait~
COPY ~Delainy/portraits/opt3G.bmp~ ~override/CDDELAIG.bmp~
COPY ~Delainy/portraits/opt3M.bmp~ ~override/CDDELAIM.bmp~
COPY ~Delainy/portraits/opt3S.bmp~ ~override/CDDELAIS.bmp~
\end{verbatim}

Any \ttref{REQUIRE!FILE}s or other module requirements for the whole group
should be put with the first subcomponent. If such a requirement fails,
none of the subcomponents can be installed. In addition, each individual
subcomponent can be guarded by its own predicate. If that predicate fails,
that particular subcomponent cannot be installed. Example:

\begin{verbatim}
BEGIN ~Imoen: Turnip-Mage~
SUBCOMPONENT ~Imoen Mage Kit~ (FILE_EXISTS_IN_GAME ~turnip.spl~)
  // This particular subcomponent will only be displayed if TURNIP.SPL
  // exists. If it does not, you can still install other subcomponents.
\end{verbatim}

One note about \t{SUBCOMPONENT}s and mod ordering: WeiDU will display
\t{SUBCOMPONENT}s in a single grouping no matter if they fall consecutively
in the \ttref{TP2}. However, the component number (the one that gets placed in
\t{weidu.log} and the one you check for in \ttref{REQUIRE!COMPONENT} et al.) is
still based on their \ttref{TP2} order.

As of v192, if all subcomponents fail their requirement, then we don't ask about
the specific group; moreover, if at least one of the subcomponents is defined with
\t{FORCED!SUBCOMPONENT} rather than \t{SUBCOMPONENT}, then the user is forced to
install one of them. This could be useful if you want to ask the user if he wants
biffing of wav files or not (as you need different actions for either choice).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec-add-cre-item}\subsection{\t{ADD!CRE!ITEM} (Last Update: v240)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This tutorial was thoughtfully provided by Japheth.

This command is a little bit more complex.

Here is the syntax:

\begin{verbatim}
COPY_EXISTING ~alynar.cre~ ~override~
  ADD_CRE_ITEM ~itemname~ #charge1 #charge2 #charge3 ~Flags~ ~Inventory Slots~ [EQUIP] [TWOHANDED] [NOMOVE]
\end{verbatim}

\t{EQUIP} and \t{TWOHANDED} are optional and are only needed when
dealing with weapons. \t{NOMOVE} is likewise optional and controls
whether \t{ADD!CRE!ITEM} should move items to make room for the new
item. If no items are moved and there are no empty slots, the new item
will not be added. Conversely, if an item is moved and there is no
empty slot into which to move it, the moved item is lost.

I'll give some examples now.

Example \#1:

If I want to add a Ring of Protection to Sir Alynar, here's what I'd do:

\begin{verbatim}
COPY_EXISTING ~alynar.cre~ ~override~
  ADD_CRE_ITEM ~ring06~ #0 #0 #0 ~IDENTIFIED~ ~RRING LRING~
\end{verbatim}

This will add the item to his right ring slot. If that slot is full, it
will be added to the left ring slot. If both are full, we move the current
right ring (the first slot in the list) to an an empty inventory slot so
that the Ring of Protection is still put in it's appropriate slot.

Example \#2:

If I want to add a +2 Longsword to his second weapon slot, but \emph{don't}
want to equip it, here's what I'd do:

\begin{verbatim}
COPY_EXISTING ~alynar.cre~ ~override~
  ADD_CRE_ITEM ~sw1h06~ #0 #0 #0 ~IDENTIFIED~ ~WEAPON2~
\end{verbatim}

Again, if there happens to be a weapon in his second weapon slot already,
then we simply move that weapon to an empty inventory slot.

Example \#3:

Same deal as example \#2 except now I want to equip the sword.

\begin{verbatim}
COPY_EXISTING ~alynar.cre~ ~override~
  ADD_CRE_ITEM ~sw1h06~ #0 #0 #0 ~IDENTIFIED~ ~WEAPON2~ EQUIP
\end{verbatim}

This will put the sword in his second weapon slot and equip it.  And again,
if there's already a weapon in that slot, it will be moved to an empty
inventory slot.

Example \#4:

If you want to add a two-handed weapon \emph{and} equip it, here's what you do:

\begin{verbatim}
COPY_EXISTING ~alynar.cre~ ~override~
  ADD_CRE_ITEM ~sw2h01~ #0 #0 #0 ~NONE~ ~WEAPON2~ EQUIP TWOHANDED
\end{verbatim}

This will place the item in the second weapon slot (and again, if there's
already a weapon there it's moved to inventory), remove anything that's in
the shield slot and put it in an empty inventory slot and finally it will
equip the weapon.

If you just want to add a two-handed weapon to a cre but don't need it
equipped, then you don't have to worry about specifying \t{EQUIP} or
\t{TWOHANDED}.

Finally, it is worth noting that any WeiDU variables inside \t{\%}s in the
\t{itemname} will be replaced by their values.

Phew, that's it.

Note: starting from v189, you can use INV, QITEM, QUIVER, WEAPON and RING as
shortcuts respectively
to INV1 INV2 ... INV15 INV16, QITEM1 QITEM2 QITEM3, QUIVER1 QUIVER2 QUIVER3,
WEAPON1...WEAPON4, RRING LRING.

In IWD2, INV unfolds to INV1..INV24, SHIELD to SHIELD1..4.

In PST, INV unfolds to INV1..20, TATTOO to TATTOO1..3, EARRING to EARING1..2,
QITEM to QITEM1..5, QUIVER1..5. PST also supports HAND, but loses SHIELD and
HELMET.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\DEFINE{Prompt Customization}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This tutorial was thoughtfully provided by Rastor, and edited by Wisp to
clarify the role of \t{prompts.tra}.

A customized installer can make your mod look more unique to your end user,
giving a feel that ``This isn't your basic, cookie-cutter mod.''  WeiDU
actually allows for a great deal of customization of the mod installer
program (ie. the \t{setup-mymod.exe} file).  For the most part, just about
every line of text can be changed to suit your needs.  This tutorial will
show you how.

{\bf Understanding the Installer}.
WeiDU, like most computer programs, draws every line of text that it
displays from a series of strings.  In a default installer (simply a
renamed weidu.exe and the appropriate .tp2), all of the strings that WeiDU
displays are programmed into WeiDU's source code.  Fortunately, weidu
allows you to overwrite these strings with ones of your own choosing.

{\bf prompts.tra}.
In the WeiDU download package (from http://www.weidu.org), you will find a
file in the \t{examples} folder called \DEFINE{prompts.tra}.  This is the
file that you modify to customize your installer. Go look at it now.

WeiDU defines a number of default tra references, which are displayed
at different points during the installation. The tra-reference numbers
and default text are reproduced in the \t{prompts.tra} file. By
editing or translating this text, and loading the resulting tra
strings as any other, the text displayed by WeiDU can be changed.

{\bf An Example}.
Let us assume for a minute that you want the question asking if users want
to install to read:
\begin{verbatim}
You are a big stupid moron if you do not install the [Component Name].
Install?
[Y]es you idiot or [N]o, bonehead or [Q]uit
\end{verbatim}

For obvious reasons, you would never want your mod's installer to
actually say that but it will serve as a good working example.

To change the install component text, find the section of prompts.tra that
corresponds with the text that you wish to change.  In this case, we want
to change \t{@-1006} and \t{@-1008}.  If you look at these lines, you will
see a strange \\n that does not actually appear when the installer is
running.  This is a line feed (or ``new line'') character.  It simply
indicates that you want any text following it to be inserted below the text
that precedes the line feed.

The name of the component in your mod is always inserted immediately
following \t{@-1006} without any spaces.  This means that you are going to
want to include a space or a bracket or some other distinguishing character
at the end of your new text, otherwise the installer's text will look
quite strange.  The name of the component also is always followed (with no
spaces) by either line \t{@-1007} or \t{@-1008} depending on whether the
component is already installed or not.

If you want to include more text in your custom line before the \t{[I]nstall} or
\t{[N]ot Install} stuff, then simply place it before the \\n character.

To generate the custom text that I presented above, change the lines in
your prompts.tra file to read:
\begin{verbatim}
@-1006= "You are a big stupid moron if you do not install the ["
@-1008= "].  Install?\n[Y]es you idiot or [N]o, bonehead or [Q]uit"
\end{verbatim}

After making these changes, place \t{prompts.tra} into the TRA folder.

If you are familiar with the default text in the installer, then you will
recognize the all of the lines that are listed in \t{prompts.tra}.  You may
change any of the text, but simply remember the meaning of the line feed.
The WeiDU installer will not word wrap, meaning that if you insert
a very large line that is not broken up by \\n, the user will not be able
to see all of it.  You should do some experimentation to determine the
optimal length for each line (it's roughly 72 characters).

{\bf What you cannot change}.
Although WeiDU does allow for a large degree of customization, there are a
few things that you cannot change. You cannot change the input keys used to
collect the player's response. You cannot change the \t{Copying one file}
and \t{Compiling dialogues} (and the similar) text.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec-inner-action}\subsection{\t{INNER!ACTION}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Normally I would start off with \emph{do not use this feature}, but since
this \ttref{patch} can basically only be used to do really obscure things,
you're probably already a master if you're considering it.

We'll use \ttref{INNER!ACTION} in the context of a hypothetical mod
that causes all monsters to drop special ``skins'' that can be worn by the
PCs, granting the PCs all of the ``natural talents'' (e.g., fire
resistance, seeing through invisibility, animation avatar) of that monster.

First, we will specially prepare a ``template'' object -- a special blank
``skin'' item that has slots equipped effects like ``fire resistance bonus
+0'' and ``natural armor class 10'' and ``change creature animation''. Each
creature ``skin'' will be a specialized copy of this template.

Then we'll consider each monster in turn. We'll read the fire resistance
value from the monster and write that value into a copy of the ``skin''
item. Then we'll repeat the process for ``armor class'', ``cold
resistance'', etc.  We'll also copy over any ``CRE effects'' the creature
might have (e.g., ``can see invisible'') and make them additional equipped
effects of the ``skin'' item. Finally we'll add that personalized ``skin''
item to the monster's inventory. If the monster is \t{C6BODHI.CRE}, we'll
call the skin \t{C6BODHI.ITM}.

Note that you would normally \emph{always} use a modder prefix for your new
items and other files.

We'll give the code in pieces. First, we want to go over every existing
creature and make sure that \t{CREATURE.ITM} doesn't already exist in the
game. If it does we won't make a ``skin'' for that monster. We'll also
include a little size sanity check to make sure that we're not ready any
degenerate 0-byte files.

\begin{verbatim}
COPY_EXISTING_REGEXP GLOB ~.*\.cre~ ~override~
  PATCH_IF
    (SOURCE_SIZE > 0x2c8) AND
    (NOT FILE_CONTAINS_EVALUATED("%SOURCE_RES%.ITM" "ITM"))
  THEN BEGIN // %SOURCE_RES%.ITM does not exist.
\end{verbatim}

See \t{SOURCE!RES}. Using \t{"ITM"} as the
second argument makes \ttref{FILE!CONTAINS!EVALUATED} behave like
\t{FILE!EXISTS!EVALUATED}, since any real item contains \t{ITM} as part of
its header.

Now we're going to read the animation, armor class, resistances, and
creature effects. We'll also equip this creature with its special skin,
even through we haven't made that skin yet.

\begin{verbatim}
    READ_SHORT 0x28    anim_id
    READ_SHORT 0x46    natural_ac
    READ_ASCII 0x59    resists (11) // read 11 bytes (even 0's)
    READ_LONG  0x2c4   eff_off
    READ_LONG  0x2c8   num_eff
    READ_ASCII eff_off effects (num_eff * 264)
    ADD_CRE_ITEM ~%SOURCE_RES%~ #0 #0 #0 ~IDENTIFIED~ ~INV10~
\end{verbatim}

Since there are 11 resistances (e.g., fire, cold, magic fire, ...) we are
just leaving them in a string as an array of bytes rather than making up
individual variables for each one. Now we want to go about creating our
special skin item. We'll use the mysterious \ttref{INNER!ACTION} to do so.

\begin{verbatim}
    INNER_ACTION BEGIN
      COPY ~foo/footemp.itm~ ~override/%SOURCE_RES%.ITM~
        WRITE_SHORT 0x76 anim_id
        WRITE_SHORT 0xa6 natural_ac
\end{verbatim}

Using \ttref{SOURCE!RES} as part of a computed \ttref{COPY} destination is
normally somewhat dangerous because it is reset every time you enter a
\ttref{COPY} -- but we're OK here.

Our template \t{footemp.itm} item has a number of pre-made equipped
abilities (e.g., no dispel, bypass resistance, apply 100 \% of the time to
the wearer, last while equipped) that are just lacking concrete values.
Here we fill in the animation and armor class. Next we'll do the
resistances:

\begin{verbatim}
        // copy over all resistances
        FOR (i=0; i<11 ; i=i+1) BEGIN
          INNER_PATCH "%resists%" BEGIN
            READ_BYTE i resist_i
          END
          foo_resist_off = 0xd6 + (i * (0x102 - 0xd2))
          WRITE_LONG foo_resist_off resist_i
        END
\end{verbatim}

For each of the 11 resistances we remember its value from the creature by
using \ttref{INNER!PATCH} to get it out of our \t{resists} ``array''. The
resistance effects in \t{footemp.itm} are stored in the same order as the
creature resistances are in a \ttref{CRE} file.

Having handled the standard resistances we now turn to creature effects.
We don't know in advance how many creature effects there will be, so for
each one we will make a new effect structure and insert it into our skin
item. We'll get the new effect structure by copying one of the ones that
was already there (called \t{dummy\_eff} in the code below).

Unfortunately, creature effects are not stored in quite the same way as item
effects, so we can't copy them over directly. Instead, from each creature
effect we'll extract the opcode, value and resource fields. We end up with
a three step process: (1) insert some bytes into the skin file to hold the new
effect, (2) copy over the \t{dummy\_eff} effect structure as a framework,
and (3) fill in the appropriate values from the creature effect. Here it
is:

\begin{verbatim}
        // copy all CRE effects
        PATCH_IF num_eff > 0 THEN BEGIN
          READ_ASCII 0x72 dummy_eff (0x30)
          FOR (i=0; i<num_eff; i=i+1) BEGIN
            INNER_PATCH "%effects%" BEGIN
              READ_ASCII ((i * 264) +  8) "cre_eff_opcode" (0x4)
              READ_ASCII ((i * 264) + 20) "cre_eff_value"  (0x8)
              READ_ASCII ((i * 264) + 40) "cre_eff_res"    (0x8)
            END
            INSERT_BYTES 0x72 0x30                        // step 1
            WRITE_EVALUATED_ASCII 0x72 "%dummy_eff%"      // step 2
            WRITE_EVALUATED_ASCII 0x72 "%cre_eff_opcode%" // step 3
            WRITE_EVALUATED_ASCII 0x76 "%cre_eff_value%"  // step 3
            WRITE_EVALUATED_ASCII 0x86 "%cre_eff_res%"    // step 3
          END
          READ_SHORT  0x70 num_global_itm_eff
          WRITE_SHORT 0x70 (num_global_itm_eff + num_eff)
        END
    END
\end{verbatim}

Huzzah. Notice our use of variables to ``pass information'' between the
main copying action and the \ttref{INNER!ACTION}. Yes, I hate WeiDU syntax
as well. Why do you ask? Anyway, after that we update the item header to
take into account the new global effects.

\begin{verbatim}
  END
  BUT_ONLY_IF_IT_CHANGES
\end{verbatim}

Finally we close off our sanity-checks and throw in the ever-popular
\ttref{BUT!ONLY!IF!IT!CHANGES}. It would be ``easy'' (read: annoying and
time-consuming but possible) to extend this hackery so that it also stole
all of the effects from undroppable items held by creature (e.g., most
``undead'' immunities are actually stored in \t{RING95.ITM} and not as
creature effects) by nesting yet-another \ttref{INNER!ACTION}. You could
even be selective and avoid copying over effects like ``minimum hit
points''. Then you could perhaps create an on-the-fly description for the
``skin'' item using \ttref{SAY!EVALUATED}.

Bonus points if you actually understood this code. Additional bonus points
if you find a real use for \ttref{INNER!ACTION} in your mod. As a closing
warning, do not try to re-invent the WeiMorph wheel using a \ttref{TP2}
script -- email Japheth instead.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec-set-2da-entry-later-now}\subsection{\t{SET!2DA!ENTRY!LATER} and \t{SET!2DA!ENTRIES!NOW} (Last Update: v241)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\ttref{SET!2DA!ENTRY!LATER} and \ttref{SET!2DA!ENTRIES!NOW} are
extensions of the \ttref{SET!2DA!ENTRY} patch, so you should be
familiar with \t{SET!2DA!ENTRY} before reading this tutorial. A
\ahrefloc{sec-set-2da-entry}{tutorial} for \t{SET!2DA!ENTRY} exists.

The main difference between the standard \ttref{SET!2DA!ENTRY} and
these variants is that \t{SET!2DA!ENTRY} changes the file each
instance, while \t{SET!2DA!ENTRY!LATER} stores a list of changes in
memory and relies on \t{SET!2DA!ENTRIES!NOW} to flush the changes and
update the file. This can result in better performance than
\t{SET!2DA!ENTRY}. According to Weimer's calculations, using the
deferred approach gives an edge when 5 or more \t{SET!2DA!ENTRY} are
to be applied to the same file.

To illustrate the differences, consider the following code, which allows
for thieves, cleric/thieves and mage/thieves to put 3 proficiency
points in Two-weapon fighting using \t{SET!2DA!ENTRY}:
\begin{verbatim}
COPY_EXISTING ~weapprof.2da~ ~override~
  SET_2DA_ENTRY 34 7  1 3
  SET_2DA_ENTRY 34 39 1 3
  SET_2DA_ENTRY 34 40 1 3
\end{verbatim}

Compare this with the equivalent code using \t{SET!2DA!ENTRY!LATER}
and \t{SET!2DA!ENTRIES!NOW}:
\begin{verbatim}
COPY_EXISTING ~weapprof.2da~ ~override~
  SET_2DA_ENTRY_LATER ~_#_#_#weapprof~ 34 7  3
  SET_2DA_ENTRY_LATER ~_#_#_#weapprof~ 34 39 3
  SET_2DA_ENTRY_LATER ~_#_#_#weapprof~ 34 40 3
  SET_2DA_ENTRIES_NOW ~_#_#_#weapprof~ 1
\end{verbatim}

The first approach makes three self-contained changes to the 2DA table
in weapprof.2da. Each \t{SET!2DA!ENTRY} loads the table, makes a
change and saves the table.

The second approach stores three changes to the 2DA table in memory
with \t{SET!2DA!ENTRY!LATER}. Finally, \t{SET!2DA!ENTRIES!NOW} loads
the 2DA table, makes the stored changes and saves the table. The
string \verb+~_#_#_#weapprof~+ is used for storing the changes and
whatever form it takes, it should only be used for
\t{SET!2DA!ENTRY!LATER} and \t{SET!2DA!ENTRIES!NOW}. Avoid using
variables with names containing the same string in other contexts. It
is safe to use the same string in consecutive uses of
\t{SET!2DA!ENTRY!LATER}, but not in parallel
uses. \t{SET!2DA!ENTRIES!NOW} finalizes a series and makes the string
safe to re-use. You can use \t{\%variables\%} in the string. One
suggestion is to use a prefix specific to \t{SET!2DA!ENTRY!LATER} and
onto that append the name of the file being edited, like
\verb+~_#_#_#weapprof~+, where \verb+_#_#_#+ is the prefix and
\verb+weapprof+ is the name of the file. It is specifically not safe
to use the same string for \ttref{READ!2DA!ENTRY!FORMER} as you are
using for \t{SET!2DA!ENTRY!LATER}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\t{READ!2DA!ENTRIES!NOW} and \t{READ!2DA!ENTRY!FORMER} (Last Update: v241)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\ttref{READ!2DA!ENTRIES!NOW} and \ttref{READ!2DA!ENTRY!FORMER} are
extensions of \ttref{READ!2DA!ENTRY}. You are advised to be familiar
with how \ttref{READ!2DA!ENTRY} works before reading this
tutorial.

Much like how \ttref{SET!2DA!ENTRY!LATER} and
\ttref{SET!2DA!ENTRIES!NOW} offer a performance improvement over
\ttref{SET!2DA!ENTRY} for a sufficiently large number of writes,
\t{READ!2DA!ENTRIES!NOW} and \t{READ!2DA!ENTRY!FORMER} offer a
performance improvement over \t{READ!2DA!ENTRY} for a sufficiently
large number of reads.

To illustrate the differences, consider the following code, which reads
values from a 2DA file using \t{READ!2DA!ENTRY}:
\begin{verbatim}
COPY_EXISTING ~kitlist.2da~ ~override~
  READ_2DA_ENTRY 0 1 9 somevar // somevar will be "RESERVE"
\end{verbatim}

Compare this with the equivalent code using \t{READ!2DA!ENTRIES!NOW}
and \t{READ!2DA!ENTRY!FORMER}:
\begin{verbatim}
COPY_EXISTING ~kitlist.2da~ ~override~
  READ_2DA_ENTRIES_NOW ~_#_#_#read_kitlist~ 9
  READ_2DA_ENTRY_FORMER ~_#_#_#read_kitlist~ 0 1 somevar // somevar will be "RESERVE"
\end{verbatim}

In the first approach, each 2DA entry is read in a self-contained
manner. Each time, the 2DA table is loaded and the entry from the given
row and column is extracted and stored in the variable.

The second approach loads the table once and stores it as an array of
discrete values. Retrieving a value from the table is only a matter of
getting the value of a variable. The names of the storage variables
are derived from the string, \verb+~_#_#_#read_kitlist~+ in this
case. Additionally, a variable \verb+%_#_#_#read_kitlist%+ is defined,
with a value equalling the number of rows that have at least 9
columns. In other words, using \t{READ!2DA!ENTRIES!NOW} additionally
gives you the equivalent of \ttref{COUNT!2DA!ROWS}. It is not
necessarily safe to make use of the same string in consecutive uses of
\t{READ!2DA!ENTRIES!NOW}. If you have used the same string when
reading from another 2DA table and you attempt to retrieve a value
from a column greater than the required column count, the result is
undefined. It is specifically not safe to use the same string you use
for \t{READ!2DA!ENTRIES!NOW} as you are using for
\ttref{SET!2DA!ENTRY!LATER}. In this example, the string follows the
same structure as in the \t{SET!2DA!ENTRY!LATER} and
\t{SET!2DA!ENTRIES!NOW} tutorial, but with the string \verb+read_+
prepended to the file name, to make sure the two strings can never be
identical.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{macros}\subsection{\t{DEFINE,LAUNCH,LOCAL} and everything else about personal \DEFINE{macros} (Last Update: v188)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Macros were originally intended as a way to repeat a certain tp2 block
with small or no changes without resorting to copy-and-paste.

\textbf{Note well:} In almost all circumstances it is preferable to use functions instead
of macros.

First, disclaimers: it's very easy to shoot yourself in the foot, since
there aren't any limits to the variable scoping of macros. Due to this reason, this tutorial
will skip on most basic stuff - if you're going to consider this, you should
already be a master of patching. \\
Also, for brevity, I'll give only examples involving tp2 actions. You can
do everything you're about to read here by substituting DEFINE!ACTION!MACRO
and LAUNCH!ACTION!MACRO with DEFINE!PATCH!MACRO and LAUNCH!PATCH!MACRO. There
is no change in the treatment of LOCAL!SPRINT/LOCAL!SET.

For starters, you might want to define a macro that prints "Hello World!" to
the screen.

\begin{verbatim}
// at the tp2 flag level, IE after AUTHOR but before components.
DEFINE_ACTION_MACRO ~HW~ BEGIN
  PRINT ~Hello World!~
END

/* ... */

// a component
BEGIN ~Print Hello World and do nothing~
LAUNCH_ACTION_MACRO ~HW~
\end{verbatim}

So, the syntax is quite simple:
\begin{verbatim}
DEFINE_ACTION_MACRO name-of-the-macro BEGIN
  local variables list
  action list
END
\end{verbatim}
will bind the action listed here with name-of-the-macro. We'll deal with
local variables later. After that, LAUNCH!ACTION!MACRO name-of-the-macro
will work like if you copy-pasted there the action list defined in
DEFINE!ACTION!MACRO.

Well, suppose you wanted to say 'Hello Jon!' or 'Hello Jack!' or any other
name, rather than only 'Hello World!'. Do you have to define a macro for each
of these? Of course not, since all variables defined before the LAUNCH!ACTION!MACRO
instruction is called are not cleared, and so can be read (or written) during execution of the macro.

\begin{verbatim}
// before calling, have the string ~HW_Name~ contain the name of the person
// to greet.
DEFINE_ACTION_MACRO ~HW~ BEGIN
  PRINT ~Hello %HW_Name%!~
END

/* ... */
OUTER_SPRINT ~HW_Name~ ~Jon~
LAUNCH_ACTION_MACRO ~HW~
OUTER_SPRINT ~HW_Name~ ~Jack~
LAUNCH_ACTION_MACRO ~HW~
\end{verbatim}

Variables inside macros that are changed keep their new value once the
macro has finished being computed. This is bad and good at the same time.
For example, you might want to calculate a factorial:
\begin{verbatim}
// set ~factorial_index~ to the factorial you'd like to compute,
// ~factorial_result~ to 1,
// keep a backup copy of ~factorial_index~
// ~factorial_result~ will yield the resulting factorial.
DEFINE_ACTION_MACRO ~factorial~ BEGIN
  ACTION_IF factorial_index != 1 THEN
  BEGIN
    OUTER_SET factorial_result = factorial_result * factorial_index
    OUTER_SET factorial_index = factorial_index - 1
     LAUNCH_ACTION_MACRO ~factorial~
  END
END

/* ... */
OUTER_SET factorial_index_old = 5
OUTER_SET factorial_index = 5
OUTER_SET factorial_result = 1
LAUNCH_ACTION_MACRO ~factorial~
PRINT ~%factorial_index_old%! = %factorial_result%~
\end{verbatim}
The fact that variables are kept through the entire tp2 execution (formally,
that they are global) is good, since you have a way of 'remembering' the result;
however, the bad part is that it may happen that variables are changed even if you
didn't want them to.\\
Note: risks grow exponentially as you use macros by somebody else.

By the way, another (rarely) useful feature of macros used here is that they
can call themselves (formally, they are recursive).

To solve the problem with variables being changed inside a macro, I provided
a rudimentary form of scoping: the aforementioned local variables list part.

Note: if 'global' and 'local' variables mean nothing to you (for example, if you
don't have experience in programming in real life languages) you might have
problems in understanding the logic beneath the rest of this tutorial. You'll do
fine with the tutorials about standard macros.

Basically, at the beginning of the macro declaration, you may use
\begin{verbatim}
LOCAL_SET name = value
LOCAL_SPRINT variable string
\end{verbatim}
to declare a variable as local, and assign it a new value. Use this for all variables
that don't need to be changed by the macro. After computing the macro, these variables
are set to the value they had before the macro was processed. They work for both
actions and patches. For example, here is a corrected
factorial macro (also converted to patch):
\begin{verbatim}
// set ~tb#factorial_index~ to the factorial you'd like to compute,
// ~tb#factorial_result~ to 1,
// ~ftb#actorial_result~ will yield the resulting factorial.
DEFINE_PATCH_MACRO ~tb#factorial~ BEGIN
  LOCAL_SET tb#factorial_index = factorial_index
  PATCH_IF tb#factorial_index != 1 THEN
  BEGIN
    SET tb#factorial_result = tb#factorial_result * tb#factorial_index
    SET tb#factorial_index = tb#factorial_index - 1
    LAUNCH_PATCH_MACRO ~tb#factorial~
  END
END

/* ... */
SET ~tb#factorial_index~ = 5
SET ~tb#factorial_result~ = 1
LAUNCH_PATCH_MACRO ~tb#factorial~
PATCH_PRINT ~%tb#factorial_index%! = %tb#factorial_result%~
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{standard macros (Last Update: v188)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

For your convenience, WeiDU includes some standard macros for you to use.
See \ahrefloc{sec-macros-listing}{Macros Listing} for a listing of all macros and how to invoke
them in detail. Here I'll describe the standard syntax.

In our example, we'll use the tb\#factorial macro (which is the same as the
last example in the preceding tutorial).

Description (from \ahrefloc{sec-macros-listing}{Macros Listing}):
\verb+tb#factorial+: computes the factorial of a number. \\
This is a PATCH macro.
\begin{itemize}
\item SET \verb+tb#factorial_index+ to the factorial you'd like to compute.
\item SET \verb+tb#factorial_result+ to 1;
\item The result is \verb+tb#factorial_result+.
\end{itemize}

Read the instructions on the variables to set:
\begin{verbatim}
SET ~tb#factorial_index~ = 5
SET ~tb#factorial_result~ = 1
LAUNCH_PATCH_MACRO ~tb#factorial~
PATCH_PRINT ~%tb#factorial_index%! = %tb#factorial_result%~
\end{verbatim}
(since you've read the warnings from the previous tutorial, standard macros
make use of LOCAL!SET/SPRINT to avoid overwriting variables that shouldn't
change).

Another example:

\verb+tb#fix_file_size+: overwrites all files matching a certain regexp with a
certain standard file, if they are under a certain size. \\
This is an ACTION macro.
\begin{itemize}
\item SET \verb+tb#fix_file_size_min+ to the maximum allowed size
(files whose size is exactly this value are NOT overwritten).
\item SPRINT \verb+tb#fix_file_size_target+ to the standard file used to replace file(s) that match the regexp.
\item SPRINT \verb+tb#fix_file_size_category+ to a descriptive name.
\item SPRINT \verb+tb#fix_file_size_regexp+ to the regexp for the file(s) to be checked for a match.
\end{itemize}
So, to overwrite all item files that are smaller than 0x72 with sw1h01.itm
(for example the corrupted iplot*.itm files)
\begin{verbatim}
OUTER_SET tb#fix_file_size_min = 0x72
OUTER_SPRINT tb#fix_file_size_target "SW1H01.ITM"
OUTER_SPRINT tb#fix_file_size_category "items"
OUTER_SPRINT tb#fix_file_size_regexp "^.*\.itm$"
LAUNCH_ACTION_MACRO ~tb#fix_file_size~
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec-group}\subsection{\t{GROUP} (Last update: V221)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The GROUP flag came about in discussing component management with an
abnormally large number of independent components, e.g. BG2 Tweaks. Previously
WeiDU lacked a satisfactory way to organize such a mod. The closest feature
would be the top level ASK!EVERY!COMPONENT, which only allows for a single
all-or-none approach.

The solution is a new component flag, GROUP, with the following syntax (and example):

Code:
\begin{verbatim}GROUP string

Code:
BEGIN ~100% Learn Spells~
GROUP ~Convenience Tweaks~
// component code

BEGIN ~Identify All Items~
GROUP ~Convenience Tweaks~
// component code

BEGIN ~Give Edwin his BG2 Stats~
GROUP ~NPC Tweaks~
// component code

BEGIN ~ Give Jaheira her BG2 Stats~
GROUP ~NPC Tweaks~
// component code
\end{verbatim}

Upon installing the mod, the player is now presented with meta-options on
each group at a high level:

Code:
\begin{verbatim}
Would you like to display the category [Convenience Tweaks]? [Y]es/[N]o
Would you like to display the category [NPC Tweaks]? [Y]es/[N]o
\end{verbatim}

Selecting \verb+[N]o+ on any group suppresses those options from being
displayed, leading to a simpler and more controlled installer experience for
the player. In the provided example, selecting \verb+[N]o+ to Convenience
Tweaks and \verb+[Y]es+ to NPC Tweaks would result in WeiDU starting
installation by asking to install the Give Edwin his BG2 Stats component.

GROUP operates independently of SUBCOMPONENT, meaning you can use both to
organize the mod as needed. A few other items of note:
\begin{itemize}
\item A component can belong to multiple GROUPs; a component is not offered
for install if and only if none of its member groups are selected
\item You could, in theory, have two components in the same SUBCOMPONENT
grouping but different GROUPs. Don't do this.
\item You can give a GROUP a condition, by adding a patch_expression after the
GROUP definition. This way, the user will not be asked about that GROUP (and
its components will be automatically skipped). If you give different conditions
to the components in a GROUP, these conditions are OR()red.
\item Because of a couple of issues with ordering and/or GROUPs not appearing,
you are encouraged to put, at the end of your tp2, a dummy component for each
GROUP, in the order you'd like to show them to the user. For the above example,
if you want to ask about the 'Convenience Tweaks' group before the 'NPC Tweaks'
one, the code becomes:
\begin{verbatim}
BEGIN ~100% Learn Spells~
GROUP ~Convenience Tweaks~
// component code

BEGIN ~Identify All Items~
GROUP ~Convenience Tweaks~
// component code

BEGIN ~Give Edwin his BG2 Stats~
GROUP ~NPC Tweaks~
// component code

BEGIN ~ Give Jaheira her BG2 Stats~
GROUP ~NPC Tweaks~
// component code

BEGIN ~Dummy component because it's too hard to fix this in WeiDU~
DEPRECATED ~Dummy component~
GROUP ~Convenience Tweaks~

BEGIN ~Dummy component because it's too hard to fix this in WeiDU~
DEPRECATED ~Dummy component~
GROUP ~NPC Tweaks~ GAME_IS ~bg2 tob~ // will not be asked for in Tutu
\end{verbatim}
This isn't needed for the above example, but it might be needed in more complex
scenarios.
\item If some components of a mod are in a GROUP, but others are not, the
non-GROUPed components will always be presented.
\item Using a GROUP anywhere in your mod will act as an implied
ASK!EVERY!COMPONENT tp2 flag.
\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec-array-construct}\subsection{\t{array construct}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The array construct is a facile way of constructing multi-component
variables. If you come from a programming background, the array
construct has little in common with conventional arrays. It can be
more accurately thought of as a multi-dimensional cross between an array
and a dictionary.

The array construct can have any number of keys but only a single result.

The construct is formed as follows:
\verb+$variable(key list)+

The construct can be used to store a result when used on the left-hand
side of an expression or to retrieve a result when used on the
right-hand side. For example, the following code snippet illustrates
how the array construct could be used to dynamically construct a
dictionary at install-time. A dictionary can be used to look up an
associated value for any key value included in the dictionary. Here we
use it to parse kitlist.2da to construct a dictionary of which
CLAB-file is associated with each kit.

\begin{verbatim}
COPY_EXISTING kitlist.2da override
  READ_2DA_ENTRIES_NOW kitlist 9
  FOR (i = 1; i < kitlist; ++i) BEGIN
    READ_2DA_ENTRY_FORMER kitlist i 1 kit
    READ_2DA_ENTRY_FORMER kitlist i 5 clab
    SPRINT $kitlist("%kit%") "%clab%"
  END
BUT_ONLY
\end{verbatim}

Arrays can either be iterated over with the action
\ttref{ACTION!PHP!EACH} or patch \ttref{PHP!EACH}.

\begin{verbatim}
ACTION_PHP_EACH kitlist AS kit => clab BEGIN
  PRINT "Kit %kit% uses CLAB-file %clab%"
END
\end{verbatim}

You can easily make use of the dictionary properties by using the
array construct on the right-hand side of the expression and inserting
one of the keys found in the construct.

\begin{verbatim}
OUTER_SPRINT clab $kitlist(cavalier)
PRINT "The Cavalier kit uses the CLAB-file %clab%"
\end{verbatim}

Using an invalid key produces the same result as trying to use an
undefined variable. Using multiple keys works analogously. As a
completely artificial example:

\begin{verbatim}
OUTER_SET $var(a b c) = 1
OUTER_SET number = $var(a b c)
\end{verbatim}

The array construct can also be used to retrieve results from arrays
constructed in other ways, like with \ttref{ACTION!DEFINE!ARRAY} or
\ttref{ACTION!DEFINE!ASSOCIATIVE!ARRAY}. For example:

\begin{verbatim}
ACTION_DEFINE_ARRAY array BEGIN a b c END
OUTER_SPRINT letter $array(2)
PRINT "The second letter is %letter%" // Will print "b"
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec-modder}\subsection{\t{MODDER} (Last update: v247)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The MODDER flag allows for more debugging info to be reported. It is suggested to
leave MODDER enabled while you're developing your mod and then disable it before
you ship it to the players. However, given different coding styles, it is possible
that something gets interpreted as a critical bug for some users and as expected
behavior for others. For this reason, it's possible to fine-tune the reporting level
for some of the bugs that are found. This is done by writing additional modifiers
after your MODDER statement, for example:
\begin{verbatim}
MODDER setup_tra fail area_variables none missing_extern warn
\end{verbatim}

Each option can be set to either NONE, WARN or FAIL with the above syntax,
with the obvious meaning. If none are chosen, WARN is assumed. WARN may generate false positives.
In this case, "INSTALLED WITH WARNINGS" is not displayed.

Options set via the the command line supercede options set via the MODDER statement.

Here the list of feedback options that you can configure, along with use cases when you
should deactivate them. In all other cases, using FAIL or WARN is a case of personal
preference (for example, use WARN early in the development process and FAIL when you're
near the beta status).
\begin{itemize}
\item setup_tra: a dialogue/script uses @references that aren't available from
     its own tra file, but are taken instead from the tp2-level setup.tra.
     \\
     When to use NONE: you're knowingly using references from
     setup.tra into scripts and/or dialogues, rather than using file-specific TRA files.
\item area_variables: the variable scope in a BAF/D \verb+*Global*("varname","scope")+
     statement is six characters long, but not GLOBAL, MYAREA, LOCALS, or a valid area name.
     \\
     When to use NONE: you biff your .are files using bat files, or you copy them to
		 the override after compiling your scripts.
\item missing_extern: an EXTERN transition in a D file references a DLG file that
     doesn't exist, nor is created in the current file.
     \\
     When to use NONE: you have two separate D files that EXTERN to each other.
\item missing_resref: a file referenced by a scripting command (EG a CRE file for a
     CreateCreature action) is not available.
     \\
     When to use NONE: you biff your files using bat files, or you copy them to
		 the override after compiling your scripts.
\item ict2_actions: you call an I_C_T2 into a state which has different actions.
		 If the different actions look like they're caused by another mod ICT2'ing in
		 the same state, only the warning is printed, further actions are not processed.
     \\
     When to use NONE: you want to ICT2 into a state with different exit actions.
\item missing_eval: WeiDU thinks that you forgot to use EVALUATE_BUFFER to evaluate
     variables in a command. Currently used for:
     \begin{itemize}
     \item WRITE_ASCII (vs. WRITE_ASCIIE)
     \item STR_VAR
     \item COMPILE
     \item arrays
     \end{itemize}
\item overwriting_file: you are writing to a file that exists (physically and/or in biffs).
\item fun_args: functions are launched with \verb+INT_VAR+s or \verb+STR_VAR+s
  that and not included in the function's definition.
\end{itemize}

An important note: if a tp2 sets MODDER, the debugging mode might propagate to
other mods. As such, \emph{REMEMBER TO TURN MODDER OFF WHEN YOU RELEASE YOUR MOD.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec-readln}\subsection{\t{READLN} (Last update: v203)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Attention. You are urged to use something other than READLN if you
can. You can read more at the end of this tutorial.

This tutorial has been brought to you by plainab.

The goal of this tutorial is to explain the use of READLN within the tp2 structure.
READLN can be used as an action or as a patch.  My experience has been in using it
as an action command. I will describe the usage of READLN and then give you some
examples of its use.  To put it bluntly READLN stands for "read line" and it's use
causes WeiDU to pause and read any information entered by the user on the interface
screen and to then store that information within the given variable.

Syntax:
\begin{verbatim}
ACTION_READLN ~variable~
PATCH_READLN ~variable~
\end{verbatim}

Lets build an example from scratch:

First we need to have something we want to change.  For this example we will use the
stack amount for item files.  We could pick a high number and simply use:

\begin{verbatim}
COPY_EXISTING_REGEXP ~.*\.itm~ ~override~
 WRITE_SHORT 0x38 9999 //stack value
BUT_ONLY_IF_IT_CHANGES
\end{verbatim}

Or we can let the end user choose how many items they want in their stacks.
To do that we first need to ask the user a question.

\begin{verbatim}
PRINT ~How many of one item do you want to be able to be stacked?~
\end{verbatim}

If we leave it at this, weidu will display the question, but keep running.
We have to make weidu pause and that is where READLN comes in. So we now have:

\begin{verbatim}
PRINT ~How many of one item do you want to be able to be stacked?~
ACTION_READLN ~new_stack~
\end{verbatim}

We can then take this entered value and use it on our copy block.

So the usage in this example would be:

\begin{verbatim}
BEGIN ~Modify the stack value of all items~
PRINT ~How many of one item do you want to be able to be stacked?~
ACTION_READLN ~new_stack~

COPY_EXISTING_REGEXP ~.*\.itm~ ~override~
 WRITE_SHORT 0x38 %new_stack% //stack value
BUT_ONLY_IF_IT_CHANGES
\end{verbatim}

You could leave it at this and it will work, but I will tell you now that the end
user can input any character from their keyboard.  READLN doesn't care what is
entered, but weidu may have problems if it is expecting an integer rather than text.
To get around that issue we need to add a loop that will re-ask the question when the
user enters the incorrect type of information.

\begin{verbatim}
BEGIN ~Modify the stack value of all items~
PRINT ~How many of one item do you want to be able to be stacked?~
ACTION_READLN ~new_stack~

OUTER_WHILE NOT(IS_AN_INT %new_stack%) BEGIN
 PRINT ~How many of one item do you want to be able to be stacked?~
 ACTION_READLN ~new_stack~
END

COPY_EXISTING_REGEXP ~.*\.itm~ ~override~
 WRITE_SHORT 0x38 %new_stack% //stack value
BUT_ONLY_IF_IT_CHANGES
\end{verbatim}

The loop we added looks to see if the entered value is an integer and if the
entered value is not an integer then it will re-ask the question.  This loop
will go indefinitely until the user inputs the correct type of information.
Should your user not understand why they keep getting asked the question you may
wish to add new text to your questions to help them to understand what it is
you are looking for.  As in this example:

\begin{verbatim}
BEGIN ~Modify the stack value of all items~
PRINT ~How many of one item do you want to be able to be stacked?
Please enter your answer as an integer.~
ACTION_READLN ~new_stack~

OUTER_WHILE NOT(IS_AN_INT %new_stack%) BEGIN
 PRINT ~Your answer was not an integer.
Please enter your answer as an integer.
How many of one item do you want to be able to be stacked?~
 ACTION_READLN ~new_stack~
END

COPY_EXISTING_REGEXP ~.*\.itm~ ~override~
 WRITE_SHORT 0x38 %new_stack% //stack value
BUT_ONLY_IF_IT_CHANGES
\end{verbatim}

That is the basics on asking for information from the user and then applying that
information later on in the install process.  PATCH_READLN works just like
ACTION_READLN only it's location of use within the tp2 is different.

\\

Another use of READLN is to create options that the user can choose from.
Top level options are taken care of by the use of SUBCOMPONENT and/or GROUP, but since
WeiDU cannot nest subcomponents, you can use READLN to offer additional choices beneath
the first set of subcomponents.  Here's an example of a finished product where READLN is
used to offer additional choices to a subcomponent.  The relevant parts to this discussion
were taken from iiProjectileRetrievalMod.  I helped to create this portion of the mod.
It works.  I have however since learned of better methods that would eliminate some of the
READLN usage from this example.

\begin{verbatim}
BEGIN ~Easy TUTU~
SUBCOMPONENT ~Projectile Retrieval Mod~
INCLUDE ~iiprojectiler/E22.tph~  // Easy TUTU version of mod

BEGIN ~All other Infinity Engine Games~
SUBCOMPONENT ~Projectile Retrieval Mod~

PRINT ~Please tell me how you'd like to modify your files.

1. I want to modify ALL thrown/projectiles at once.
2. I want to modify each thrown/projectile one at a time.

PLEASE ENTER  1 OR 2  ~
ACTION_READLN how
OUTER_WHILE NOT(IS_AN_INT %how%) || (%how% > 2) || (%how% < 1) BEGIN
 PRINT ~Please tell me how you'd like to modify your files.

1. I want to modify ALL thrown/projectiles at once.
2. I want to modify each thrown/projectile one at a time.

PLEASE ENTER  1 OR 2  ~
 ACTION_READLN how
END

ACTION_IF (%how% = 1) THEN BEGIN
 PRINT ~Please choose how you'd like ALL your projectiles retrieved.

1. Plain projectile only -> Plain projectile only
2. All projectiles       -> Plain projectile only
3. Each projectile       -> Each projectile
4. Magical projectiles   -> Reduced Magical/Plain projectiles

PLEASE ENTER  1, 2, 3, OR 4  ~
 ACTION_READLN choice
 OUTER_WHILE NOT(IS_AN_INT %choice%) OR (%choice% > 4) OR (%choice% < 1) BEGIN
  PRINT ~Please choose how you'd like ALL your projectiles retrieved.

1. Plain projectile only -> Plain projectile only
2. All projectiles       -> Plain projectile only
3. Each projectile       -> Each projectile
4. Magical projectiles   -> Reduced Magical/Plain projectiles

PLEASE ENTER  1, 2, 3, OR 4  ~
  ACTION_READLN choice
 END
\end{verbatim}

There is a problem with using READLN. Notably, READLN pauses the
installation until the user inputs an answer. This requires the player
to baby-sit the installation and attentively watch for READLNs. It
also causes problems for automated installation tools, which are
increasingly becoming popular. Modders are urged to be choose
solutions beside READLN, such as subcomponents, or even making use of
configuration files, if these are suitable.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec-functions}\subsection{\t{Functions} (Last update: V247)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Macros can have unintended side effects because they change the global variable environment.
You have to be extremely careful when interacting with the ``outside''.

That's why functions were introduced in v209. Any changes to the variables are only visible
inside the function. You can also provide default arguments and return values.

As with macros these functions come in an ACTION and a PATCH variant. So the corresponding
commands are: DEFINE!ACTION!FUNCTION / DEFINE!PATCH!FUNCTION (both actions) and
LAUNCH!ACTION!FUNCTION (action) / LAUNCH!PATCH!FUNCTION (patch).

Before you can use a function you have to DEFINE it:
\begin{verbatim}
DEFINE_PATCH_FUNCTION count_spells INT_VAR level = 1 STR_VAR type = "WI" RET num BEGIN
    SET num = 0
    PATCH_IF (~%SOURCE_EXT%~ STRING_EQUAL_CASE ~CRE~) THEN BEGIN
        // do some magic here that actually counts the number of spells and sets
        // the variable num to that number.
    END
END
\end{verbatim}

The function is defined with default values for the variables
\verb+level+ and \verb+type+. These default values override any values
the corresponding variables may have in the environment of the
function's caller, unless other values are provided as part of calling
the function (\textit{vide infra}).

After that you can LAUNCH it:
\begin{verbatim}
COPY_EXISTING ~my.cre~ ~override~
    // count number of level 1 wizard spells (default arguments of the function)
    LAUNCH_PATCH_FUNCTION count_spells RET lvl1_wizard = num END
    // and now the level 5 priest spells
    LAUNCH_PATCH_FUNCTION count_spells INT_VAR level = 5 STR_VAR type = "PR" RET lvl5_priest = num END

    PATCH_PRINT ~This CRE has %lvl1_wizard% level 1 wizard spells and %lvl5_priest% level 5 priest spells~
\end{verbatim}

The first time the function is called, the definition's default values
for \verb+level+ and \verb+type+ are used. The second time, the values
of the variables are given when the function is called.

Any variables you change inside the function will revert back to their old value
after the function finishes.
That's why you have to specify what values should be return values.
You can do this in the RET part of the function definition (\verb+RET num+).
When you launch the function you can use these variables to import the value
into your current variable environment (\verb+RET lvl1_wizard = num+).
Separate the variables with a space character if you have multiple return values.

As of V244, you can return whole arrays with the \verb+RET_ARRAY+
keyword. Like with \verb+RET+, you can optionally assign the array to
a different name by using assignment when launching the function.

\begin{verbatim}
DEFINE_ACTION_FUNCTION foobar
  RET_ARRAY
    foo
    bar
BEGIN
  ACTION_DEFINE_ARRAY foo BEGIN 1 2 3 END
  ACTION_DEFINE_ARRAY bar BEGIN a b c END
END

LAF foobar RET_ARRAY foo baz = bar END

// After the function has returned, the arrays foo and baz will exist
// The array baz will be derived from the array bar

ACTION_PHP_EACH foo AS _ => v BEGIN
  PRINT "%v%" // will print 1, 2 and 3
END

ACTION_PHP_EACH baz AS _ => v BEGIN
  PRINT "%v%" // will print a, b and c
END

\end{verbatim}

If you don't need certain features simply omit them:
\begin{verbatim}
DEFINE_ACTION_FUNCTION xyz INT_VAR x = 1 y = 2 z = 3 BEGIN
    PRINT ~x: %x%, y: %y%, z: %z%~
END

LAUNCH_ACTION_FUNCTION xyz END
\end{verbatim}

Starting from V210, you can also specify a variable that will be local to the
function environment, without being passed back to the calling environment,
by adding either STR!VAR or INT!VAR to the LAUNCH bit:
\begin{verbatim}
DEFINE_ACTION_FUNCTION xyz INT_VAR x = 1 y = 2 z = 3 BEGIN
    PRINT ~x: %x%, y: %y%, z: %z%~
END

LAUNCH_ACTION_FUNCTION xyz INT_VAR x = 0 END

OUTER_SET y = 5
LAUNCH_ACTION_FUNCTION xyz INT_VAR y END // synonym for INT_VAR y = y
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec-get-offset-array12}\subsection{\t{GET!OFFSET!ARRAY} and \t{GET!OFFSET!ARRAY2} (last edit: 218)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Many thanks to Wisp for providing this tutorial.

GET!OFFSET!ARRAY and GET!OFFSET!ARRAY2 are means for obtaining information about certain types of file structures without using the usual READs, FORs etc. GET!OFFSET!ARRAY can, for example, be used to find the starting offsets for all the extended headers (abilities) in an item, while GET!OFFSET!ARRAY2 can be used to find the starting offsets for all extended effects in the item. Since the effect structure is organised by the ability structure, GET!OFFSET!ARRAY2 is conventionally used together with GET!OFFSET!ARRAY.

The seven values required by GET!OFFSET!ARRAY are:
\begin{verbatim}
1. Offset
2. Read length of "Offset"
3. Iterations
4. Read length of "Iterations"
5. Index
6. Read length of "Index"
7. Length between iterations.
\end{verbatim}

Acceptable values for read length are 0 (don't read), 2 (SHORT) and 4 (LONG). Length between iterations depends on the file structure you are working with. In our item example, length between iterations is 0x38 while we are using GET!OFFSET!ARRAY. If we were working with a spell instead, it would be 0x28.

In the item example, "Offset" is 0x64, which gives the ability offset when read.
The value read from "Iterations" is the number reads that should be performed. "Iterations" is 0x68 in the item example, which gives the number of abilities when read.
The value read from "Index" is the number of iterations into the file the current read should be made. This is not always relevant for GET!OFFSET!ARRAY, but for reading general effects (on-equip effects), this is 0x6e.

GET!OFFSET!ARRAY2 requires an additional value. Let's call it Offset2. This value is normally obtained as the result from GET!OFFSET!ARRAY. In our item example this value is the starting offset for the current ability. The value of "Offset" is now 0x6a, which gives the effect offset. The value of "Iterations" is now 0x1e, which gives the number of effects, the value of "Index" is now 0x20 and both are read from Offset2 + value (unlike GET!OFFSET!ARRAY where they are read from the start of the file).

For example, if we wanted to know how many levels Blackrazor can drain, we could use this code:
\begin{verbatim}
COPY_EXISTING miscbc.itm override
  GET_OFFSET_ARRAY ab_array 0x64 4 0x68 2 0 0 0x38
  PHP_EACH ab_array AS int => ab_off BEGIN
    GET_OFFSET_ARRAY2 fx_array ab_off ITM_V10_HEAD_EFFECTS
    PHP_EACH fx_array AS int => fx_off BEGIN
      READ_SHORT fx_off fx_type
      PATCH_IF fx_type = 216 BEGIN
        READ_LONG fx_off + 0x4 amount
        PATCH_PRINT "I drain %amount% level(s)"
      END
    END
  END
BUT_ONLY
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec-match-and-try}\subsection{\t{MATCH} and \t{TRY} (last edit: 245)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\verb+MATCH+ is the equivalent of switch..case in mainstream languages (except
it also works on strings, similar to OCaml's match..with). This is a type of
selection control statement whose purpose is to allow the value of a variable
or expression to control the flow of program execution via a multiway branch.
The main reasons for using this type of statement include improving clarity
and reducing otherwise repetitive coding.

\textbf{N.B.} \t{TRY} is generally \emph{not safe} to use because many
errors are intended to be fatal and if the mod installation were to
proceed anyway, it might do so in an inconsistent state, with resource
leaks or with other errors. \ttref{ACTION!RERAISE} and
\ttref{PATCH!RERAISE} mitigates or eliminates these risks, since the
unsafe part is allowing the installation to continue and re-raising
the error allows it to fail, like intended.

\verb+TRY+ is used to detect TP2 failures (= anything that blocks the installation
and prints "NOT INSTALLED DUE TO ERRORS") and allows the modder to run custom
code (without forcibly failing the installation). The syntax is very similar
to \verb+MATCH+, which is why these two commands are presented together.

This tutorial documents \verb+ACTION!MATCH+ and \verb+ACTION!TRY+, but the
patch equivalents (\verb+PATCH!MATCH+ and \verb+PATCH!TRY+) are also
available.

This is a sample code for \verb+MATCH+:
\begin{verbatim}
ACTION_MATCH 12 + 14 // value
WITH
  15 16 // guards
  BEGIN
    PRINT ~15 or 16~ // guarded actions
  END
  15 + 5 ~str.*with%vars% and regexp~
  BEGIN
    PRINT ~15 + 5 or matches "str.*with%vars% and regexp"~
  END
  DEFAULT
    PRINT ~default~ // default actions
END
\end{verbatim}

To begin with, the value (12 + 14) is evaluated (can be any integer or a string).
After that, it is compared against each guard: it is neither 15 nor 16, so its
guarded action is not executed.  Similarly, it is neither 15 + 5 (= 20)
nor does it match the regexp \verb+~str.*with%vars% and regexp~+ after evaluating
variables and case-insensitive regexp, so its guarded actions aren't executed either.
Since no listed value is printed, the default action(s) are executed (in this case,
\verb+PRINT ~default~+).

\verb+MATCH+ can also compare against strings:
\begin{verbatim}
OUTER_SET var = 15
ACTION_MATCH ~string%var%~
WITH
  ~string12~ ~string2.*~
  BEGIN
    PRINT ~string12 or string2.*~
  END
  ~string1[12345]~
  BEGIN
    PRINT ~string1[12345]~
  END
  DEFAULT
    PRINT ~default~
END
\end{verbatim}
In this case, \verb+PRINT ~string1[12345]~+ is executed.

Guards can also have a condition associated; in that case, the value must match
against one of the guards and the condition must be true:
\begin{verbatim}
ACTION_MATCH ~%something%~
WITH
  ~none~ WHEN GAME_IS ~BG1 TotSC~
  BEGIN
    // ~none~ and the game is BG1
  END
  ~none~
  BEGIN
    // ~none~ and the game is not BG1
  END
  DEFAULT
    // not ~none~
END
\end{verbatim}

It is also possible to have a condition without a guard, in which case the
syntax is:
\begin{verbatim}
ACTION_MATCH ~%something%~
WITH
  ANY GAME_IS ~BG1 TotSC~
  BEGIN
    // the game is BG1
  END
  ANY GAME_IS ~SoA ToB~
  BEGIN
    // the game is BG2
  END
  DEFAULT
    // not BG1 or BG2
END
\end{verbatim}

Specific cases that might be worth mentioning:
it is possible for a guarded action to be empty, to have no default actions,
or to only have default actions, as per the following examples:
\begin{verbatim}
ACTION_MATCH ~%something%~
WITH
  ~no action~ ~none~ ~empty~ ~~
  BEGIN
    // empty guarded action: default action never executed
  END
  ~error~
  BEGIN
    FAIL ~error~
  END
  DEFAULT
    DO_THIS_AND_THAT
END

ACTION_MATCH ~%something%~
WITH
  ~value1~ ~value2~ ~value3~
  BEGIN
    DO_SOMETHING
  END
  ~error~
  BEGIN
    FAIL ~error~
  END
  DEFAULT
    // no default action: nothing is done for unmatched values
END

ACTION_MATCH ~%something%~
WITH
  DEFAULT
    // no guarded actions, only default actions: always executed
    DO_THIS_AND_THAT
END
\end{verbatim}

Also, no more than one group of actions is executed:
\begin{verbatim}
ACTION_MATCH ~string123~
WITH
  ~string123~
  BEGIN
    DO_THIS // executed
  END
  ~string123~
  BEGIN
    DO_THAT // not executed
  END
  DEFAULT
    DO_BOTH // also not executed
END
\end{verbatim}
\\
\\
\\
\\
\verb+TRY+ is similar to \verb+MATCH+:
\begin{verbatim}
ACTION_TRY
  COPY ~override/sw1h01.itm~ ~override~
  DO_SOMETHING_ELSE
WITH
  ~Unix.Unix_error(20, "stat", "override/sw1h01.itm")~
  BEGIN
    PRINT ~I caught sw1h01.itm not found!~
  END
  ~Unix.Unix_error(20, "stat", "override/.*.itm")~
  BEGIN
    PRINT ~I caught another missing item!~
  END
  DEFAULT
    PRINT ~I caught another error!~
END
\end{verbatim}

The actions in \verb+ACTION_TRY+ are executed. If none of those fails, the
\verb+WITH+ part is skipped; otherwise, the error message is printed as usual
(use \ttref{SILENT}), the exception text (from the ERROR: blah blah line) is
saved to the \verb+%ERROR_MESSAGE%+ variable, and a \verb+MATCH+ is executed
on that.

After running the correct error handling code, execution continues after the
end of the \verb+ACTION_TRY+ block. If you still want to block the
installation, use \verb+ACTION_RERAISE+ (in theory, you could use
\verb+FAIL ~%ERROR_MESSAGE%~+, but this changes the exception and its text,
which would cause you headaches when nesting multiple \verb+TRY+s).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec-quick-menu}\subsection{\t{QUICK!MENU} (last edit: 227)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This tp2 flag is used to define groups of components that the user will be
offered to install in a single step. Sample code:

\begin{verbatim}
QUICK_MENU
  ALWAYS_ASK 5 END
  ~Red~ BEGIN 1 2 END
  ~Green~ BEGIN 2 3 END
  ~Blue~ BEGIN 4 6 END
END
\end{verbatim}

The user will be presented with the following prompt:

\begin{verbatim}
The test/test.tp2 mod has 13 distinct optional components.
To save time, you can choose what to do with them at a high level rather than being asked about each one.

[A]sk about each component, [S]kip all, or choose a pre-defined selection:
 1] Red
 2] Green
 3] Blue
\end{verbatim}

If some mod components were already installed, the option to [U]ninstall
or [R]einstall the currently installed components will also be offered.

If the user chooses to install a pre-defined selection, then its components
will be installed, and ALL other components of the mod will be uninstalled
if already installed.

Components in ALWAYS_ASK will always be asked for individually if the user
chose to install one of the pre-defined selections (or, of course, if he chose
[A]). If the user chose [S], [R] or [U] the same action will be applied to the
components in ALWAYS_ASK.

Caveats:
\begin{itemize}
\item If a component is in both ALWAYS_ASK and a pre-defined selection the mod
will refuse to install.
\item Because of a complex problem whose details are too technical for this
document, component 0 of your mod must be empty (or your mod will refuse to
install), must not be in any pre-defined selection or in ALWAYS_ASK (or your
mod will refuse to install) and will always be (re)installed (unless the user
chooses [S]kip all).

This also means that your mod's components will always be grouped together (you
can't install a component from your mod, then a second mod, and then other
components of your mod).
\item Some of the listed failure points are not checked for when the mod is
installed non-interactively (--yes, --force-install and friends). Test the menu
system at least once before releasing your mod, even if you do the bulk of the
development of your mod using --yes and the like.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec-handle-audio-and-handle-tilesets}\subsection{\t{HANDLE!AUDIO} and \t{HANDLE!TILESETS}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\ttref{HANDLE!AUDIO} and \ttref{HANDLE!TILESETS} are convenience
functions for the common tasks of installing mod-supplied audio and
tilesets. All IE games are supported and the specifics for each game
is handled automatically. The functions are designed to take care of
as many as the platform-specific details as possible, including the
differences between Windows, OS\begin{rawhtml}&nbsp;\end{rawhtml}X and
GNU/Linux.

There is one exception to this, however. At present, to use
\verb+HANDLE_AUDIO+ you need to include oggdec.exe for Windows and SoX
for OS\begin{rawhtml}&nbsp;\end{rawhtml}X in your mod. To use
\verb+HANDLE_TILESETS+ you need to include tisunpack for Windows and
OS\begin{rawhtml}&nbsp;\end{rawhtml}X. In both cases it is recommended
that GNU/Linux users install oggdec and tisunpack themselves. Most
modern GNU/Linux distributions come with oggdec already installed. A
copy of tisunpack compiled for GNU/Linux is distributed together with
the Linux version of WeiDU. If you want to facilitate the installation
of your mod on GNU/Linux, you should state that your mod depends on
oggdec or tisunpack, as appropriate.

\ttref{HANDLE!AUDIO} expects your audio to be in the Ogg Vorbis format.
If you have WAV or WAVC files, you do not need \verb+HANDLE_AUDIO+,
you can simply copy them to the override.

With no configuration, \verb+HANDLE_AUDIO+ expects your audio,
oggdec.exe and SoX to be located in \verb+mymod/audio+. Using
\verb+HANDLE_AUDIO+ is then as simple as a single line of TP2:
\begin{verbatim}
LAF HANDLE_AUDIO END
\end{verbatim}

\verb+LAF+ is an alias for \ttref{LAUNCH!ACTION!FUNCTION}.
\verb+HANDLE_AUDIO+ is a completely independent function, and does not
have no be placed before or after anything else in your TP2 file. It
is equivalent to a TP2 action and you obviously need to place it in
the right component, but that is it.

\verb+HANDLE_AUDIO+ can also be configured to use audio in a different
directory, through the string variable \verb+audio_path+. The value of
this variable is the directory in which \verb+HANDLE_AUDIO+ should
look for audio, oggdec.exe and SoX. So, for instance, if you keep your
sounds in \verb+mymod/sound+ you would configure \verb+HANDLE_AUDIO+
like so:
\begin{verbatim}
LAF HANDLE_AUDIO STR_VAR audio_path = ~mymod/sound~ END
\end{verbatim}
If you want \verb+HANDLE_AUDIO+ to look for oggdec.exe or SoX in
another directory than \verb+audio_path+, you can use the
\verb+oggdec_path+ and \verb+sox_path+ variables.  For example, if you
have your voice-overs in \verb+mymod/audio/vo+, your music in
\verb+mymod/audio/music+, and oggdec.exe and SoX in \verb+mymod/audio+
you could install it like so:
\begin{verbatim}
LAF HANDLE_AUDIO
  STR_VAR
    audio_path = ~mymod/audio/vo~
    oggdec_path = ~mymod/audio~
    sox_path = ~mymod/audio~
END
LAF HANDLE_AUDIO
  INT_VAR
    music = 1
  STR_VAR
    audio_path = ~mymod/audio/music~
    oggdec_path = ~mymod/audio~
    sox_path = ~mymod/audio~
END
\end{verbatim}
The integer variable \verb+music+ simply tells \verb+HANDLE_AUDIO+
that you want the audio handled as music. This only makes a difference
on BGEE.

The function \ttref{HANDLE!TILESETS} follow the same design as
\verb+HANDLE_AUDIO+. \verb+HANDLE_TILESETS+ decompresses and installs
TIZ files rather than OGG files and uses tisunpack rather than
oggdec/SoX.

With no configuration, \verb+HANDLE_TILESETS+ expects your TIZ files
to be located in \verb+mymod/tiz+. Additionally, it expects tisunpack
for Windows to be located in \verb+mymod/tiz/win32+ and tisunpack for
OS\begin{rawhtml}&nbsp;\end{rawhtml}X to be located in
\verb+mymod/tiz/osx+. You install you tilesets like so:
\begin{verbatim}
LAF HANDLE_TILESETS END
\end{verbatim}
The string variables \verb+tiz_path+ and \verb+tisunpack_path+ allow
you to configure \verb+HANDLE_TILESETS+ to look for TIZ files or
tisunpack in other directories. Note that you do not specify the
individual directories for tisunpack for Windows or tisunpack for OS
X. Instead you specify the parent directory and WeiDU will then use
the value of the variable \ttref{WEIDU!OS} to find the right version
of tisunpack. For example, if you keep your TIZ files in
\verb+mymod/tilesets+ and tisunpack for Windows in
\verb+mymod/bin/win32+ and tisunpack for
OS\begin{rawhtml}&nbsp;\end{rawhtml}X in \verb+mymod/bin/osx+ you
could install your tilesets like so:
\begin{verbatim}
LAF HANDLE_TILESETS
  STR_VAR
    tiz_path = ~mymod/tilesets~
    tisunpack_path = ~mymod/bin~
END
\end{verbatim}

To conclude this tutorial, here is a fictional (but valid) example of
a TP2 file of a mod where \verb+HANDLE_AUDIO+ and
\verb+HANDLE_TILESETS+ are used:
\begin{verbatim}
BACKUP ~fl#xmpl/backup~
AUTHOR ~Wisp~

BEGIN ~E. G. McExample NPC~

COPY ~fl#xmpl/copy~ override

COMPILE ~fl#xmpl/compile~

LAF HANDLE_AUDIO END

LAF HANDLE_TILESETS END

COPY ~fl#xmpl/character/fl#xmpl.cre~ override
  SAY NAME1 ~E. G. McExample~
  SAY NAME2 ~E. G. McExample~
  // Other SAYs

// End of File
\end{verbatim}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\DEFINE{Code dumps}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This section contains code snippets that serve to document functionality
not covered elsewhere.

These snippets are provided by Miloch.
\begin{verbatim}
//For each dialogue, change GivePartyGold() to GiveGoldForce() actions
ACTION_FOR_EACH dialog IN ~arkion~ ~ardrou~ ~berrun~ ~brevli~ ~brielb~ ~forthe~ ~gurke~ BEGIN
  ACTION_IF FILE_EXISTS_IN_GAME ~%dialog%.dlg~ BEGIN
    COPY_EXISTING ~%dialog%.dlg~ ~override~
      PATCH_IF SOURCE_SIZE > 0x34 BEGIN
        DECOMPILE_DLG_TO_D
        REPLACE_TEXTUALLY CASE_INSENSITIVE EXACT_MATCH ~GivePartyGold~ ~GiveGoldForce~
        COMPILE_D_TO_DLG
      END
    BUT_ONLY
  END
END

//Compress a BAM
COPY ~bambatch/bam~ ~bambatch/bam~
  READ_ASCII 0x0 sg (4) //Signature
  PATCH_IF (~%sg%~ STRING_EQUAL_CASE ~BAM ~ = 1) BEGIN
    dl = SOURCE_SIZE //Data length
    COMPRESS_REPLACE_FILE 0 dl 9
    INSERT_BYTES 0x0 0xc
    WRITE_ASCII 0x0 ~BAMCV1  ~
    WRITE_LONG 0x8 dl
  END ELSE BEGIN
    PATCH_PRINT ~%SOURCE_FILE% is not an uncompressed BAM.~
  END
BUT_ONLY

//Decompress a BAM
COPY ~bambatch/bam~ ~bambatch/bam~
  READ_ASCII 0x0 sg (4) //Signature
  PATCH_IF (~%sg%~ STRING_EQUAL_CASE ~BAMC~ = 1) BEGIN
    READ_LONG 0x8 dl //Uncompressed data length
    DECOMPRESS_REPLACE_FILE 0xc (SOURCE_SIZE - 0xc) dl
  END ELSE BEGIN
    PATCH_PRINT ~%SOURCE_FILE% is not a compressed BAM.~
  END
BUT_ONLY

//Defines an array associating creatures with a new amount of gold
ACTION_DEFINE_ASSOCIATIVE_ARRAY newgold BEGIN
  ~arkion~ => 100
  ~ardrou~ => 10
  ~berrun~ => 58
  ~brevli~ => 5
  ~brielb~ => 200
  ~gurke~ => 20
  ~oublek~ => 1000
  ~perdue%~ => 75
  ~pheirk%~ => 38
  ~scar~ => 1026
  ~sonner~ => 150
  ~wenric~ => 170
  ~jarlaxle~ => 25
  ~ppsime~ => 50
  ~yschearl~ => 150
END

//Writes the new amount of gold for each creature above if it exists
ACTION_PHP_EACH newgold AS crename => gold BEGIN
  ACTION_IF FILE_EXISTS_IN_GAME ~%crename%.cre~ BEGIN
    COPY_EXISTING ~%crename%.cre~ ~override~
      PATCH_IF SOURCE_SIZE > 0x2d3 BEGIN
        WRITE_LONG 0x1c gold
      END
    BUT_ONLY
  END
END
\end{verbatim}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec-macros-listing}\section{Macros Listing}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
These macros are automatically shipped with WeiDU.

\verb+tb#factorial+: computes the factorial of a number. \\
This is a PATCH macro.
\begin{itemize}
\item SET \verb+tb#factorial_index+ to the factorial you'd like to compute.
\item SET \verb+tb#factorial_result+ to 1;
\item The result is \verb+tb#factorial_result+.
\end{itemize}

\verb+tb#fix_file_size+: overwrites all files matching a certain regexp with a
certain standard file, if they are under a certain size. \\
This is an ACTION macro.
\begin{itemize}
\item SET \verb+tb#fix_file_size_min+ to the maximum allowed size
(files whose size is exactly this value are NOT overwritten).
\item SPRINT \verb+tb#fix_file_size_target+ to the standard file used to replace file(s) that match the regexp.
\item SPRINT \verb+tb#fix_file_size_category+ to a descriptive name.
\item SPRINT \verb+tb#fix_file_size_regexp+ to the regexp for the file(s) to be checked for a match.
\end{itemize}

\\

Note that, differently from the standalone versions, for these macros you \emph{need}
to set all the needed values - they aren't initialized automatically. This is untrue functions
(they are initialized to either 0 or the empty string, except for \verb+probability1+ which is initialized to 100).

\verb+DELETE_SPELL_EFFECT+: deletes all extended effects with specified opcode from a spell.
This is a PATCH macro and function.
\begin{itemize}
\item SET \verb+opcode_to_delete+ to the opcode of the effect you want to delete. Opcode of (-1) will match all effects.
\end{itemize}

\verb+DELETE_ITEM_EFFECT+: deletes all extended effects with specified opcode from an item.
This is a PATCH macro and function.
\begin{itemize}
\item SET \verb+opcode_to_delete+ to the opcode of the effect you want to delete. Opcode of (-1) will match all effects.
\end{itemize}

\verb+DELETE_ITEM_EQEFFECT+: deletes all equipping effects with specified opcode from an item.
This is a PATCH macro and function.
\begin{itemize}
\item SET \verb+opcode_to_delete+ to the opcode of the effect you want to delete. Opcode of (-1) will match all effects.
\end{itemize}

\verb+DELETE_CRE_EFFECT+: deletes all effects with specified opcode from a creature. (Warning: doesn't check EFF version)
This is a PATCH macro and function.
\begin{itemize}
\item SET \verb+opcode_to_delete+ to the opcode of the effect you want to delete. Opcode of (-1) will match all effects.
\end{itemize}

\verb+ITEM_EFFECT_TO_SPELL+: copies all extended effects from the current item to the first extended header of a spell.
This is a PATCH macro and function.
\begin{itemize}
\item SET \verb+type+ to the header type to copy the effect from (use 99 to specify 'all types').
\item SET \verb+header+ to number of extended header the effect should be copied from (use 99 to specify 'every header').
\item SET \verb+insert_point+ to the index into the spell file at which the effects should be inserted. A value of 0 will have the effects inserted as the first effects of the spell. Effects are inserted as the last effects by default.
\item SPRINT \verb+new_itm_spl+ to a spell you want to copy effects to.
\end{itemize}

\verb+ADD_SPELL_EFFECT+: adds an extended effect to a spell. All variables except \verb+probability1+ and \verb+insert_point+ are 0 by default.
This is a PATCH macro and function.
\begin{itemize}
\item SET \verb+opcode+ to opcode
\item SET \verb+target+ to target type
\item SET \verb+timing+ to timing type
\item SET \verb+parameter1+ to first parameter
\item SET \verb+parameter2+ to second parameter
\item SET \verb+power+ to power
\item SET \verb+resist_dispel+ to magic resistance/dispel type
\item SET \verb+duration+ to duration
\item SET \verb+probability1+ to probability 1 (default 100)
\item SET \verb+probability2+ to probability 2
\item SPRINT \verb+resource+ to resource (8 chars max)
\item SET \verb+dicenumber+ to number of dices to be thrown
\item SET \verb+dicesize+ to size of dices to be thrown
\item SET \verb+savingthrow+ to type of savingthrow to be allowed against the effect
\item SET \verb+savebonus+ to saving throw bonus
\item SET \verb+special+ to the special parameter (only valid for functions; not macros)
\item SET \verb+header+ to number of extended header (starting from 1) the effect should be added to (by default the effect is added to every header).
\item SET \verb+insert_point+ to the position of the effect. If this variable is 0 the effect will be inserted as the first effect of the extended header. If this variable is negative or greater than the number of effects, the effect will be inserted as the last effect. The effect is added as the last effect by default.
\end{itemize}

\verb+ADD_ITEM_EFFECT+: adds an extended effect to an item. All variables except \verb+probability1+, \verb+type+ and \verb+insert_point+ are 0 by default.
This is a PATCH macro and function.
\begin{itemize}
\item SET \verb+opcode+ to opcode
\item SET \verb+target+ to target type
\item SET \verb+timing+ to timing type
\item SET \verb+parameter1+ to first parameter
\item SET \verb+parameter2+ to second parameter
\item SET \verb+power+ to power
\item SET \verb+resist_dispel+ to magic resistance/dispel type
\item SET \verb+duration+ to duration
\item SET \verb+probability1+ to probability 1 (default 100)
\item SET \verb+probability2+ to probability 2
\item SPRINT \verb+resource+ to resource (8 chars max)
\item SET \verb+dicenumber+ to number of dices to be thrown
\item SET \verb+dicesize+ to size of dices to be thrown
\item SET \verb+savingthrow+ to type of savingthrow to be allowed against the effect
\item SET \verb+savebonus+ to saving throw bonus
\item SET \verb+special+ to the special parameter (only valid for functions; not macros)
\item SET \verb+header+ to number of extended header (starting from 1) the effect should be added to (by default the effect is added to every header).
\item SET \verb+type+ to the type of header to which the effect should be added or 99 for all types. Defaults to 3 (magic).
\item SET \verb+insert_point+ to the position of the effect. If this variable is 0 the effect will be inserted as the first effect of the extended header. If this variable is negative or greater than the number of effects, the effect will be inserted as the last effect. The effect is added as the last effect by default.
\end{itemize}

\verb+ADD_ITEM_EQEFFECT+: adds an equipping effect to an item. All variables except \verb+probability1+ are 0 by default.
This is a PATCH macro and function.
\begin{itemize}
\item SET \verb+opcode+ to opcode
\item SET \verb+target+ to target type
\item SET \verb+timing+ to timing type
\item SET \verb+parameter1+ to first parameter
\item SET \verb+parameter2+ to second parameter
\item SET \verb+power+ to power
\item SET \verb+resist_dispel+ to magic resistance/dispel type
\item SET \verb+duration+ to duration
\item SET \verb+probability1+ to probability 1 (default 100)
\item SET \verb+probability2+ to probability 2
\item SPRINT \verb+resource+ to resource (8 chars max)
\item SET \verb+dicenumber+ to number of dices to be thrown
\item SET \verb+dicesize+ to size of dices to be thrown
\item SET \verb+savingthrow+ to type of savingthrow to be allowed against the effect
\item SET \verb+savebonus+ to saving throw bonus
\item SET \verb+special+ to the special parameter (only valid for functions; not macros)
\item SET \verb+insert_point+ to the position of the effect. If this variable is 0 the effect will be inserted as the first effect of the extended header. If this variable is negative or greater than the number of effects, the effect will be inserted as the last effect. The effect is added as the first effect by default.
\end{itemize}

\verb+ADD_SPELL_CFEFFECT+: adds a casting-feature effect to a spell. All variables except \verb+probability1+ are 0 by default.
This is a PATCH macro and function.
\begin{itemize}
\item SET \verb+opcode+ to opcode
\item SET \verb+target+ to target type
\item SET \verb+timing+ to timing type
\item SET \verb+parameter1+ to first parameter
\item SET \verb+parameter2+ to second parameter
\item SET \verb+power+ to power
\item SET \verb+resist_dispel+ to magic resistance/dispel type
\item SET \verb+duration+ to duration
\item SET \verb+probability1+ to probability 1 (default 100)
\item SET \verb+probability2+ to probability 2
\item SPRINT \verb+resource+ to resource (8 chars max)
\item SET \verb+dicenumber+ to number of dices to be thrown
\item SET \verb+dicesize+ to size of dices to be thrown
\item SET \verb+savingthrow+ to type of savingthrow to be allowed against the effect
\item SET \verb+savebonus+ to saving throw bonus
\item SET \verb+special+ to the special parameter (only valid for functions; not macros)
\item SET \verb+insert_point+ to the position of the effect. If this variable is 0 the effect will be inserted as the first effect of the extended header. If this variable is negative or greater than the number of effects, the effect will be inserted as the last effect. The effect is added as the first effect by default.
\end{itemize}

\verb+ADD_CRE_EFFECT+: adds an effect to a creature. All variables except probability1 are 0 by default.
This is a PATCH macro and function.
\begin{itemize}
\item SET \verb+opcode+ to opcode
\item SET \verb+timing+ to timing type
\item SET \verb+target+ to target type
\item SET \verb+parameter1+ to first parameter
\item SET \verb+parameter2+ to second parameter
\item SET \verb+parameter3+ to third parameter
\item SET \verb+parameter4+ to forth parameter
\item SET \verb+power+ to power
\item SET \verb+resist_dispel+ to magic resistance/dispel type
\item SET \verb+duration+ to duration
\item SET \verb+probability1+ to probability 1 (default 100)
\item SET \verb+probability2+ to probability 2
\item SPRINT \verb+resource+ to resource (8 chars max)
\item SPRINT \verb+resource2+ to second resource (8 chars max)
\item SPRINT \verb+vvcresource+ to VVC resource (8 chars max)
\item SPRINT \verb+effsource+ to effect source
\item SPRINT \verb+effvar+ to effect variable
\item SET \verb+dicenumber+ to number of dices to be thrown
\item SET \verb+dicesize+ to size of dices to be thrown
\item SET \verb+savingthrow+ to type of savingthrow to be allowed against the effect
\item SET \verb+savebonus+ to saving throw bonus
\item SET \verb+school+ to magical school
\item SET \verb+special+ to the special parameter (only valid for functions; not macros)
\item SET \verb+lowestafflvl+ to lowest affected level
\item SET \verb+highestafflvl+ to highest affected level
\item SET \verb+casterx+ to caster X position
\item SET \verb+castery+ to caster Y position
\item SET \verb+targetx+ to target X position
\item SET \verb+targety+ to target Y position
\item SET \verb+restype+ to source resource type
\item SET \verb+sourceslot+ to source resource slot
\item SET \verb+casterlvl+ to caster level
\item SET \verb+sectype+ to secondary type
\item SET \verb+insert_point+ to the index at which the new effect
  is to be inserted. 0 is first and negative values or values
  equal to or exceeding the existing number of effects are last.
\end{itemize}

\verb+DELETE_CRE_ITEM+: deletes all matching items from a creature. Regexp allowed.
This is a PATCH macro and function.
\begin{itemize}
\item SPRINT \verb+item_to_delete+ to the item you want to delete.
\end{itemize}

\verb+DELETE_STORE_ITEM+: deletes all matching items from a store. Regexp allowed.
This is a PATCH macro and function.
\begin{itemize}
\item SPRINT \verb+item_to_delete+ to the item you want to delete.
\end{itemize}

\verb+DELETE_AREA_ITEM+: deletes all matching items from an area. Regexp allowed.
This is a PATCH macro and function.
\begin{itemize}
\item SPRINT \verb+item_to_delete+ to the item you want to delete.
\end{itemize}

\verb+REPLACE_STORE_ITEM+: replaces all matching items in a store with another item. Regexp allowed.
This is a PATCH macro and function.
\begin{itemize}
\item SPRINT \verb+old_item+ to the item you want to be replaced
\item SPRINT \verb+new_item+ to the new item
\item SET \verb+number_in_stock+ to number of new items in stock (default 0)
\item SPRINT \verb+flags+ to flags new item should have (usual weidu syntax: STOLEN, IDENTIFIED&STOLEN, etc). Default - no flags.
\item SET \verb+charges1+ to number of charges of first magical ability (default 0)
\item SET \verb+charges2+ to number of charges of second magical ability (default 0)
\item SET \verb+charges3+ to number of charges of third magical ability (default 0)
\end{itemize}

\verb+REPLACE_AREA_ITEM+: replaces all matching items in an area with another item. Regexp allowed.
This is a PATCH macro and function.
\begin{itemize}
\item SPRINT \verb+old_item+ to the item you want to be replaced
\item SPRINT \verb+new_item+ to the new item
\item SPRINT \verb+flags+ to flags the new item should have (usual weidu syntax: STOLEN, IDENTIFIED&STOLEN, etc). Default - no flags.
\item SET \verb+charges1+ to amount in stock/number of charges of first magical ability (default 0)
\item SET \verb+charges2+ to number of charges of second magical ability (default 0)
\item SET \verb+charges3+ to number of charges of third magical ability (default 0)
\end{itemize}

\verb+ADD_AREA_ITEM+: adds an item to a container of an area.
This is a PATCH macro and function.
\begin{itemize}
\item SPRINT \verb+item_to_add+ to the item you want to add
\item SET \verb+container_to_add_to+ to the number of the container the item should be added to. The count starts at 1.
\item SPRINT \verb+flags+ to flags the item should have (usual weidu syntax: STOLEN, IDENTIFIED&STOLEN, etc). Default - no flags.
\item SET \verb+charges1+ to amount in stock/number of charges of first magical ability (default 0)
\item SET \verb+charges2+ to number of charges of second magical ability (default 0)
\item SET \verb+charges3+ to number of charges of third magical ability (default 0)
\end{itemize}

\verb+ADD_CRE_ITEM_FLAGS+: adds flags to all matching items possessed by a creature. Regexp allowed.
This is a PATCH macro and function.
\begin{itemize}
\item SPRINT \verb+item_to_change+ to the item the flags should be added to
\item SPRINT \verb+flags+ to flags you need to add (usual weidu syntax: STOLEN, IDENTIFIED&STOLEN, etc).
\end{itemize}

\verb+REMOVE_CRE_ITEM_FLAGS+: removes flags from all matching items possessed by a creature. Regexp allowed.
This is a PATCH macro and function.
\begin{itemize}
\item SPRINT \verb+item_to_change+ to the item the flags should be removed from
\item SPRINT \verb+flags+ to flags you need to remove (usual weidu syntax: STOLEN, IDENTIFIED&STOLEN, etc).
\end{itemize}

\verb+SET_CRE_ITEM_FLAGS+: set flags to all matching items possessed by a creature. Regexp allowed.
This is a PATCH macro and function.
\begin{itemize}
\item SPRINT \verb+item_to_change+ to the item which flags should be set
\item SPRINT \verb+flags+ to flags you need to set (usual weidu syntax: STOLEN, IDENTIFIED&STOLEN, etc).
\end{itemize}

\verb+READ_SOUNDSET+: reads soundset of a creature and stores it as an array of string references %soundset%_%i% (i=0-99)
This is an ACTION macro.
\begin{itemize}
\item SPRINT \verb+npc+ to the target creature (with .cre extension)
\item SPRINT \verb+soundset+ to the name of soundset you want.
\end{itemize}

\verb+WRITE_SOUNDSET+: writes soundset to all matching creatures. Regexp allowed.
This is an ACTION macro.
\begin{itemize}
\item SPRINT \verb+npc+ to a creature in question (with .cre extension)
\item SPRINT \verb+soundset+ to name of soundset you have.
\item SET \verb+overwrite+ to 2 if you want new soundset to overwrite the old one completely. Set it to 1 if you want to overwrite old string references only with non-empty new references (may keep some old). Set it to 0 it you want to overwrite only empty old references with new ones.
\end{itemize}

\verb+FJ_CRE_VALIDITY+: Checks whether a CRE file is well-formed or not, fixes some common bugs, and reports whether the CRE file is still broken or not. In particular:
\begin{itemize}
\item reports invalidity if it is charbase.cre, shorter than the minimum size, the signature mismatches, or a sub-structure has members and its offset is in the header.
\item if a empty sub-structure's offset is in the header, point them to the end of the header.
\item if the cre is valid, force it to use proper order (known spells, spell memorization info, memorized spells, effects, items, item slot).
\item forces the CRE file to use EFF V2 effects internally (or EFF V1 if on BG1).
\end{itemize}
This is a PATCH function.
\begin{itemize}
\item INT_VAR \verb+do_message+ to 1 if you want explicit an explicit message regarding the cre invalidity. Defaults to 0.
\item INT_VAR \verb+do_reindex+ to 0 if you don't want the creature file to be reindexed. Defaults to 1.
\item INT_VAR \verb+do_eff+ to 0 if you don't want EFFv1 <-> EFFv2 conversion to be applied. Defaults to 1.
\item RET \verb+valid+ returns 1 if the CRE is well-formed, 0 otherwise.
\end{itemize}

\verb+FJ_CRE_REINDEX+: reorders creatures with nonstandard offset orders. Called by FJ_CRE_VALIDITY automatically if relevant.\\\\
This is a PATCH function.
\begin{itemize}
\item INT_VAR \verb+do_reindex+ to 0 if you don't want the creature file to be reindexed. Defaults to 1.
\item INT_VAR \verb+do_eff+ to 0 if you don't want EFFv1 <-> EFFv2 conversion to be applied. Defaults to 1.
\end{itemize}

\verb+FJ_CRE_EFF_V2+: Converts creatures using version 1 effects to version 2. Called by FJ_CRE_VALIDITY or FJ_CRE_REINDEX automatically if relevant.\\
This is a PATCH function.

\verb+T-CRE_EFF_V1+: Converts creatures using version 2 effects to version 1. Called by FJ_CRE_VALIDITY or FJ_CRE_REINDEX automatically if relevant.\\
This is a PATCH function.

\verb+ADD_AREA_REGION_TRIGGER+: adds an area region to the current are file.
This is a PATCH macro and function. Unlike other macros you do not need to set every variable. You are only required to set those values that you need to write.
\begin{itemize}
\item SPRINT \verb+ab_RT_Name+ -- Name to assign to new region
\item SET \verb+ab_RT_Type+ -- Type of trigger -- 0=proximity;1=info;2=travel
\item SET \verb+ab_RT_BbLX+ -- Bounding Box - low x value  - LEFT
\item SET \verb+ab_RT_BbLY+ -- Bounding Box - low y value  - TOP
\item SET \verb+ab_RT_BbHX+ -- Bounding Box - High x value - RIGHT
\item SET \verb+ab_RT_BbHY+ -- Bounding Box - High y value - BOTTOM
\item SET \verb+ab_RT_VxPr+ -- Number of Vertex Pairs for current region
\item SET \verb+ab_RT_CuId+ -- Cursor Index - points to a graphic in cursors.bam
\item SPRINT \verb+ab_RT_Dest+ -- Destination Area
\item SPRINT \verb+ab_RT_EntN+ -- Entrance Name
\item SET \verb+ab_RT_Fbit+ -- Flag bits set in bit format which are read right to left - 0=off; 1=on
\item SET \verb+ab_RT_Itxt+ -- Info text
\item SET \verb+ab_RT_TDtD+ -- Trap Detection Difficulty
\item SET \verb+ab_RT_TRmD+ -- Trap Removal Difficulty
\item SET \verb+ab_RT_TSet+ -- Trap is set - 0=no; 1=yes
\item SET \verb+ab_RT_TDet+ -- Trap is detected - 0=no; 1=yes
\item SET \verb+ab_RT_LPoX+ -- Launch Point X
\item SET \verb+ab_RT_LPoY+ -- Launch Point Y
\item SPRINT \verb+ab_RT_KeyI+ -- Key Item
\item SET \verb+ab_RT_Rbcs+ -- Region Script file
\item SET \verb+ab_RT_ALPX+ -- Alternate Launch Point X
\item SET \verb+ab_RT_ALPY+ -- Alternate Launch Point Y
\item SET \verb+ab_RT_Dial+ -- Dialog file (used only in PST)
\end{itemize}

\\
The vertex points are separated by their X & Y values
You may have as many pairs as you need. Just copy this set and increment the #.
Example: For the X values: \verb+ab_RT_Vx_X_0+, \verb+ab_RT_Vx_X_1+, \verb+ab_RT_Vx_X_2+\\
         For the Y values: \verb+ab_RT_Vx_Y_0+, \verb+ab_RT_Vx_Y_1+, \verb+ab_RT_Vx_Y_2+
\begin{itemize}
\item SET \verb+ab_RT_Vx_X_0+ -- Point #0 X value
\item SET \verb+ab_RT_Vx_Y_0+ -- Point #0 Y value
\end{itemize}

\\
NOTE: The original code released in WeiDU v211 has been overhauled and re-released in v212. Therefore, the user defined variable names have been changed. If you used the 211 version you will need to update your mod to use the variables in this version. Sorry for the inconvenience...


\\
\verb+RES_NUM_OF_SPELL_NAME+: converts a spell.ids reference to resource name.
This is an ACTION and PATCH macro and function.
\begin{itemize}
\item SPRINT \verb+spell_name+ to the IDS symbolic reference of a spell.
\item RET \verb+spell_num+ to the IDS numerical reference of that spell.
\item RET \verb+spell_res to+ the resource name for the referenced spell.
\end{itemize}
\\

\verb+RES_NAME_OF_SPELL_NUM+: converts a spell.ids reference to resource name.
This is an ACTION and PATCH macro and function.
\begin{itemize}
\item SET \verb+spell_num+ to the IDS numerical reference of that spell.
\item RET \verb+spell_name+ to the IDS symbolic reference of a spell.
\item RET \verb+spell_res+ to the resource name for the referenced spell.
\end{itemize}
\\

\verb+NAME_NUM_OF_SPELL_RES+: converts a spell resource name to a spell.ids reference.
This is an ACTION and PATCH macro and function.
\begin{itemize}
\item SPRINT \verb+spell_res+ to the resource name for the referenced spell.
\item RET \verb+spell_num+ to the IDS numerical reference of that spell.
\item RET \verb+spell_name+ to the IDS symbolic reference of a spell.
\end{itemize}
\\

\verb+GET_UNIQUE_FILE_NAME+: Creates a file name that is currently unallocated.
This is a PATCH and ACTION function.
This function will create a filename using __ as a prefix. __ is reserved by
The Bigg and writeable by anybody, as long as you dynamically create the file
name (either by using this function or other code of your devising). The algorithm
creates file names in base 36, going from __0000.ext to __zzzz.ext; this allows for
36 ^ 4 = 1679616 unique file names.



To allow users to reinstall your mod without breaking the identity of these files, you
can use the 'base' parameter to ensure that the same thing will be mapped to the same
file on reinstalls. For instance, if you're iterating through Mages to give each of
them a spellbook, base should contain your modder prefix, an identifier for the purpose
of the call, and the file name you're working on, for instance:
\verb+~tb#spellbooks_%SOURCE_RES%~+
\begin{itemize}
\item STR_VAR \verb+extension+ to the desired extension (required).
\item STR_VAR \verb+base+ to a string unique to your mod and current file (optional).
\item RET \verb+filename+ the currently unallocated file name (sans the extension).
\end{itemize}
\\

\verb+ALTER_AREA_ENTRANCE+: patch coordinates and orientation of \ahref{\url{http://gibberlings3.net/iesdp/file_formats/ie_formats/are_v1.htm#formAREAV1_0_Entrance}}{area party entrance points}.
This is a PATCH function. For all integer variables, a negative value results in no change to that field and the default value is -1. The variable \verb+entrance_name+ is required.
\begin{itemize}
\item INT_VAR \verb+x_coord+ to the new X coordinate.
\item INT_VAR \verb+y_coord+ to the new Y coordinate.
\item INT_VAR \verb+orient+ to the new orientation.
\item STR_VAR \verb+entrance_name+ to the name of the entrance point to be altered. This variable is required.
\end{itemize}
\\

\verb+ALTER_AREA_REGION+: patch \ahref{\url{http://gibberlings3.net/iesdp/file_formats/ie_formats/are_v1.htm#formAREAV1_0_Info}}{area regions}, also known as area triggers.
This is a PATCH function. For all integer variables except \verb+info_point+, a negative value results in no change and the default value is -1. The variable \verb+info_point+ results in no change if it has the default value 99999999. In the case of flags, a value of 1 will set the flag and a value of 0 will unset it. For all string variables except \verb+region_name+, the default value is the string "same", which results in no change to that field. The variable \verb+region_name+ is required.
\begin{itemize}
\item INT_VAR \verb+type+ to the new type of the region.
\item INT_VAR \verb+cursor+ to the new cursor index to be used.
\item INT_VAR \verb+trap_detect+ to the new difficulty of trap detection.
\item INT_VAR \verb+trap_remove+ to the new difficulty of trap removal.
\item INT_VAR \verb+trapped+ to whether the region should be trapped.
\item INT_VAR \verb+detected+ to whether the trap should be detected.
\item INT_VAR \verb+flag_locked+ to the new value of the flag known as \t{locked} or \t{invisible trap} (bit 0).
\item INT_VAR \verb+flag_resets+ to the new value of the flag known as \t{trap resets} (bit 1).
\item INT_VAR \verb+flag_party_required+ to the new value of the flag known as \t{party is required} (bit 2).
\item INT_VAR \verb+flag_trap_detectable+ to the new value of the flag known as \t{trap is detectable} (bit 3).
\item INT_VAR \verb+flag_trap_enemies+ to the new value of the flag known as \t{trap can be set off by enemies} (bit 4).
\item INT_VAR \verb+flag_tutorial+ to the new value of the flag known as \t{tutorial trigger} (bit 5).
\item INT_VAR \verb+flag_trap_npcs+ to the new value of the flag known as \t{trap can be set off by NPCs} (bit 6).
\item INT_VAR \verb+flag_silent+ to the new value of the flag known as \t{silent trigger} (bit 7).
\item INT_VAR \verb+flag_deactivated+ to the new value of the flag known as \t{deactivated} (bit 8).
\item INT_VAR \verb+flag_impassable_npc+ to the new value of the flag known as \t{cannot be passed by NPCs} (bit 9).
\item INT_VAR \verb+flag_activation_point+ to the new value of the flag known as \t{use activation point} (bit 10).
\item INT_VAR \verb+flag_connect_to_door+ to the new value of the flag known as \t{connected to door} (bit 11).
\item INT_VAR \verb+bounding_left+ to the new value of the left edge of the bounding box. The vertices remain unchanged.
\item INT_VAR \verb+bounding_top+ to the new value of the top edge of the bounding box. The vertices remain unchanged.
\item INT_VAR \verb+bounding_right+ to the new value of the right edge of the bounding box. The vertices remain unchanged.
\item INT_VAR \verb+bounding_bottom+ to the new value of the bottom edge of the bounding box. The vertices remain unchanged.
\item INT_VAR \verb+info_point+ to the new string reference of the info point.
\item INT_VAR \verb+launch_x+ to the new x coordinate of the launch point.
\item INT_VAR \verb+launch_y+ to the new y coordinate of the launch point.
\item INT_VAR \verb+activate_x+ to the new x coordinate of the activation point.
\item INT_VAR \verb+activate_y+ to the new y coordinate of the activation point.
\item STR_VAR \verb+region_name+ to the name of the region to be patched. This variable is required.
\item STR_VAR \verb+destination_area+ to the resref of the new destination area.
\item STR_VAR \verb+entrance_name+ to the new entrance name of the destination area.
\item STR_VAR \verb+region_key+ to the resref of the key item.
\item STR_VAR \verb+region_script+ to the resref of the region script.
\end{itemize}
\\

\verb+ALTER_AREA_ACTOR+: patch \ahref{\url{http://gibberlings3.net/iesdp/file_formats/ie_formats/are_v1.htm#formAREAV1_0_Actor}}{area actors}.
This is a PATCH function. All integer variables, except \verb+expiry+, default to the value -1 and a negative value results in no change to the corresponding field. The variable \verb+expiry+ instead has a default value of -2. In the case of flags, a value of 1 will set the flag and a value of 0 will unset it. All string variables except \verb+actor_name+ default to the string "same", which results in no change to the corresponding field. The variable \verb+actor_name+ is required.
\begin{itemize}
\item INT_VAR \verb+x_coord+ to the new x coordinate. Unless \verb+dest_x+ is defined, \verb+x_coord+ is used as the x-value of the destination, as well.
\item INT_VAR \verb+y_coord+ to the new y coordinate. Unless \verb+dest_y+ is defined, \verb+y_coord+ is used as the y-value of the destination, as well.
\item INT_VAR \verb+dest_x+ to the new x destination.
\item INT_VAR \verb+dest_y+ to the new y destination.
\item INT_VAR \verb+spawned+ to the new spawned value.
\item INT_VAR \verb+animation+ to the new animation value.
\item INT_VAR \verb+orient+ to the new facing direction.
\item INT_VAR \verb+expiry+ to the new expiration time.
\item INT_VAR \verb+wander+ to the new wander-distance value.
\item INT_VAR \verb+follow+ to the new follow-distance value.
\item INT_VAR \verb+times_talked+ to the new number of times the actor has been talked to.
\item INT_VAR \verb+flag_cre_unattached+ to the new value of the flag known as \t{CRE attached} (bit 0).
\item INT_VAR \verb+flag_seen_party+ to the new value of the flag known as \t{has seen party} (bit 1).
\item INT_VAR \verb+flag_invulnerable+ to the new value of the flag known as \t{invulnerable} (bit 2).
\item INT_VAR \verb+flag_override_script_name+ to the new value of the flag known as {override script name} (bit 3).
\item INT_VAR \verb+flag_time_0+ through \verb+flag_time_23+ to the new values of the actor's appearance schedule.
\item STR_VAR \verb+actor_name+ to the name of the actor to be patched. This variable is required.
\item STR_VAR \verb+dlg_file+ to the resref of the new dialogue file.
\item STR_VAR \verb+script_override+ to the resref of the new override script.
\item STR_VAR \verb+script_general+ to the resref of the new general script.
\item STR_VAR \verb+script_class+ to the resref of the new class script.
\item STR_VAR \verb+script_race+ to the resref of the new race script.
\item STR_VAR \verb+script_default+ to the resref of the new default script.
\item STR_VAR \verb+script_specifics+ to the resref of the new specifics script.
\item STR_VAR \verb+cre_file+ to the resref of the new creature file.
\end{itemize}
\\

\verb+ALTER_AREA_CONTAINER+: patch \ahref{\url{http://gibberlings3.net/iesdp/file_formats/ie_formats/are_v1.htm#formAREAV1_0_Container}}{area containers}, but not their contents. This is a PATCH function. All integer variables default to -1 and negative values result in no change to the corresponding field. In the case of flags, a value of 1 will set the flag and a value of 0 will unset it. All string variables except \verb+container_name+ default to the string "same", which results in no change to the corresponding field. The variable \verb+container_name+ is required.
\begin{itemize}
\item INT_VAR \verb+coord_x+ to the new x coordinate.
\item INT_VAR \verb+coord_y+ to the new y coordinate.
\item INT_VAR \verb+container_type+ to the new type of the container.
\item INT_VAR \verb+trapped+ to whether the container should be trapped.
\item INT_VAR \verb+detected+ to whether the container trap should be detected.
\item INT_VAR \verb+launch_x+ to the new x coordinate of the launch point.
\item INT_VAR \verb+launch_y+ to the new y coordinate of the launch point.
\item INT_VAR \verb+bounding_left+ to the new value of the left edge of the bounding box. The vertices remain unchanged.
\item INT_VAR \verb+bounding_top+ to the new value of the top edge of the bounding box. The vertices remain unchanged.
\item INT_VAR \verb+bounding_right+ to the new value of the right edge of the bounding box. The vertices remain unchanged.
\item INT_VAR \verb+bounding_bottom+ to the new value of the bottom edge of the bounding box. The vertices remain unchanged.
\item INT_VAR \verb+range+ to the new trigger-range value.
\item INT_VAR \verb+lockpick_strref+ to the new strref of the lockpick string.
\item INT_VAR \verb+lock_difficulty+ to the new difficulty of the lock.
\item INT_VAR \verb+trap_detect+ to the new difficulty of trap detection.
\item INT_VAR \verb+trap_remove+ to the new difficulty of trap removal.
\item INT_VAR \verb+flag_locked+ to the new value of the flag known as \t{locked} (bit 0).
\item INT_VAR \verb+flag_mlocked+ to the new value of the flag known as \t{magical lock} (bit 2).
\item INT_VAR \verb+flag_resets+ to the new value of the flag known as \t{trap resets} (bit 3).
\item INT_VAR \verb+flag_disabled+ to the new value of the flag known as \t{disabled} (bit 5).
\item STR_VAR \verb+container_name+ to the name of the container to be patched. This variable is required.
\item STR_VAR \verb+container_script+ to the resref of the new container script.
\item STR_VAR \verb+container_key+ to the resref of the new container key.
\end{itemize}
\\

\verb+ALTER_AREA_DOOR+: patch \ahref{\url{http://gibberlings3.net/iesdp/file_formats/ie_formats/are_v1.htm#formAREAV1_0_Door}}{area doors.} This is a PATCH function. All integer variables, except \verb+string_unlock+ and \verb+string_speaker+, default to -1 and negative values result in no change to the corresponding field. The variables \verb+string_unlock+ and \verb+string_speaker+ instead default to 99999999. In the case of flags, a value of 1 will set the flag and a value of 0 will unset it. All string variables except \verb+door_name+ default to the string "same", which results in no change to the corresponding field. The variable \verb+door_name+ is required.
\begin{itemize}
\item INT_VAR \verb+bounding_open_left+ to the new value of the left edge of the open-state bounding box. The vertices remain unchanged.
\item INT_VAR \verb+bounding_open_top+ to the new value of the top edge of the open-state bounding box. The vertices remain unchanged.
\item INT_VAR \verb+bounding_open_right+ to the new value of the right edge of the open-state bounding box. The vertices remain unchanged.
\item INT_VAR \verb+bounding_open_bottom+ to the new value of the bottom edge of the open-state bounding box. The vertices remain unchanged.
\item INT_VAR \verb+bounding_closed_left+ to the new value of the left edge of the closed-state bounding box. The vertices remain unchanged.
\item INT_VAR \verb+bounding_closed_top+ to the new value of the top edge of the closed-state bounding box. The vertices remain unchanged.
\item INT_VAR \verb+bounding_closed_right+ to the new value of the right edge of the closed-state bounding box. The vertices remain unchanged.
\item INT_VAR \verb+bounding_closed_bottom+ to the new value of the bottom edge of the closed-state bounding box. The vertices remain unchanged.
\item INT_VAR \verb+door_hp+ to the new hit-point value.
\item INT_VAR \verb+door_ac+ to the new armor-class value.
\item INT_VAR \verb+cursor+ to the new cursor index.
\item INT_VAR \verb+trap_detect+ to the new difficulty of trap detection.
\item INT_VAR \verb+trap_remove+ to the new difficulty of trap removal.
\item INT_VAR \verb+trapped+ to whether the door should be trapped.
\item INT_VAR \verb+detected+ to whether the door trap should be detected.
\item INT_VAR \verb+launch_x+ to the new x coordinate of the launch point.
\item INT_VAR \verb+launch_y+ to the new y coordinate of the launch point.
\item INT_VAR \verb+door_detect+ to the new difficulty of door detection.
\item INT_VAR \verb+lock_difficulty+ to the new difficulty of the lock.
\item INT_VAR \verb+open_x+ to the new x coordinate of the opening point.
\item INT_VAR \verb+open_y+ to the new y coordinate of the opening point.
\item INT_VAR \verb+close_x+ to the new x coordinate of the closing point.
\item INT_VAR \verb+close_y+ to the new y coordinate of the closing point.
\item INT_VAR \verb+string_unlock+ to the new string reference of the unlock message.
\item INT_VAR \verb+string_speaker+ to the new string reference of the dialogue-speaker name.
\item INT_VAR \verb+flag_open+ to the new value of the flag known as \t{door open} (bit 0).
\item INT_VAR \verb+flag_locked+ to the new value of the flag known as \t{door locked} (bit 1).
\item INT_VAR \verb+flag_resets+ to the new value of the flag known as \t{reset trap} (bit 2).
\item INT_VAR \verb+flag_detectable+ to the new value of the flag known as \t{trap detectable} (bit 3).
\item INT_VAR \verb+flag_forced+ to the new value of the flag known as \t{broken} (bit 4).
\item INT_VAR \verb+flag_no_close+ to the new value of the flag known as \t{can't close} (bit 5).
\item INT_VAR \verb+flag_located+ to the new value of the flag known as \t{linked} (bit 6).
\item INT_VAR \verb+flag_secret+ to the new value of the flag known as \t{door hidden} (bit 7).
\item INT_VAR \verb+flag_detected+ to the new value of the flag known as \t{door found} (bit 8).
\item INT_VAR \verb+flag_no_look+ to the new value of the flag known as \t{don't block line of sight} (bit 9).
\item INT_VAR \verb+flag_uses_key+ to the new value of the flag known as \t{remove key} (bit 10).
\item INT_VAR \verb+flag_sliding+ to the new value of the flag known as \t{ignore obstacles when closing} (bit 11).
\item STR_VAR \verb+door_name+ to the name of the door to be patched. This variable is required.
\item STR_VAR \verb+door_open_sound+ to the resource reference of the opening sound.
\item STR_VAR \verb+door_close_sound+ to the resource reference of the closing sound.
\item STR_VAR \verb+door_key+ to the resref of the new door key.
\item STR_VAR \verb+door_script+ to the resref of the new door script.
\item STR_VAR \verb+travel_trigger+ to the new travel-trigger name. This field is 24 bytes in length.
\item STR_VAR \verb+dialogue+ to the new resource reference of the dialogue file.
\end{itemize}
\\

\verb+ALTER_ITEM_EFFECT+: patch \ahref{\url{http://gibberlings3.net/iesdp/file_formats/ie_formats/itm_v1.htm#itmv1_Feature_Block}}{global (equipping) effects} and/or \ahref{\url{http://gibberlings3.net/iesdp/file_formats/ie_formats/itm_v1.htm#itmv1_Extended_Header}}{effects on extended headers}. This is a PATCH function. All integer variables except \verb+check_globals+, \verb+check_headers+, \verb+header+ and \verb+savebonus+ default to -1 and negative values result in no change to the corresponding field. The integer variables \verb+check_globals+, \verb+check_headers+ and \verb+header+ default to 0. The integer variable \verb+savebonus+ defaults to -11 and values lower than -10 result in no change to the corresponding field. The string variable \verb+resource+ defaults to the string "same", which results in no change to the corresponding field.

Note that both \verb+check_globals+ and \verb+check_headers+ are 0 by default, so you need to change one or both of these to 1 to perform any patching at all. If you patch headers, you can further target by using type to target melee, ranged, or magical headers. \verb+match_opcode+ can be left at -1 to match all effects on your targeted range or targeted to a specific opcode. If the opcode itself needs to be changed, you can use \verb+match_opcode+ to target the existing effect and \verb+new_opcode+ as the new opcode to use. \verb+duration_high+ is an alternative to \verb+duration+, mainly for changing the overall duration of an item's effects. The idea is to allow you to mass patch effects to new durations while leaving the one-time only cosmetics and visuals--which are usual instant or only run for a few seconds--unchanged.
\begin{itemize}
\item INT_VAR \verb+check_globals+ to whether to check global (on-equip) effects (0 for no, 1 for yes). (default 0)
\item INT_VAR \verb+check_headers+ to whether to check effects on extended headers (0 for no, 1 for yes). (default 0)
\item INT_VAR \verb+header+ to the number of the ability header that should be altered. A value of 0 matches all headers. (default 0)
\item INT_VAR \verb+header_type+ to which type of header that should be checked. If this variable is -1, all header types will be checked.
\item INT_VAR \verb+match_opcode+ to which type of opcode to match. If this variable is -1, all opcodes are a match.
\item INT_VAR \verb+new_opcode+ to the value the matched opcode should be changed into.
\item INT_VAR \verb+target+ to the new target.
\item INT_VAR \verb+power+ to the new power.
\item INT_VAR \verb+parameter1+ to the new parameter1.
\item INT_VAR \verb+parameter2+ to the new parameter2.
\item INT_VAR \verb+timing+ to the new timing mode.
\item INT_VAR \verb+resist_dispel+ to the new resist/dispel.
\item INT_VAR \verb+duration+ to the new duration.
\item INT_VAR \verb+duration_high+ to the new duration, but is only written if the existing duration is greater than 5.
\item INT_VAR \verb+probability1+ to the new probability1 (the upper bound).
\item INT_VAR \verb+probability2+ to the new probability2 (the lower bound).
\item INT_VAR \verb+dicenumber+ to the new number of dice. This field is instead used for maximum hit-dice (HD) by some opcodes.
\item INT_VAR \verb+dicesize+ to the new size of dice. This field is also instead for minimum hit-dice (HD) by some opcodes.
\item INT_VAR \verb+savingthrow+ to the new saving-throw type.
\item INT_VAR \verb+savebonus+ to the new saving-throw bonus/penalty. This variable can take negative values down to -10 while still writing to the corresponding field. (default -11)
\item INT_VAR \verb+special+ to the new special parameter.
\item STR_VAR \verb+resource+ to the new resource reference.
\end{itemize}
\\

\verb+ALTER_ITEM_HEADER+: patch \ahref{\url{http://gibberlings3.net/iesdp/file_formats/ie_formats/itm_v1.htm#itmv1_Extended_Header}}{ability headers} on items. This is a PATCH function. All integer variables except \verb+match_icon+ and \verb+header+ default to -1 and negative values result in no change to the corresponding field. The integer variables \verb+match_icon+ and \verb+header+ default to 0. In the case of flags, a value of 1 will set the flag and a value of 0 will unset it. The string variable \verb+icon+ defaults to the string "same", which results in no change to the corresponding field.

\verb+header_type+ is used to limit the scope of matching. The default value of -1 will match all types of headers while values of 0-4 will match headers with those values. If \verb+match_icon+ is 1, the icon resource reference will be match with the \verb+icon+ variable as an additional qualifier. This is useful for items which have multiple magic abilities. \verb+header+ can also be used to limit patching to the Nth header, counting from 1 as the first header. The default is 0, which will match all headers.

\begin{itemize}
\item INT_VAR \verb+header_type+ to the type of header to be matched. If this variable is -1, all headers will be a match. (default -1)
\item INT_VAR \verb+match_icon+ to whether to match the ability icon (0 for no, 1 for yes). (default 0)
\item INT_VAR \verb+header+ to the number of the ability header (starting from 1) that should be altered. A value of 0 matches all header. (default 0)
\item INT_VAR \verb+new_header_type+ to the value the matched header should be changed into.
\item INT_VAR \verb+identify+ to the new identification requirement.
\item INT_VAR \verb+location+ to the new new ability location.
\item INT_VAR \verb+target+ to the new target.
\item INT_VAR \verb+target_count+ to the new target count.
\item INT_VAR \verb+range+ to the new range.
\item INT_VAR \verb+launcher+ to the new required launcher.
\item INT_VAR \verb+speed+ to the new speed factor.
\item INT_VAR \verb+thac0_bonus+ to the new THAC0 bonus.
\item INT_VAR \verb+dicesize+ to the new dice size.
\item INT_VAR \verb+primary_type+ to the new primary type (school).
\item INT_VAR \verb+dicenumber+ to the new number of dice.
\item INT_VAR \verb+secondary_type+ to the new secondary type.
\item INT_VAR \verb+damage_bonus+ to the new damage bonus.
\item INT_VAR \verb+damage_type+ to the new damage type.
\item INT_VAR \verb+charges+ to the new number of charges.
\item INT_VAR \verb+drained+ to the new charge-depletion behaviour.
\item INT_VAR \verb+projectile+ to the new projectile.
\item INT_VAR \verb+animation_overhand+ to the new overhand animation percentage.
\item INT_VAR \verb+animation_backhand+ to the new backhand animation percentage.
\item INT_VAR \verb+animation_thrust+ to the new thrust animation percentage.
\item INT_VAR \verb+arrow+ to the new arrow qualifier.
\item INT_VAR \verb+bolt+ to the new bolt qualifier.
\item INT_VAR \verb+bullet+ to the new bullet qualifier.
\item INT_VAR \verb+flag_strength+ to the new value of the flag known as \t{add strength bonus} (bit 0).
\item INT_VAR \verb+flag_break+ to the new value of the flag known as \t{breakable} (bit 1).
\item INT_VAR \verb+flag_strength_damage+ to the new value of the flag known as \t{add strength bonus to damage only} (bit 2). This flag is not available in all games.
\item INT_VAR \verb+flag_strength_thac0+ to the new value of the flag known as \t{add strength bonus to THAC0 only} (bit 3). This flag is not available in all games.
\item INT_VAR \verb+flag_hostile+ to the new value of the flag known as \t{hostile} (bit 10).
\item INT_VAR \verb+flag_recharge+ to the new value of the flag known as \t{recharges} (bit 11).
\item INT_VAR \verb+flag_bypass+ to the new value of the flag known as \t{bypass armor} (bit 16). This flag is not available in all games.
\item INT_VAR \verb+flag_keenedge+ to the new value of the flag known as \t{keen edge} (bit 17). This flag is not available in all games.
\item INT_VAR \verb+flag_backstab+ to the new value of the flag known as \t{toggle backstab} (bit 25). This flag is not available in all games.
\item INT_VAR \verb+flag_noinvisible+ to the new value of the flag known as \t{cannot target invisible} (bit 26). This flag is not available in all games.
\item STR_VAR \verb+icon+ to the resource reference to be used for matching if \verb+match_icon+ is 1, or the new ability icon if \verb+match_icon+ is 0.
\end{itemize}
\\

\verb+DELETE_ITEM_HEADER+: delete ability headers, also known as \ahref{\url{http://gibberlings3.net/iesdp/file_formats/ie_formats/itm_v1.htm#itmv1_Extended_Header}}{extended headers}, from items. This is a PATCH function. All integer variables default to 0.

This function will delete one or more ability headers, along with all of their associated effects, and properly re-index the file.

\begin{itemize}
\item INT_VAR \verb+header_type+ to the header type to delete. If this variable is -1, all header types will be a match. (default 0)
\end{itemize}
\\

\verb+ALTER_SPELL_EFFECT+: patch \ahref{\url{http://gibberlings3.net/iesdp/file_formats/ie_formats/spl_v1.htm#splv1_Feature_Block}}{effects} on spells. This is a PATCH function. All integer variables except \verb+check_globals+, \verb+check_headers+, \verb+header+ and \verb+savebonus+ default to -1 and negative values result in no change to the corresponding field. The integer variables \verb+check_globals+ and \verb+header+ default to 0. The integer variable \verb+check_headers+ defaults to 1. The integer variable \verb+savebonus+ defaults to -11 and values lower than -10 result in no change to the corresponding field. The string variable \verb+resource+ defaults to the string "same", which results in no change to the corresponding field.

The function will by default only check effects on headers. You can change this by changing the values of the variables \verb+check_globals+ and \verb+check_headers+. If you patch headers, you can further target by using type to target melee, ranged, or magical headers. \verb+match_opcode+ can be left at -1 to match all effects on your targeted range or targeted to a specific opcode. If the opcode itself needs to be changed, you can use \verb+match_opcode+ to target the existing effect and \verb+new_opcode+ as the new opcode to use. \verb+duration_high+ is an alternative to \verb+duration+, mainly for changing the overall duration of an item's effects. The idea is to allow you to mass patch effects to new durations while leaving the one-time only cosmetics and visuals--which are usual instant or only run for a few seconds--unchanged.
\begin{itemize}
\item INT_VAR \verb+check_globals+ to whether to check global effects (0 for no, 1 for yes). (default 0)
\item INT_VAR \verb+check_headers+ to whether to check effects on extended headers (0 for no, 1 for yes). (default 1)
\item INT_VAR \verb+header+ to the number of the ability header that should be altered. A value of 0 matches all headers. (default 0)
\item INT_VAR \verb+header_type+ to which type of header that should be checked. If this variable is -1, all header types will be checked.
\item INT_VAR \verb+match_opcode+ to which type of opcode to match. If this variable is -1, all opcodes are a match.
\item INT_VAR \verb+new_opcode+ to the value the matched opcode should be changed into.
\item INT_VAR \verb+target+ to the new target.
\item INT_VAR \verb+power+ to the new power.
\item INT_VAR \verb+parameter1+ to the new parameter1.
\item INT_VAR \verb+parameter2+ to the new parameter2.
\item INT_VAR \verb+timing+ to the new timing mode.
\item INT_VAR \verb+resist_dispel+ to the new resist/dispel.
\item INT_VAR \verb+duration+ to the new duration.
\item INT_VAR \verb+duration_high+ to the new duration, but is only written if the existing duration is greater than 5.
\item INT_VAR \verb+probability1+ to the new probability1 (the upper bound).
\item INT_VAR \verb+probability2+ to the new probability2 (the lower bound).
\item INT_VAR \verb+dicenumber+ to the new number of dice. This field is instead used for maximum hit-dice (HD) by some opcodes.
\item INT_VAR \verb+dicesize+ to the new size of dice. This field is also instead for minimum hit-dice (HD) by some opcodes.
\item INT_VAR \verb+savingthrow+ to the new saving-throw type.
\item INT_VAR \verb+savebonus+ to the new saving-throw bonus/penalty. This variable can take negative values down to -10 while still writing to the corresponding field. (default -11)
\item INT_VAR \verb+special+ to the new special parameter.
\item STR_VAR \verb+resource+ to the new resource reference.
\end{itemize}
\\

\verb+ALTER_SPELL_HEADER+: patch \ahref{\url{http://gibberlings3.net/iesdp/file_formats/ie_formats/spl_v1.htm#splv1_Extended_Header}}{ability headers} on spells. This is a PATCH function.All integer variables except \verb+match_icon+ and \verb+header+ default to -1 and negative values result in no change to the corresponding field. The integer variables \verb+match_icon+ and \verb+header+ default to 0. The string variable \verb+icon+ defaults to the string "same", which results in no change to the corresponding field.

\verb+header_type+ is used to limit the scope of matching. The default value of -1 will match all types of headers while values of 0-4 will match headers with those values. If \verb+match_icon+ is 1, the icon resource reference will be match with the \verb+icon+ variable as an additional qualifier. This is useful for items which have multiple magic abilities. \verb+header+ can also be used to limit patching to the Nth header, counting from 1 as the first header. The default is 0, which will match all headers.

\begin{itemize}
\item INT_VAR \verb+header_type+ to the type of header to be matched. If this variable is -1, all headers will be a match. (default -1)
\item INT_VAR \verb+match_icon+ to whether to match the ability icon (0 for no, 1 for yes). (default 0)
\item INT_VAR \verb+header+ to the number of the ability header (starting from 1) that should be altered. A value of 0 matches all header. (default 0)
\item INT_VAR \verb+new_header_type+ to the value the matched header should be changed into.
\item INT_VAR \verb+location+ to the new new ability location.
\item INT_VAR \verb+target+ to the new target.
\item INT_VAR \verb+target_count+ to the new target count.
\item INT_VAR \verb+range+ to the new range.
\item INT_VAR \verb+min_level+ to the new required minimum level.
\item INT_VAR \verb+speed+ to the new speed factor.
\item INT_VAR \verb+thac0_bonus+ to the new THAC0 bonus.
\item INT_VAR \verb+dicesize+ to the new dice size.
\item INT_VAR \verb+dicenumber+ to the new number of dice.
\item INT_VAR \verb+damage_bonus+ to the new damage bonus.
\item INT_VAR \verb+damage_type+ to the new damage type.
\item INT_VAR \verb+charges+ to the new number of charges.
\item INT_VAR \verb+projectile+ to the new projectile.
\item STR_VAR \verb+icon+ to the resource reference to be used for matching if \verb+match_icon+ is 1, or the new ability icon if \verb+match_icon+ is 0.
\end{itemize}
\\

\verb+DELETE_SPELL_HEADER+: delete ability headers, also known as \ahref{\url{http://gibberlings3.net/iesdp/file_formats/ie_formats/itm_v1.htm#itmv1_Extended_Header}}{extended headers}, from spells. This is a PATCH function. The integer variable \verb+header_type+ defaults to 0. The integer variable \verb+min_level+ defaults to -1 and if this variable is 0 or greater, only headers with a matching minimum level will be deleted.

This function will delete one or more ability headers, along with all of their associated effects, and properly re-index the file.

\begin{itemize}
\item INT_VAR \verb+header_type+ to the header type to delete. If this variable is -1, all header types will be a match. (default 0)
\item INT_VAR \verb+min_level+ to the minimum level to be matched. If this variable is negative, it will not be used for matching. (default -1)
\end{itemize}
\\

\verb+CLONE_EFFECT+: This is a patch function for creature, item, or spell files that will match an existing effect and create a new one based on the matched effect. Numerous variables are available for matching the specified effect and for specifying new values in the new effect based on the matched effect.

The first batch of variables are meta-variables which will help determine the scope of the function:

\begin{itemize}
\item INT_VAR \verb+check_globals+ to whether the function should loop through global effects on items (also known as equipping effects) and spells (default is 1). Creature effects are all global effects, so this variable will always be considered to be one when this function is run on a creature.
\item INT_VAR \verb+check_headers+ to whether the function should loop through effects on extended headers on items and spells if set to 1 (default is 1). Creatures have no extended headers, so this variable is ignored when used on creatures.
\item INT_VAR \verb+header+ to whether the function should target effects on one specific header, counting the first header as zero. A negative value will match all headers (default is -1). Creatures have no extended headers, so this variable is ignored when used on creatures.
\item INT_VAR \verb+header_type+ to whether the function should only clone effects on extended headers of the specified type (1 - melee, 2 - ranged, etc.). Negative values will look at effects on all headers (default is -1). Creatures have no extended headers, so this variable is ignored when used on creatures.
\item INT_VAR \verb+multi_match+ to the number of effects to clone in the active stack. If you just want to match the first effect and have the function stop, use 1. Otherwise the function will continue matching until the number of cloned effects matches this value. The function will always make at least one change (e.g. 0 or negative values are treated as 1). (default is 999).
\item INT_VAR \verb+verbose+ to whether the function should provide some rudimentary information on how many effects were added (default is 0).
\item INT_VAR \verb+silent+ to whether the function should suppress warnings when no effects were added. This option also suppresses the \t{verbose} option (default is 0).
\item STR_VAR \verb+insert+ to the relative position the cloned effect should be inserted at. A value of 'below' puts the new, cloned effect immediately below the matched effect. Values of 'first' or last' will put the new effect at the top or bottom of the effect stack, respectively. All other values will default to 'above', where the effect is added immediately before the matched effect (default is 'above').
\end{itemize}

The next batch of variables sets the function boundaries on matching an effect to clone. Any variables not specified will not be used to determine a match. The function will only determine an effect is a match only if ALL of the variables specified are matched.

\begin{itemize}
\item INT_VAR \verb+match_opcode+ to the opcode of effects to be matched (default -1).
\item INT_VAR \verb+match_target+ to the target of effects to be matched (default -1).
\item INT_VAR \verb+match_power+ to the power of effects to be matched (default -1).
\item INT_VAR \verb+match_parameter1+ to parameter1 of effects to be matched (default -1).
\item INT_VAR \verb+match_parameter2+ to parameter2 of effects to be matched (default -1).
\item INT_VAR \verb+match_timing+ to the timing of effects to be matched (default -1).
\item INT_VAR \verb+match_resist_dispel+ to the resist/dispel setting of effects to be matched (default -1).
\item INT_VAR \verb+match_duration+ to the duration of effects to be matched (default -1).
\item INT_VAR \verb+match_probability1+ to probability1 (the upper bound) of effects to be matched (default -1).
\item INT_VAR \verb+match_probability2+ to probability2 (the lower bound) of effects to be matched (default -1).
\item INT_VAR \verb+match_dicenumber+ to the number of dice of effects to be matched (default -1). This field is instead used for maximum hit-dice (HD) by some opcodes.
\item INT_VAR \verb+match_dicesize+ to the size of dice of effects to be matched (default -1). This field is used instead for minimum hit-dice (HD) by some opcodes.
\item INT_VAR \verb+match_savingthrow+ to the saving throw type of effects to be matched (default -1).
\item INT_VAR \verb+match_savebonus+ to the saving throw bonus of effects to be matched (default -11). Since saving throws can range into negative values, this variable can match all the way down to -10.
\item INT_VAR \verb+match_special+  to the special field of effects to be matched (default -1). The special field is used by some EE effects.
\item STR_VAR \verb+match_resource+ to the resource of effects to be matched (default "SAME").
\end{itemize}

Once a matching effect is found, a new effect is created (STR_VAR
\verb+insert+ determines its placement) with all of the same
specifications as the matched effect. The next series of variables
allows the function to change the fields to new values in the
newly-created effect. All integer variables have the default value -1,
except savebonus which defaults to -11. If the value of a variable is
less than or equal to the default value, the new effect inherits the
corresponding value of the matched effect.

\begin{itemize}
\item INT_VAR \verb+opcode+ to the value the of the new effect's opcode.
\item INT_VAR \verb+target+ to the new effect's target.
\item INT_VAR \verb+power+ to the new effect's power.
\item INT_VAR \verb+parameter1+ to the new effect's parameter1.
\item INT_VAR \verb+parameter2+ to the new effect's parameter2.
\item INT_VAR \verb+timing+ to the new effect's timing mode.
\item INT_VAR \verb+resist_dispel+ to the new effect's resist/dispel setting.
\item INT_VAR \verb+duration+ to the new effect's duration.
\item INT_VAR \verb+probability1+ to the new effect's probability1 (the upper bound).
\item INT_VAR \verb+probability2+ to the new effect's probability2 (the lower bound).
\item INT_VAR \verb+dicenumber+ to the new effect's number of dice. This field is instead used for maximum hit-dice (HD) by some opcodes.
\item INT_VAR \verb+dicesize+ to the new effect's size of dice. This field is also instead for minimum hit-dice (HD) by some opcodes.
\item INT_VAR \verb+savingthrow+ to the new effect's saving-throw type.
\item INT_VAR \verb+savebonus+ to the new effect's saving-throw bonus/penalty. This variable can take negative values down to -10 while still writing to the corresponding field.
\item INT_VAR \verb+special+ to the new effect's special field. The special field is used by many EE effects.
\item STR_VAR \verb+resource+ to the new effect's resource reference.
\end{itemize}
\\

\verb+DELETE_EFFECT+: This is a patch function for creature, item, or spell files that will match an existing effect and then delete it. Numerous variables are available for matching the specified effect.

The first batch of variables are meta-variables which will help determine the scope of the function:

\begin{itemize}
\item INT_VAR \verb+check_globals+ to whether the function should loop through global effects on items (also known as equipping effects) and spells (default is 1). Creature effects are all global effects, so this variable will always be considered to be one when this function is run on a creature.
\item INT_VAR \verb+check_headers+ to whether the function should loop through effects on extended headers on items and spells (default is 1). Creatures have no extended headers, so this variable is ignored when used on creatures.
\item INT_VAR \verb+header+ to whether the function should target effects on one specific header, counting the first header as zero. A negative value will match all headers (default is -1). Creatures have no extended headers, so this variable is ignored when used on creatures.
\item INT_VAR \verb+header_type+ to whether the function should only delete effects on extended headers of the specified type (1 - melee, 2 - ranged, etc.). Negative values will look at effects on all headers (default is -1). Creatures have no extended headers, so this variable is ignored when used on creatures.
\item INT_VAR \verb+multi_match+ to the number of effects to delete in the active stack. If you just want to match the first effect and have the function stop, use 1. Otherwise the function will continue matching until the number of deleted effects matches this value. The function will always make at least one change (e.g. 0 or negative values are treated as 1). (default is 999).
\item INT_VAR \verb+verbose+ to whether the function should provide some rudimentary information on how many effects were deleted (default is 0).
\end{itemize}

The next batch of variables sets the function boundaries on matching an effect to delete. Any variables not specified will not be used to determine a match. The function will only determine an effect is a match only if ALL of the variables specified are matched.

\begin{itemize}
\item INT_VAR \verb+match_opcode+ to the opcode of effects to be matched (default -1).
\item INT_VAR \verb+match_target+ to the target of effects to be matched (default -1).
\item INT_VAR \verb+match_power+ to the power of effects to be matched (default -1).
\item INT_VAR \verb+match_parameter1+ to parameter1 of effects to be matched (default -1).
\item INT_VAR \verb+match_parameter2+ to parameter2 of effects to be matched (default -1).
\item INT_VAR \verb+match_timing+ to the timing of effects to be matched (default -1).
\item INT_VAR \verb+match_resist_dispel+ to the resist/dispel setting of effects to be matched (default -1).
\item INT_VAR \verb+match_duration+ to the duration of effects to be matched (default -1).
\item INT_VAR \verb+match_probability1+ to probability1 (the upper bound) of effects to be matched (default -1).
\item INT_VAR \verb+match_probability2+ to probability2 (the lower bound) of effects to be matched (default -1).
\item INT_VAR \verb+match_dicenumber+ to the number of dice of effects to be matched (default -1). This field is instead used for maximum hit-dice (HD) by some opcodes.
\item INT_VAR \verb+match_dicesize+ to the size of dice of effects to be matched (default -1). This field is used instead for minimum hit-dice (HD) by some opcodes.
\item INT_VAR \verb+match_savingthrow+ to the saving throw type of effects to be matched (default -1).
\item INT_VAR \verb+match_savebonus+ to the saving throw bonus effects to be matched (default -11). Since saving throws can range into negative values, this variable can match all the way down to -10.
\item INT_VAR \verb+match_special+  to the special field of effects to be matched (default -1). The special field is used by some EE effects.
\item STR_VAR \verb+match_resource+ to the resource of effects to be matched (default "SAME").
\end{itemize}

Once a matching effect is found it is deleted. The function will continue to delete effects from the stack until the number of effects deleted matches the \verb+multi_match+ variable.\\
\\

\verb+ALTER_EFFECT+: This is a patch function for creature, item, or spell files that will match an existing effect and alter it based on the defined variables. Numerous variables are available for matching the specified effect and for specifying new values.

The first batch of variables are meta-variables which will help determine the scope of the function:

\begin{itemize}
\item INT_VAR \verb+check_globals+ to whether the function should loop through global effects on items (also known as equipping effects) and spells (default is 1). Creature effects are all global effects, so this variable will always be considered to be one when this function is run on a creature.
\item INT_VAR \verb+check_headers+ to whether the function should loop through effects on extended headers on items and spells (default is 1). Creatures have no extended headers, so this variable is ignored when used on creatures.
\item INT_VAR \verb+header+ to whether the function should target effects on one specific header, counting the first header as zero. A negative value will match all headers (default is -1). Creatures have no extended headers, so this variable is ignored when used on creatures.
\item INT_VAR \verb+header_type+ to whether the function should only alter effects on extended headers of the specified type (1 - melee, 2 - ranged, etc.). Negative values will look at effects on all headers (default is -1). Creatures have no extended headers, so this variable is ignored when used on creatures.
\item INT_VAR \verb+multi_match+ to the number of effects to alter in the active stack. If you just want to match the first effect and have the function stop, use 1. Otherwise the function will continue matching until the number of altered effects matches this value. The function will always make at least one change (e.g. 0 or negative values are treated as 1). (default is 999).
\item INT_VAR \verb+verbose+ to whether the function should provide some rudimentary information on how many effects were added (default is 0).
\item INT_VAR \verb+silent+ to whether the function should suppress warnings when no effects were altered. This option also suppresses the \t{verbose} option (default is 0).
\end{itemize}

The next batch of variables sets the function boundaries on matching an effect to alter. Any variables not specified will not be used to determine a match. The function will only determine an effect is a match only if ALL of the variables specified are matched.

\begin{itemize}
\item INT_VAR \verb+match_opcode+ to the opcode of effects to be matched (default is -1).
\item INT_VAR \verb+match_target+ to the target of effects to be matched (default is -1).
\item INT_VAR \verb+match_power+ to the power of effects to be matched (default is -1).
\item INT_VAR \verb+match_parameter1+ to parameter1 of effects to be matched (default is -1).
\item INT_VAR \verb+match_parameter2+ to parameter2 of effects to be matched (default is -1).
\item INT_VAR \verb+match_timing+ to the timing of effects to be matched (default is -1).
\item INT_VAR \verb+match_resist_dispel+ to the resist/dispel setting of effects to be matched (default is -1).
\item INT_VAR \verb+match_duration+ to the duration of effects to be matched (default is -1).
\item INT_VAR \verb+match_probability1+ to probability1 (the upper bound) of effects to be matched (default is -1).
\item INT_VAR \verb+match_probability2+ to probability2 (the lower bound) of effects to be matched (default is -1).
\item INT_VAR \verb+match_dicenumber+ to the number of dice of effects to be matched (default is -1). This field is instead used for maximum hit-dice (HD) by some opcodes.
\item INT_VAR \verb+match_dicesize+ to the size of dice of effects to be matched (default is -1). This field is used instead for minimum hit-dice (HD) by some opcodes.
\item INT_VAR \verb+match_savingthrow+ to the saving throw type of effects to be matched (default is -1).
\item INT_VAR \verb+match_savebonus+ to the saving trow bonus effects to be matched (default is -11). Since saving throws can range into negative values, this variable can match all the way down to -10.
\item INT_VAR \verb+match_special+ to the special field of effects to be matched (default is -1). The special field is used by some EE effects.
\item STR_VAR \verb+match_resource+ to the resource of effects to be matched (default is "SAME").
\end{itemize}

Once a matching effect is found, the next series of variables allows
the function to change the fields to these new values in the matched
effect. All integer variables have the default value -1, except
savebonus which defaults to -11. The function does not change the
fields if the value of the corresponding value is less than or equal
to the default value.

\begin{itemize}
\item INT_VAR \verb+opcode+ to the value the of the altered effect's opcode.
\item INT_VAR \verb+target+ to the altered effect's target.
\item INT_VAR \verb+power+ to the altered effect's power.
\item INT_VAR \verb+parameter1+ to the altered effect's parameter1.
\item INT_VAR \verb+parameter2+ to the altered effect's parameter2.
\item INT_VAR \verb+timing+ to the altered effect's timing mode.
\item INT_VAR \verb+resist_dispel+ to the altered effect's resist/dispel setting.
\item INT_VAR \verb+duration+ to the altered effect's duration.
\item INT_VAR \verb+probability1+ to the altered effect's probability1 (the upper bound).
\item INT_VAR \verb+probability2+ to the altered effect's probability2 (the lower bound).
\item INT_VAR \verb+dicenumber+ to the altered effect's number of dice. This field is instead used for maximum hit-dice (HD) by some opcodes.
\item INT_VAR \verb+dicesize+ to the altered effect's size of dice. This field is also instead for minimum hit-dice (HD) by some opcodes.
\item INT_VAR \verb+savingthrow+ to the altered effect's saving-throw type.
\item INT_VAR \verb+savebonus+ to the altered effect's saving-throw bonus/penalty. This variable can take negative values down to -10 while still writing to the corresponding field.
\item INT_VAR \verb+special+ to the new effect's special field. The special field is used by many EE effects.
\item STR_VAR \verb+resource+ to the altered effect's resource reference.
\end{itemize}
\\

\verb+SUBSTRING+: returns a substring of the provided string. This is an ACTION and PATCH function. All integer variables default to 0.

The function will fail with an error if either \verb+start+ or \verb+length+ are negative or if any of \verb+start+, \verb+length+ or the sum of the two is greater than the length of \verb+string+.
\begin{itemize}
\item INT_VAR \verb+start+ to the string index (0 based) from which the start of the substring should be read.
\item INT_VAR \verb+length+ to the length of the substring to be read.
\item STR_VAR \verb+string+ to the string the substring should be read from.
\item RET \verb+substring+ the substring read from the provided string.
\end{itemize}
\\

\verb+ADD_CRE_SCRIPT+: assigns a script to a creature in the first available slot. This is a PATCH function. By default, the function will try all 5 script slots from \verb+SCRIPT_OVERRIDE+ to \verb+SCRIPT_DEFAULT+.

The function will fail with an error if the file being patched does not have a signature (first 3 bytes) that case-sensitively equals \t{CRE}, if either \verb+offset_start+ or \verb+offset_end+ are negative, if \verb+offset_end+ is less than \verb+offset_start+ or if \verb+offset_end+ is greater than the size of the file being patched.
\begin{itemize}
\item INT_VAR \verb+offset_start+ to the offset from which the search for an empty slot should start. (default \verb+SCRIPT_OVERRIDE+)
\item INT_VAR \verb+offset_end+ to the offset at which the search should end. (default \verb+SCRIPT_DEFAULT+)
\item STR_VAR \verb+script+ to the resource reference of the script to be assigned.
\item RET \verb+success+ a return value indicating whether the script was successfully assigned. 1 signifies success and 0 signifies that no empty slot was found. A harmless warning will be printed if the function was unsuccessful.
\end{itemize}
\\

\DEFINE{\verb+HANDLE_AUDIO+}: install Ogg--Vorbis compressed audio files in a safe and easy manner. This is an ACTION function.

% HeVeA forces me to use rawhtml of ~ here. \hspace{1 pc} may also be an option.

This function supports Windows, OS\begin{rawhtml}&nbsp;\end{rawhtml}X, GNU/Linux and all IE games, including BG:EE. If the game is not BG:EE, the audio will be decompressed and the resulting .wav files will be \ttref{MOVE}d to the override. If the game is BG:EE, the .ogg files are copied into the override and renamed into .wav files. Refer to the \ahrefloc{sec-handle-audio-and-handle-tilesets}{\tt{HANDLE!AUDIO} and \tt{HANDLE!TILESETS} tutorial} for usage examples and a more practical explanation.

If the audio files need to be decompressed, this function will use oggdec.exe on Windows, which is by default expected to be found in \verb+audio_path+. The most recent version of oggdec can be downloaded \ahref{\url{http://downloads.xiph.org/releases/vorbis/vorbis-tools-win32-bin.7z}}{here} (direct link). On OS\begin{rawhtml}&nbsp;\end{rawhtml}X, SoX will be used, which is by default also expected to be found in \verb+audio_path+. SoX compiled for OS\begin{rawhtml}&nbsp;\end{rawhtml}X can be downloaded \ahref{\url{http://sourceforge.net/projects/sox/files/sox/14.4.1/sox-14.4.1-macosx.zip/download}}{here}. On GNU/Linux, oggdec will be used, but it is expected to be found on the system path and the user should install it him/herself. If you provide installation instructions for GNU/Linux, just include something to the effect of ``install oggdec, which is usually part of the package vorbis-tools''.

If the decompression utility cannot be found, the user is warned that the audio files were not installed.

\begin{itemize}
\item INT_VAR \verb+music+ if this variable is not 0 and the game is BG:EE, the audio files are given the extension .acm instead of .wav. This variable has no effect if the game is not BG:EE. By default its value is 0.
\item STR_VAR \verb+audio_path+ to the path your .ogg files are stored in. By default this variable is \verb+~%MOD_FOLDER%/audio~+.
\item STR_VAR \verb+oggdec_path+ to the path oggdec is located in. By default this variable is \verb+~%audio_path%~+.
\item STR_VAR \verb+sox_path+ to the path SoX is located in. By default this variable is \verb+~%audio_path%~+.
\item STR_VAR \verb+output_path+ to the path the audio should be installed into. By default this variable is \t{override}.
\end{itemize}
\\

\DEFINE{\verb+HANDLE_TILESETS+}: install TISpack-compressed tilesets in a safe and easy manner. This is an ACTION function.

This function supports Windows, OS\begin{rawhtml}&nbsp;\end{rawhtml}X, GNU/Linux and all IE games that support the \t{\ahref{\url{http://gibberlings3.net/iesdp/file_formats/ie_formats/tis_v1.htm}}{TIS V1}} file format. The program tisunpack, part of \ahref{\url{http://www.pocketplane.net/mambo/index.php?option=com_content&task=blogcategory&id=137&Itemid=96}}{TISpack}, is used to decompress the provided .tiz files and the resulting .tis files are placed in the override. Refer to the \ahrefloc{sec-handle-audio-and-handle-tilesets}{\tt{HANDLE!AUDIO} and \tt{HANDLE!TILESETS} tutorial} for usage examples and a more practical explanation.

This function expects to find tisunpack for one or more of Windows, OS\begin{rawhtml}&nbsp;\end{rawhtml}X or GNU/Linux in a common directory under the subdirectories \t{win32}, \t{osx}, and \t{unix}, respectively. For example, in \t{mymod/tiz/win32}, \t{mymod/tiz/osx} and \t{mymod/tiz/unix}, the common directory is \t{mymod/tiz} and \t{mymod/tiz/win32/tisunpack.exe} should be a valid file. For GNU/Linux, this function also supports tisunpack being located on the system path (something the user would take care of). If you choose to leave tisunpack to the user, you should mention this requirement in any installation instructions you provide.

If tisunpack for the user's platform could not be found, the installation fails.

\begin{itemize}
\item STR_VAR \verb+tiz_path+ to the path your .tiz files are stored in. By default this variable is \verb+~%MOD_FOLDER%/tiz~+.
\item STR_VAR \verb+tisunpack_path+ to the common directory where the subdirectories \t{win32}, \t{osx} and \t{unix} are located. By default this variable is \verb+~%tiz_path%~+.
\item STR_VAR \verb+output_path+ to the path the tilesets should be installed into. By default this variable is \t{override}.
\end{itemize}
\\

\DEFINE{\verb+HANDLE_CHARSETS+}: runtime-convert \t{TRA} files to/from \t{UTF-8} in a safe and easy manner. This is an ACTION function.

This function supports Windows, OS\begin{rawhtml}&nbsp;\end{rawhtml}X and GNU/Linux. This function can run in two modes: let's call them forward and reverse. The forward mode is used for converting \t{TRA} files from legacy ``ANSI'' character sets into UTF-8 for use by EE-type games. The reverse mode converts UTF-8 into the legacy ``ANSI'' character sets used by the original game editions. The variable \verb+from_utf8+ controls whether the function runs in forward or reverse. \verb+HANDLE_CHARSETS+ needs to be used before any text is installed and is compatible with \ttref{AUTO!TRA} and all other methods of loading \t{TRA} files, unless the option \verb+out_path+ is used.

Conversion is handled by the program \t{iconv}. The program is available as part of the base system on OS\begin{rawhtml}&nbsp;\end{rawhtml}X and GNU/Linux but a Windows version needs to be included in your mod. A Windows version can be downloaded \ahref{\url{http://gnuwin32.sourceforge.net/packages/libiconv.htm}}{here}.

In order to function, \verb+HANDLE_CHARSETS+ needs to know a few things. First, you need to specify where you keep your \t{TRA} files. You do this with the variable \verb+tra_path+. Second, \verb+HANDLE_CHARSETS+ needs to know where the Windows version of \t{iconv} is located. You do this with the variable \verb+iconv_path+. Third, \verb+HANDLE_CHARSETS+ needs to know which character set the \t{TRA} files are in and which character set they should be converted into. For this, the function needs to know whether to run in forward or reverse mode; you specify this with the variable \verb+from_utf8+. If the variable is 0 (default), files are converted from a language-dependent character set into UTF-8 and cannot already be in UTF-8. If the variable is 1, files are converted from UTF-8 into a language-dependent character set. Which language-dependent character set should be used in the conversion process is specified with \verb+charset_table+ or, or you can tell \verb+HANDLE_CHARSETS+ to try to infer this by itself with \verb+infer_charsets+. Lastly, \verb+HANDLE_CHARSETS+ needs to know which \t{TRA} files to convert and whether any of them should be reloaded. You can do this with \verb+noconvert_array+, \verb+convert_array+ and \verb+reload_array+.

Unless \verb+convert_array+ is specified, \verb+HANDLE_CHARSETS+ will recursively convert all \t{TRA} files in \verb+tra_path+ except those listed in \verb+noconvert_array+. If \verb+convert_array+ is specified, only those \t{TRA} files listed in the array will be converted. \verb+convert_array+ may contain references to \t{TRA} files in subdirectories of \verb+tra_path+.

\begin{itemize}
\item INT_VAR \verb+infer_charsets+ to whether \verb+HANDLE_CHARSETS+ should try to infer which language-dependent character set is used by the language in which the mod is being installed. It uses the contents of the \t{\%language\%} variable (\textit{vide infra}). If the contents of the variable can be recognised, \verb+HANDLE_CHARSETS+ will use the character set used by the localised version of BG2 for this language. If the contents of the variable cannot be recognised, or if the \t{TRA} files use a different character set than the expected one, \verb+HANDLE_CHARSETS+ will fail. Refer to the compatibility matrix below for additional information. \verb+infer_charsets+ overrides \verb+charset_table+. Defaults to 0.
\item INT_VAR \verb+from_utf8+ to whether the function should assume the source \t{TRA} files are in UTF-8 or not. The default value is 0, that is, the function assumes the \t{TRA} files use language-dependent charater sets and should be converted into UTF-8 when the mod is installed on EE-type games; the function produces no results on the original editions of the games. If set to 1, the source \t{TRA} files are assumed to be in UTF-8 and are to be converted into language-dependent character sets when the mod is installed on original editions of the games; the function produces no results when installed on EE-type games.
\item INT_VAR \verb+verbose+ to whether the function should print debug information. Defaults to 0.
\item STR_VAR \verb+language+ to the name of the language directory you wish to convert. The default value of this variable is \verb+\%LANGUAGE\%+, in other words, the directory corresponding to the language the user selected at the start of the installation. You should never need to alter the value of this variable.
\item STR_VAR \verb+default_language+ to the name of the directory used by the default language of your mod, if your mod has one. The default language is typically one for which the translation is always complete and up to date and which you use to guard against incomplete translations. \verb+HANDLE_CHARSETS+ will convert the \t{TRA} files of the default language in addition to those of the user-selected language. Should these two languages be the same, the \t{TRA} files will only be converted once. Additionally, any \t{TRA} files listed in the \verb+reload_array+ (\textit{vide infra}) will be reloaded for the default language before they are reloaded for the user-selected language. The default value of this variable is \verb+~~+ (the empty string).
\item STR_VAR \verb+tra_path+ to the path where your mod's language directories are located. \verb+%tra_path%/%language%+ should be a valid directory containing \t{TRA} files.
\item STR_VAR \verb+out_path+ to the path to which the converted files should be directed. The default value of this variable is \verb+%tra_path%+, that is, the converted files reversibly overwrite the originals and the conversion is transparent to the rest of your mod. Note that if \verb+%tra_path+ and \verb+out_path+ are the same directory, the conversion will naturally happen only once regardless of how many times \verb+HANDLE_CHARSETS+ are invoked, but if the directories are different, the conversion will happen for every invocation (notably, if \verb+HANDLE_CHARSETS+ is invoked among the \ttref{ALWAYS} actions).
\item STR_VAR \verb+iconv_path+ to the path where iconv.exe is located. Defaults to \verb+%tra_path%/iconv+.
\item STR_VAR \verb+charset_table+ to the name of an associative array where the keys are the names of your language directories and the corresponding values are the character sets used by the respective language. The keys must be entirely in lowercase. \verb+charset_table+ is not used if you also specify \verb+infer_charsets+.
\item STR_VAR \verb+noconvert_array+ to the name of an array indexed by monotonically increasing integers starting from 0. The values should be the names of \t{TRA} files that should not be converted into \t{UTF-8}. All \t{TRA} files in the language directory and its subdirectories except the ones listed in \verb+noconvert_array+ will be converted. The .tra file extension is optional. This variable should not be provided if you also provide \verb+convert_array+.
\item STR_VAR \verb+convert_array+ to the name of an array indexed by monotonically increasing integers starting from 0. The values should be the names of \t{TRA} files that should be converted into \t{UTF-8}. Only those \t{TRA} files in the language directory or its subdirectories which are listed in \verb+convert_array+ will be converted. The .tra file extension is optional. If this variable is provided, \verb+noconvert_array+ will not be used.
\item STR_VAR \verb+reload_array+ to the name of an array indexed by monotonically increasing integers starting from 0. The values should be the names of \t{TRA} files which should be reloaded after they have been converted. The .tra file extension is optional. You should use this variable for reloading those \t{TRA} files loaded by \ttref{LANGUAGE} which should also be converted.
\item STR_VAR \verb+file_regexp+ to a regexp expression with the file names that must be converted. Defaults to \verb~.+$\backslash$.tra$~.
\end{itemize}

Compatibility matrix for \verb+infer_charsets+.
\begin{tabular} {l c r}
\hline
Language & \verb+%LANGUAGE%+ contains & Inferred character set \\
\hline
Simplified Chinese & schinese, zh_CN & CP936 \\
Traditional Chinese & tchinese & CP950 \\
Czech & czech, cs_CZ & CP1250 \\
English & english, american, en_US & CP1252 \\
French & french, francais, fr_FR & CP1252 \\
German & german, deutsch, de_DE & CP1252 \\
Italian & italian, italiano, it_IT & CP1252 \\
Japanese & japanese, ja_JP & CP932 \\
Korean & korean, ko_KR & CP949 \\
Polish & polish, polski, pl_PL & CP1250 \\
Russian & russian, ru_RU & CP1251 \\
Spanish & spanish, castilian, espanol, castellano, es_ES & CP1252 \\
\hline
\end{tabular}
\\

\DEFINE{\verb+DELETE_WORLDMAP_LINKS+}: delete all links from one worldmap area to another. This is a PATCH function.

This function will delete links from one specified area to another. Links can be deleted from all four directional nodes (north, east, south, west) or from a specific node. Links connecting the areas in the opposite direction will not be deleted.

\begin{itemize}
\item STR_VAR \verb+from_area+ to the area from which the links that are to be deleted originate.
\item STR_VAR \verb+from_node+ to the directional node from which the links that are to be deleted originate. Legal values for this variable are ``north'', ``n'', ``east'', ``e'', ``south'', ``s'', ``west'', ``w''. Values are not case sensitive. Links are deleted from all four nodes by default.
\item STR_VAR \verb+to_area+ to the area to which the links that are to be deleted lead.
\end{itemize}
\\

\DEFINE{\verb+ADD_WORLDMAP_LINKS+}: add links from one worldmap area to another. This is a PATCH function.

This function add links from one specified area to another. Links can be added from all four directional nodes (north, east, south, west) or from a specific node. If a link already exists, its metadata (distance scale, random encounters, etc.) will be overwritten. Links connecting the areas in the opposite direction will not be added. If either of the areas do not exist in the worldmap, a warning is printed and no links are added.

\begin{itemize}
\item INT_VAR \verb+distance_scale+ to the distance scale between the two areas. \verb+distance_scale+ * 4 equals the travel time between the areas (in hours).
\item INT_VAR \verb+default_entry+ to the default entry location. Legal values for this variable are 1 (northern side), 2 (eastern), 4 (southern) and 8 (western). The default value is 1.
\item INT_VAR \verb+encounter_probability+ to the probability of a random encounter occurring.
\item STR_VAR \verb+from_area+ to the area from which the links should originate.
\item STR_VAR \verb+from_node+ to the directional node from which the links should originate. Legal values for this variable are ``north'', ``n'', ``east'', ``e'', ``south'', ``s'', ``west'' and ``w''. Values are not case sensitive. Links are added to all four nodes by default.
\item STR_VAR \verb+to_area+ to the area to which the links should lead.
\item STR_VAR \verb+entry+ to the entry point in \verb+to_area+.
\item STR_VAR \verb+random_area1+ to the first random-encounter area.
\item STR_VAR \verb+random_area2+ to the second random-encounter area.
\item STR_VAR \verb+random_area3+ to the third random-encounter area.
\item STR_VAR \verb+random_area4+ to the fourth random-encounter area.
\item STR_VAR \verb+random_area5+ to the fifth random-encounter area.
\end{itemize}
\\

\DEFINE{\verb+UPDATE_PVRZ_INDICES+}: update the \t{PVRZ} references in a \t{BAM V2} or \t{MOS V2} resource. This is a PATCH function.

This function will update the \t{PVRZ} references in a \t{BAM V2} or \t{MOS V2} resource with the next contiguous block of free \t{PVRZ} indices. This function is intended to be used in combination with the action function \ttref{INSTALL!PVRZ}.

\begin{itemize}
\item INT_VAR \verb+target_base_index+ is an optional parameter. When specified, the function attempts to use a block of free \t{PVRZ} indices starting at the specified value. The default value is 1000.
\item RET \verb+original_base_index+ returns the lowest \t{PVRZ} index used by the source \t{BAM} or \t{MOS}. Returns -1 on error.
\item RET \verb+new_base_index+ returns the lowest \t{PVRZ} index used by the target \t{BAM} or \t{MOS}. Returns -1 on error.
\item RET \verb+index_range+ returns the range of reserved \t{PVRZ} indices, i.e., the difference between the smallest and biggest \t{PVRZ} index, inclusive. Returns 0 on error.
\end{itemize}
\\

\DEFINE{\verb+INSTALL_PVRZ+}: install a \t{PVRZ} file and updates the \t{PVRZ} index. This is an ACTION function.

This function copies the specified \t{PVRZ} file into the target folder and updates the \t{PVRZ} index. This function should be used in conjunction with \ttref{UPDATE!PVRZ!INDICES}.

\begin{itemize}
\item INT_VAR \verb+original_base_index+ to the current base index. This value is returned by the function \ttref{UPDATE!PVRZ!INDICES} as \verb+original_base_index+.
\item INT_VAR \verb+new_base_index+ to the new base index. This value is returned by the function \ttref{UPDATE!PVRZ!INDICES} as \verb+new_base_index+.
\item STR_VAR \verb+source_file+ to the source file to copy. The filename must match the regular expression \t{\textasciitilde MOS[0-9]+\textbackslash.PVRZ\textasciitilde} (e.g., MOS0000.PVRZ, mos1592.pvrz or Mos12345.PVRZ). Case is ignored.
\item STR_VAR \verb+target_folder+ to the target folder to copy the source file into. The default value is "override".
\item RET \verb+success+ is set to non-zero if the function returned successfully and is set to zero on error.
\item This function can additionally return all the variables automatically set by \ttref{COPY}.
\end{itemize}
\\

\DEFINE{\verb+FIND_FREE_PVRZ_INDEX+}: attempt to find a contiguous block of free \t{PVRZ} indices in the game installation. This is a PATCH and an ACTION function.

This function attempts to find the first available free \t{PVRZ} index of a contiguous block which guarantees to fit at least \verb+num_to_reserve+ indices.

\begin{itemize}
\item INT_VAR \verb+num_to_reserve+ to the minimum required size of the contiguous block of free indices. This number should be no smaller than 1 nor no bigger than 999. The default value is 1.
\item INT_VAR \verb+start_index+ to the index the search should begin at. The default value is 1000.
\item RET \verb+free_index+ returns the first available index matching the specified parameters. Returns -1 on errors.
\end{itemize}
\\

\DEFINE{\verb+DIRECTORY_OF_FILESPEC+}: returns the directory of a file specification. Compare to \ttref{SOURCE!DIRECTORY}. This is an ACTION and PATCH function.

\begin{itemize}
\item STR_VAR \verb+filespec+ to the file specification, which must include an identifiable directory, or a warning will be raised.
\item RET \verb+directory+ returns the directory of the file specification.
\end{itemize}

\DEFINE{\verb+FILE_OF_FILESPEC+}: returns the file of a file specification. Compare to \ttref{SOURCE!FILE}. This is an ACTION and PATCH function.

\begin{itemize}
\item STR_VAR \verb+filespec+ to the file specification, which may or may not include a directory.
\item RET \verb+file+ returns the file of the file specification.
\end{itemize}

\DEFINE{\verb+RES_OF_FILESPEC+}: returns the resource name of a file specification. Compare to \ttref{SOURCE!RES}. This is an ACTION and PATCH function.

\begin{itemize}
\item STR_VAR \verb+filespec+ to the file specification, which must include an identifiable resource name, or a warning will be raised.
\item RET \verb+res+ returns the resource name of the file specification.
\end{itemize}

\DEFINE{\verb+EXT_OF_FILESPEC+}: returns the resource extension of a file specification. Compare to \ttref{SOURCE!EXT}. This is an ACTION and PATCH function.

\begin{itemize}
\item STR_VAR \verb+filespec+ to the file specification, which must include an identifiable resource extension, or a warning will be raised.
\item RET \verb+ext+ returns the resource extension of the file specification.
\end{itemize}
\\

\subsection{Store-related functions}

\DEFINE{\verb+ADD_STORE_ITEM_EX+}: adds an item to the current STO file. This is a PATCH function.

\begin{itemize}
\item INT_VAR \verb+charge1+ to the number of charges of the 1st ability or quantity for stackables. (Default: 0)
\item INT_VAR \verb+charge2+ to the number of charges of the 2nd ability. (Default: 0)
\item INT_VAR \verb+charge3+ to the number of charges of the 3rd ability. (Default: 0)
\item INT_VAR \verb+stack+ to the number of item instances the store carries in the stack. (Default: 1)
\item INT_VAR \verb+unlimited+ to non-zero if the store should carry an inexhaustible stack of the new item. (Default: 0)
\item INT_VAR \verb+overwrite+ to non-zero to overwrite any instances of an existing sale entry of matching item resref when found. (Default: 0)
\item INT_VAR \verb+expiration+ to the item's expiration time, when it will be replaced with the drained item. (Default: 0)
\item STR_VAR \verb+item_name+ to the resource name (resref) of the item to add.
\item STR_VAR \verb+position+ to the desired position of the item in the list of sale entries. The following syntax is supported:
\begin{verbatim}
AFTER resref    Will place the new item directly behind the item given by "resref".
                You can list more than one resref, separated by space. The new item will be
                added after the entry of the first matching resref.
BEFORE resref   Will place the new item directly before the item given by "resref".
                You can list more than one resref, separated by space. The new item will be
                added before the entry of the first matching resref.
LAST            Will place the new item after all existing items.
FIRST           Will place the new item before all existing items.
AT value        Will place the new item at the position given by the number "value".
                Use negative values to place the new item relative to the last item position
                in reverse order.
\end{verbatim}
(Default: FIRST)
\item STR_VAR \verb+flags+ to numeric values or the following constants: \verb+none+, \verb+identified+, \verb+unstealable+, \verb+stolen+. Constants can be combined by using ampersand (\&) or space as separators (e.g. \verb+identified&unstealable+). (Default: \verb+none+)
\item STR_VAR \verb+sale_trigger+ Availability trigger (STO V1.1 only). The following syntax is supported:
\begin{verbatim}
Trigger string          Example: GlobalGT("MyCondition","GLOBAL",0)
Strref value            Example: #1234
Translation reference   Example: @1000
\end{verbatim}
(Default: #-1)
\item RET \verb+index+ returns the index of the added item or the last matching index when overwriting items. Returns -1 if the item could not be added or updated.
\item RET \verb+offset+ returns the offset of the added item or the last matching offset when overwriting items. Returns -1 if the item could not be added or updated.
\end{itemize}

\DEFINE{\verb+ADD_STORE_DRINK+}: adds a drink to the current STO file. This is a PATCH function.

\begin{itemize}
\item INT_VAR \verb+price+ to the price of the drink.
\item INT_VAR \verb+rate+ to the rate (\%) of displaying a rumor.
\item INT_VAR \verb+overwrite+ to non-zero to overwrite any instances of an existing drink of matching \verb+drink_name+ when found. (Default: 0)
\item STR_VAR \verb+drink_name+ to the name of the drink.
The following syntax is supported:
\begin{verbatim}
Literal string          Example: Elminster's Choice Beer
Strref value            Example: #1234
Translation reference   Example: @1000
\end{verbatim}
\item STR_VAR \verb+position+ to the desired position in the list of drinks. Refer to the table below for supported expressions. The following syntax is supported:
\begin{verbatim}
AFTER name      Will place the new drink directly behind the drink given by "name". Name can
                either be a strref value (e.g. #1234) or a translation reference (e.g. @1000).
                You can list more than one name, separated by space. The new drink will be
                added after the entry of the first matching name.
BEFORE name     Will place the new drink directly before the drink given by "name". Name can
                either be a strref value (e.g. #1234) or a translation reference (e.g. @1000).
                You can list more than one name, separated by space. The new drink will be
                added before the entry of the first matching name.
LAST            Will place the new drink after all existing drinks.
FIRST           Will place the new drink before all existing drinks.
AT value        Will place the new drink at the position given by the number "value".
                Use negative values to place the new drink relative to the last drink position
                in reverse order.
\end{verbatim}
(Default: FIRST)
\item RET \verb+index+ returns the index of the added drink or the last matching index when overwriting drinks. Returns -1 if the drink could not be added or updated.
\item RET \verb+offset+ returns the offset of the added drink or the last matching offset when overwriting drinks. Returns -1 if the drink could not be added or updated.
\end{itemize}

\DEFINE{\verb+ADD_STORE_CURE+}: adds a cure to the current STO file. This is a PATCH function.

\begin{itemize}
\item INT_VAR \verb+price+ to the spell price.
\item INT_VAR \verb+overwrite+ to non-zero to overwrite any instances of an existing cure entry of matching spell resref when found. (Default: 0)
\item STR_VAR \verb+spell_name+ to the resource name (resref) of the spell to add.
\item STR_VAR \verb+position+ to the desired position in the list of cures. Refer to the table below for supported expressions. The following syntax is supported:
\begin{verbatim}
AFTER resref    Will place the new spell directly behind the spell given by "resref".
                You can list more than one resref, separated by space. The new spell will be
                added after the entry of the first matching resref.
BEFORE resref   Will place the new spell directly before the spell given by "resref".
                You can list more than one resref, separated by space. The new spell will be
                added before the entry of the first matching resref.
LAST            Will place the new spell after all existing cures.
FIRST           Will place the new spell before all existing cures.
AT value        Will place the new spell at the position given by the number "value".
                Use negative values to place the new spell relative to the last spell position
                in reverse order.
\end{verbatim}
(Default: FIRST)
\item RET \verb+index+ returns the index of the added cure or the last matching index when overwriting cure entries. Returns -1 if the spell could not be added or updated.
\item RET \verb+offset+ returns the offset of the added cure or the last matching offset when overwriting cures. Returns -1 if the spell could not be added or updated.
\end{itemize}

\DEFINE{\verb+ADD_STORE_PURCHASE+}: adds one or more item categories the store will buy to the current STO file. Existing categories will be skipped.
\begin{itemize}
\item INT_VAR \verb+category+ to the item category to add. A nearly complete list of supported item category codes can be found \ahref{\url{https://gibberlings3.github.io/iesdp/file_formats/ie_formats/sto_v1.htm#tableItemType}}{here}.
\item RET \verb+index+ returns the index of the added purchase. Returns -1 if the purchase could not be added.
\item RET \verb+offset+ returns the offset of the added purchase. Returns -1 if the purchase could not be added.
\end{itemize}

\DEFINE{\verb+REMOVE_STORE_ITEM_EX+}: removes all sale instances matching the specified item name from the current STO file. This is a patch function.
\begin{itemize}
\item STR_VAR \verb+item_name+ to the resource name (resref) of the item to remove. Regular expression syntax is supported.
\item RET \verb+index+ returns the index of the first removed entry matching the item name, returns -1 otherwise.
\item RET \verb+offset+ returns the offset of the first removed entry matching the item name, returns -1 otherwise.
\end{itemize}

\DEFINE{\verb+REMOVE_STORE_DRINK+}: removes all drink instances matching the specified drink name from the current STO file. This is a patch function.
\begin{itemize}
\item STR_VAR \verb+drink_name+ to the name of the drink to remove. The following syntax is supported:
\begin{verbatim}
Literal string          Example: Elminster's Choice Beer
Strref value            Example: #1234
Translation reference   Example: @1000
\end{verbatim}
Note: Regular expression syntax is supported for literal strings.
\item RET \verb+index+ returns the index of the first removed entry matching the drink name, returns -1 otherwise.
\item RET \verb+offset+ returns the offset of the first removed entry matching the drink name, returns -1 otherwise.
\end{itemize}

\DEFINE{\verb+REMOVE_STORE_CURE+}: removes all cure instances matching the specified spell name from the current STO file. This is a patch function.
\begin{itemize}
\item STR_VAR \verb+spell_name+ to the resource name (resref) of the spell to remove. Regular expression syntax is supported.
\item RET \verb+index+ returns the index of the first removed entry matching the spell name, returns -1 otherwise.
\item RET \verb+offset+ returns the offset of the first removed entry matching the spell name, returns -1 otherwise.
\end{itemize}

\DEFINE{\verb+REMOVE_STORE_PURCHASE+}: removes the specified item category from the current STO file. This is a patch function.
\begin{itemize}
\item INT_VAR \verb+category+ to the item category to remove. A nearly complete list of supported item category codes can be found \ahref{\url{https://gibberlings3.github.io/iesdp/file_formats/ie_formats/sto_v1.htm#tableItemType}}{here}.
\item RET \verb+index+ returns the index of the first removed entry matching the category, returns -1 otherwise.
\item RET \verb+offset+ returns the offset of the first removed entry matching the category, returns -1 otherwise.
\end{itemize}

\subsection{\DEFINE{fj_are_structure}}
Adds a structure to an area file. All variables are zero or blank by default unless otherwise indicated. Fields designated by an asterisk are typically required; all others are optional.
This is a PATCH function.

Universal structure variables:
\begin{itemize}
\item STR_VAR \verb+fj_structure_type+ to the type of area structure to be added (actor, region, spawn, entrance, container, itm, ambient, variable, door, animation, explored bitmask, songlist, rest interrupt table, note or projectile)*;
\item INT_VAR \verb+fj_delete_mode+ to the index of the structure to be deleted (if deleting rather than adding a new structure);
\item INT_VAR \verb+fj_debug+ to 1 to enable feedback
\item RET \verb+fj_return_offset+ returns the position of the structure in the area file;
\end{itemize}
Actor structure variables:
\begin{itemize}
\item STR_VAR \verb+fj_name+ to the actor's name*;
\item INT_VAR \verb+fj_loc_x+ to the starting X (horizontal) coordinate*;
\item INT_VAR \verb+fj_loc_y+ to the starting Y (vertical) coordinate*;
\item INT_VAR \verb+fj_dest_x+ to the destination X coordinate (by default the same as \verb+fj_loc_x+);
\item INT_VAR \verb+fj_dest_y+ to the destination Y coordinate (by default the same as \verb+fj_loc_y+);
\item INT_VAR \verb+fj_loading+ to whether the .cre file is loaded (0=attached, 1=loaded, default 1);
\item INT_VAR \verb+fj_spawned+ to whether the creature has been spawned (0=no, 1=yes, default 0);
\item INT_VAR \verb+fj_animation+ to the actor's animation number (from animate.ids, though the engine uses the animation set on the .cre file);
\item INT_VAR \verb+fj_orientation+ to the facing direction (0-15 where 0=south, 4=west, 8=north, 12=east, default 0);
\item INT_VAR \verb+fj_expiry+ to the actor removal timer in absolute ticks (default -1 to avoid removal);
\item INT_VAR \verb+fj_wander_dist_actor+ to the actor's random walk distance limit;
\item INT_VAR \verb+fj_mvmt_dist_actor+ to the actor's movement distance limit;
\item INT_VAR \verb+fj_schedule+ to the hourly appearance schedule (bits 0-23, default -1 or always);
\item INT_VAR \verb+fj_num_talked+ to the NumTimesTalkedTo (in .sav files);
\item STR_VAR \verb+fj_dlg_resref+ to the actor's dialogue file (normally obtained from .cre files);
\item STR_VAR \verb+fj_bcs_override+ to the actor's override script (normally obtained from .cre files);
\item STR_VAR \verb+fj_bcs_general+ to the actor's general script (normally obtained from .cre files);
\item STR_VAR \verb+fj_bcs_class+ to the actor's class script (normally obtained from .cre files);
\item STR_VAR \verb+fj_bcs_race+ to the actor's race script (normally obtained from .cre files);
\item STR_VAR \verb+fj_bcs_default+ to the actor's default script (normally obtained from .cre files);
\item STR_VAR \verb+fj_bcs_specific+ to the actor's specific script (normally obtained from .cre files);
\item STR_VAR \verb+fj_cre_resref+ to the actor's resource reference (creature filename)*;
\item STR_VAR \verb+fj_cre_embedded+ to ~path/to/file.cre~ if embedding a new creature (defaults to \verb+fj_cre_resref+ if not set);
\end{itemize}
Region structure variables:
\begin{itemize}
\item STR_VAR \verb+fj_name+ to the region's name*;
\item INT_VAR \verb+fj_type+ to the region type (0=trap, 1=info, 2=travel)*;
\item INT_VAR \verb+fj_box_left+ to the leftmost X coordinate of the region's bounding box*;
\item INT_VAR \verb+fj_box_top+ to the topmost Y coordinate of the region's bounding box*;
\item INT_VAR \verb+fj_box_right+ to the rightmost X coordinate of the region's bounding box*;
\item INT_VAR \verb+fj_box_bottom+ to the bottommost Y coordinate of the region's bounding box*;
\item INT_VAR \verb+fj_cursor_idx+ to the region's mouse cursor index (from cursors.bam)*;
\item STR_VAR \verb+fj_destination_area+ to the destination area resource reference (for travel regions);
\item STR_VAR \verb+fj_destination_name+ to the entrance name in the destination area (for travel regions);
\item INT_VAR \verb+fj_flags+ to the bitwise region flags;
\item INT_VAR \verb+fj_info_point_strref+ to the information text string reference (for info points, default -1);
\item INT_VAR \verb+fj_trap_detect+ to the trap detection difficulty percentage;
\item INT_VAR \verb+fj_trap_remove+ to the trap removal difficulty percentage;
\item INT_VAR \verb+fj_trap_active+ to whether the region is trapped (0=no, 1=yes);
\item INT_VAR \verb+fj_trap_status+ to whether the trap is detected (0=no, 1=yes);
\item INT_VAR \verb+fj_loc_x+ to the trap launch X coordinate*;
\item INT_VAR \verb+fj_loc_y+ to the trap launch Y coordinate*;
\item STR_VAR \verb+fj_key_resref+ to the filename of the region's key;
\item STR_VAR \verb+fj_reg_script+ to the region script;
\item INT_VAR \verb+fj_alt_x+ to the activation point X coordinate;
\item INT_VAR \verb+fj_alt_y+ to the activation point Y coordinate;
\item STR_VAR \verb+fj_sound+ to the sound resource reference (ONLY for PST);
\item INT_VAR \verb+fj_talk_loc_x+ to the talk location point X coordinate (ONLY for PST);
\item INT_VAR \verb+fj_talk_loc_y+ to the talk location point Y coordinate (ONLY for PST);
\item INT_VAR \verb+fj_speaker_strref+ to the speaker's name string reference (default -1; ONLY for PST);
\item STR_VAR \verb+fj_dialog+ to the region's dialogue file (ONLY for PST);
\item INT_VAR \verb+fj_vertex_0+ to (X coordinate + (Y coordinate << 16)) for each vertex pair*;
\end{itemize}
Spawn structure variables:
\begin{itemize}
\item STR_VAR \verb+fj_name+ to the spawn point's name*;
\item INT_VAR \verb+fj_loc_x+ to the spawning X coordinate*;
\item INT_VAR \verb+fj_loc_y+ to the spawning Y coordinate*;
\item STR_VAR \verb+fj_cre_resref0+ to the resource reference of each creature spawned (0-9)*;
\item INT_VAR \verb+fj_spawn_num+ to the count of spawn creatures*;
\item INT_VAR \verb+fj_difficulty+ to the base number of creatures to spawn (encounter difficulty)*;
\item INT_VAR \verb+fj_delay+ to the number of seconds between spawning (default 10);
\item INT_VAR \verb+fj_method+ to the spawn method;
\item INT_VAR \verb+fj_duration+ to the creature duration (default 1000);
\item INT_VAR \verb+fj_wander_dist_spawn+ to the creature's random walk distance limit (default 1000);
\item INT_VAR \verb+fj_mvmt_dist_spawn+ to the creature's movement distance limit (default 1000);
\item INT_VAR \verb+fj_max_num+ to the maximum number of creatures to spawn*;
\item INT_VAR \verb+fj_enable+ to the spawn point status (0=inactive, 1=active, default 1);
\item INT_VAR \verb+fj_schedule+ to the hourly appearance schedule (bits 0-23, default -1 or always);
\item INT_VAR \verb+fj_day_prob+ to the spawn point daytime probability (default 100);
\item INT_VAR \verb+fj_night_prob+ to the spawn point nighttime probability (default 100);
\end{itemize}
Entrance structure variables:
\begin{itemize}
\item STR_VAR \verb+fj_name+ to the entrance's name*;
\item INT_VAR \verb+fj_loc_x+ to the X coordinate*;
\item INT_VAR \verb+fj_loc_y+ to the Y coordinate*;
\item INT_VAR \verb+fj_orientation+ to the facing direction (0-15 where 0=south, 4=west, 8=north, 12=east)*;
\end{itemize}
Container structure variables:
\begin{itemize}
\item STR_VAR \verb+fj_name+ to the container's name*;
\item INT_VAR \verb+fj_loc_x+ to the X coordinate*;
\item INT_VAR \verb+fj_loc_y+ to the Y coordinate*;
\item INT_VAR \verb+fj_type+ to the container type (1=bag, 2=chest, 3=drawer, 4=pile, 5=table, 6=shelf, 7=altar, 8=nonvisible, 9=spellbook, 10=body, 11=barrel, 12=crate)*;
\item INT_VAR \verb+fj_lock_diff+ to the lock difficulty (default 100);
\item INT_VAR \verb+fj_flags+ to the bitwise container flags (bit0=locked, bit3=trap resets, bit5=disabled);
\item INT_VAR \verb+fj_trap_detect+ to the trap detection difficulty percentage;
\item INT_VAR \verb+fj_trap_remove_diff+ to the trap removal difficulty percentage (default 100);
\item INT_VAR \verb+fj_trap_active+ to whether the container is trapped (0=no, 1=yes);
\item INT_VAR \verb+fj_trap_status+ to whether the trap is detected (0=no, 1=yes);
\item INT_VAR \verb+fj_trap_loc_x+ to the trap launch X coordinate*;
\item INT_VAR \verb+fj_trap_loc_y+ to the trap launch Y coordinate*;
\item INT_VAR \verb+fj_box_left+ to the leftmost X coordinate of the trap's bounding box;
\item INT_VAR \verb+fj_box_top+ to the topmost Y coordinate of the trap's bounding box;
\item INT_VAR \verb+fj_box_right+ to the rightmost X coordinate of the trap's bounding box;
\item INT_VAR \verb+fj_box_bottom+ to the bottommost Y coordinate of the trap's bounding box;
\item STR_VAR \verb+fj_trap_script+ to the trap's script;
\item INT_VAR \verb+fj_vertex_0+ to (X coordinate + (Y coordinate << 16)) for each vertex pair*;
\item STR_VAR \verb+fj_key_resref+ to the filename of the container's key;
\item INT_VAR \verb+fj_lockpick_strref+ to the lockpick string reference (default -1);
\end{itemize}
Item structure variables:
\begin{itemize}
\item STR_VAR \verb+fj_name+ to the item's resource reference (filename)*;
\item INT_VAR \verb+fj_con_itm_idx+ to the index of the container to which the item is added*;
\item INT_VAR \verb+fj_itm_expiry+ to the item expiration time (default 0);
\item INT_VAR \verb+fj_charge0+ to the charges of the 1st ability (item quantity for stackables, default 0);
\item INT_VAR \verb+fj_charge1+ to the charges of the 2nd ability (default 0);
\item INT_VAR \verb+fj_charge2+ to the charges of the 3rd ability (default 0);
\item INT_VAR \verb+fj_flags+ to the bitwise item flags (bit0=identified, bit1=unstealable, bit2=stolen, bit3=undroppable, default 0);
\end{itemize}
Ambient structure variables:
\begin{itemize}
\item STR_VAR \verb+fj_name+ to the ambient's name*;
\item INT_VAR \verb+fj_loc_x+ to the X coordinate*;
\item INT_VAR \verb+fj_loc_y+ to the Y coordinate*;
\item INT_VAR \verb+fj_radius+ to the sound radius (default 500);
\item INT_VAR \verb+fj_loc_z+ to the Z coordinate (height);
\item INT_VAR \verb+fj_pitch_variance+ to the pitch variance;
\item INT_VAR \verb+fj_volume_variance+ to the volume variance;
\item INT_VAR \verb+fj_volume+ to the volume percentage (default 80);
\item STR_VAR \verb+fj_wav_resref0+ to the resource reference of each sound (0-9)*;
\item INT_VAR \verb+fj_sound_num+ to the number of sounds*;
\item INT_VAR \verb+fj_delay+ to the base interval in seconds between sounds from this ambient list;
\item INT_VAR \verb+fj_variation+ to the base deviation from the base interval;
\item INT_VAR \verb+fj_schedule+ to the hourly appearance schedule (bits 0-23, default -1 or always);
\item INT_VAR \verb+fj_flags+ to the bitwise ambient flags*;
\end{itemize}
Variable structure variables:
\begin{itemize}
\item STR_VAR \verb+fj_name+ to the variable's name*;
\item INT_VAR \verb+fj_variable_value+ to the variable's value*;
\end{itemize}
Door structure variables:
\begin{itemize}
\item STR_VAR \verb+fj_name+ to the door's name*;
\item STR_VAR \verb+fj_door_wed_id+ to the door ID linked to the .wed file*;
\item INT_VAR \verb+fj_flags+ to the bitwise door flags*;
\item INT_VAR \verb+fj_open_box_left+ to the leftmost X coordinate of the open door's bounding box*;
\item INT_VAR \verb+fj_open_box_top+ to the topmost Y coordinate of the open door's bounding box*;
\item INT_VAR \verb+fj_open_box_right+ to the rightmost X coordinate of the open door's bounding box*;
\item INT_VAR \verb+fj_open_box_bottom+ to the bottommost Y coordinate of the open door's bounding box*;
\item INT_VAR \verb+fj_closed_box_left+ to the leftmost X coordinate of the closed door's bounding box*;
\item INT_VAR \verb+fj_closed_box_top+ to the topmost Y coordinate of the closed door's bounding box*;
\item INT_VAR \verb+fj_closed_box_right+ to the rightmost X coordinate of the closed door's bounding box*;
\item INT_VAR \verb+fj_closed_box_bottom+ to the bottommost Y coordinate of the closed door's bounding box*;
\item INT_VAR \verb+fj_door_open_vert_0+ to (X coordinate + (Y coordinate << 16)) for each vertex pair of the open door*;
\item INT_VAR \verb+fj_door_closed_vert_0+ to (X coordinate + (Y coordinate << 16)) for each vertex pair of the closed door*;
\item INT_VAR \verb+fj_cell_open_vert_0+ to (X coordinate + (Y coordinate << 16)) for each impeded search map cell of the open door*;
\item INT_VAR \verb+fj_cell_closed_vert_0+ to (X coordinate + (Y coordinate << 16)) for each impeded search map cell of the closed door*;
\item STR_VAR \verb+fj_door_open_wav+ to the door open sound;
\item STR_VAR \verb+fj_door_close_wav+ to the door closed sound;
\item INT_VAR \verb+fj_cursor_idx+ to the door's mouse cursor index (from cursors.bam)*;
\item INT_VAR \verb+fj_trap_detect+ to the trap detection difficulty percentage;
\item INT_VAR \verb+fj_trap_remove+ to the trap removal difficulty percentage;
\item INT_VAR \verb+fj_trap_active+ to whether the door is trapped (0=no, 1=yes);
\item INT_VAR \verb+fj_trap_status+ to whether the trap is detected (0=no, 1=yes);
\item INT_VAR \verb+fj_trap_loc_x+ to the trap launch X coordinate*;
\item INT_VAR \verb+fj_trap_loc_y+ to the trap launch Y coordinate*;
\item STR_VAR \verb+fj_key_resref+ to the filename of the door's key;
\item STR_VAR \verb+fj_door_script+ to the door script;
\item INT_VAR \verb+fj_detect_diff+ to the detection difficulty (for secret doors);
\item INT_VAR \verb+fj_locked_diff+ to the lock difficulty;
\item INT_VAR \verb+fj_open_loc_x+ to the X coordinate for toggling the door's open state*;
\item INT_VAR \verb+fj_open_loc_y+ to the Y coordinate for toggling the door's open state*;
\item INT_VAR \verb+fj_closed_loc_x+ to the X coordinate for toggling the door's closed state*;
\item INT_VAR \verb+fj_closed_loc_y+ to the Y coordinate for toggling the door's closed state*;
\item INT_VAR \verb+fj_lockpick_strref+ to the lockpick string reference (default -1);
\item STR_VAR \verb+fj_travel_trigger+ to the travel region name*;
\item INT_VAR \verb+fj_dlg_strref+ to the dialogue string reference (default -1);
\item STR_VAR \verb+fj_dlg_resref+ to the door's dialogue file;
\end{itemize}
Animation structure variables:
\begin{itemize}
\item STR_VAR \verb+fj_name+ to the animation name*;
\item INT_VAR \verb+fj_loc_x+ to the X coordinate*;
\item INT_VAR \verb+fj_loc_y+ to the Y coordinate*;
\item INT_VAR \verb+fj_schedule+ to the hourly appearance schedule (bits 0-23, default -1 or always);
\item STR_VAR \verb+fj_bam_resref+ to the animation resource reference (filename)*;
\item INT_VAR \verb+fj_bam_seq+ to the BAM sequence number;
\item INT_VAR \verb+fj_bam_frame+ to the BAM frame number;
\item INT_VAR \verb+fj_flags+ to the bitwise animation flags*;
\item INT_VAR \verb+fj_loc_z+ to the height;
\item INT_VAR \verb+fj_transparent+ to the BAM transparency;
\item INT_VAR \verb+fj_init_frame+ to the starting frame;
\item INT_VAR \verb+fj_loop_chance+ to the chance of looping;
\item INT_VAR \verb+fj_skip_cycles+ to start delay in frames;
\item STR_VAR \verb+fj_bmp_resref+ to the palette bitmap;
\end{itemize}
Bitmask structure variables:
\begin{itemize}
\item STR_VAR \verb+fj_bitmask+ to ~path/to/binary.file~*;
\end{itemize}
Songlist structure variables:
\begin{itemize}
\item INT_VAR \verb+fj_song_day+ to the day SONGLIST.2DA entry;
\item INT_VAR \verb+fj_song_night+ to the night SONGLIST.2DA entry;
\item INT_VAR \verb+fj_song_victory+ to the victory SONGLIST.2DA entry;
\item INT_VAR \verb+fj_song_battle+ to the battle SONGLIST.2DA entry;
\item INT_VAR \verb+fj_song_defeat+ to the defeat SONGLIST.2DA entry;
\item STR_VAR \verb+fj_song_day0+ to the day song WAV resref;
\item STR_VAR \verb+fj_song_day1+ to the night song WAV resref;
\item INT_VAR \verb+fj_song_day_vol+ to the day songs volume (default 100);
\item STR_VAR \verb+fj_song_night0+ to the night song WAV resref;
\item STR_VAR \verb+fj_song_night1+ to the second night song WAV resref;
\item INT_VAR \verb+fj_song_night_vol+ to the night songs volume (default 100);
\end{itemize}
Rest interrupt structure variables
\begin{itemize}
\item STR_VAR \verb+fj_name+ to the name of the rest interrupts (for editor use only);
\item INT_VAR \verb+fj_cre_strref0...fj_cre_strref9+ to string displayed upon party ambush (default -1);
\item STR_VAR \verb+fj_cre_resref0...fj_cre_resref9+ to creature resref;
\item STR_VAR \verb+fj_spawn_num+ to the number of spawned attackers;
\item STR_VAR \verb+fj_difficulty+ to the difficulty of the encounter;
\item STR_VAR \verb+fj_duration+ to the creature's duration (default 1000);
\item STR_VAR \verb+fj_wander_distance+ to the creature's random walk distance limit (default 1000);
\item STR_VAR \verb+fj_mvmt_distance+ to the creature's movement distance limit (default 1000);
\item STR_VAR \verb+fj_max_num+ to maximum number of spawned creatures;
\item STR_VAR \verb+fj_enable+ to whether rest interrupts are enabled (0=no, 1=yes);
\item STR_VAR \verb+fj_day_prob+ to probability of daytime ambush;
\item STR_VAR \verb+fj_night_prob+ to probability of nightime ambush;
\end{itemize}
Map note structure variables:
\begin{itemize}
\item INT_VAR \verb+fj_loc_x+ to the X coordinate*;
\item INT_VAR \verb+fj_loc_y+ to the Y coordinate*;
\item INT_VAR \verb+fj_note_strref+ to the note string reference (default -1, BGII only)*;
\item STR_VAR \verb+fj_note_text+ to the note text (PST only)*;
\item INT_VAR \verb+fj_strref_loc+ to the strref location (0=external, 1=dialog.tlk, default 1);
\item INT_VAR \verb+fj_color+ to the map marker color (0-7);
\item INT_VAR \verb+fj_note_id+ to the note ID;
\end{itemize}
Projectile trap structure variables (not available on PST):
\begin{itemize}
\item STR_VAR \verb+fj_name+ to the projectile filename*;
\item INT_VAR \verb+fj_eff_off+ to the effect block offset;
\item INT_VAR \verb+fj_eff_size+ to the effect block size;
\item INT_VAR \verb+fj_missile_num+ to the missile.ids reference (projectl.ids - 1);
\item INT_VAR \verb+fj_frequency+ to the explosion length (in frames);
\item INT_VAR \verb+fj_duration+ to the number of explosions;
\item INT_VAR \verb+fj_loc_x+ to the X coordinate*;
\item INT_VAR \verb+fj_loc_y+ to the Y coordinate*;
\item INT_VAR \verb+fj_loc_z+ to the height;
\item INT_VAR \verb+fj_target+ to the target ID;
\item STR_VAR \verb+fj_embedded_eff0+ to ~path/to/v2.eff~ or eff resref containing to projectile's effects*;
\end{itemize}
A few examples best illustrate the use of this function.

Example 1: add an actor to an area
\begin{verbatim}
COPY_EXISTING ar0500.are override
  LPF fj_are_structure
    INT_VAR
    fj_loc_x          = 2780
    fj_loc_y          = 1955
    fj_dest_x         = 2780
    fj_dest_y         = 1955
    fj_animation      = 0x6110 //fighter female human
    fj_orientation    = 15     //SSE
    STR_VAR
    fj_structure_type = actor
    fj_name           = Aurora
    fj_cre_resref     = agaurora
  END
\end{verbatim}
Example 2: add a region to an area (in this case, a travel trigger to another area)
\begin{verbatim}
  LPF fj_are_structure
    INT_VAR
    fj_type         = 2    //travel
    fj_box_left     = 3415
    fj_box_top      = 625
    fj_box_right    = 3450
    fj_box_bottom   = 700
    fj_cursor_idx   = 30   //door
    fj_vertex_0     = 3415 + (625 << 16)
    fj_vertex_1     = 3450 + (650 << 16)
    fj_vertex_2     = 3450 + (700 << 16)
    fj_vertex_3     = 3415 + (676 << 16)
    STR_VAR
    fj_structure_type   = region
    fj_name             = Tran0540
    fj_destination_area = ag0540
    fj_destination_name = Exit0500
  END
\end{verbatim}
Example 3: add an entrance (from another area) to an area
\begin{verbatim}
  LPF fj_are_structure
    INT_VAR
    fj_loc_x       = 3490
    fj_loc_y       = 655
    fj_orientation = 10   //NE
    STR_VAR
    fj_structure_type = entrance
    fj_name           = Exit0540
  END
\end{verbatim}
Example 4: add a container to an area, then add an item to the new container
\begin{verbatim}
  LPF fj_are_structure
    INT_VAR
    fj_type        = 8 //nonvisible
    fj_loc_x       = 4388
    fj_loc_y       = 2876
    fj_box_left    = 4372
    fj_box_top     = 2826
    fj_box_right   = 4420
    fj_box_bottom  = 2858
    fj_trap_loc_x  = 4380
    fj_trap_loc_y  = 2870
    fj_vertex_0    = 4411 + (2858 << 16)
    fj_vertex_1    = 4372 + (2845 << 16)
    fj_vertex_2    = 4382 + (2826 << 16)
    fj_vertex_3    = 4420 + (2839 << 16)
    STR_VAR
    fj_structure_type = container
    fj_name           = ~Cornerstone~
  END
  LPF fj_are_structure
    INT_VAR
    fj_con_itm_idx    = SHORT_AT 0x74 - 1 // a new container will be last in the file
    fj_flags          = 1 // identified
    STR_VAR
    fj_name           = c6lantho
    fj_structure_type = itm
  END
\end{verbatim}
Example 5: add a door to an area
\begin{verbatim}
  LPF fj_are_structure
    INT_VAR
    fj_flags               = 0b100000000
    fj_open_box_left       = 520
    fj_open_box_top        = 724
    fj_open_box_right      = 545
    fj_open_box_bottom     = 830
    fj_closed_box_left     = 507
    fj_closed_box_top      = 761
    fj_closed_box_right    = 562
    fj_closed_box_bottom   = 869
    fj_cursor_idx          = 30
    fj_trap_loc_x          = 500
    fj_trap_loc_y          = 852
    fj_open_loc_x          = 517
    fj_open_loc_y          = 881
    fj_closed_loc_x        = 562
    fj_closed_loc_y        = 814
    fj_door_open_vert_0    = 520 + (826 << 16)
    fj_door_open_vert_1    = 527 + (830 << 16)
    fj_door_open_vert_2    = 545 + (798 << 16)
    fj_door_open_vert_3    = 545 + (727 << 16)
    fj_door_open_vert_4    = 539 + (724 << 16)
    fj_door_open_vert_5    = 520 + (750 << 16)
    fj_door_closed_vert_0  = 507 + (831 << 16)
    fj_door_closed_vert_1  = 562 + (869 << 16)
    fj_door_closed_vert_2  = 562 + (799 << 16)
    fj_door_closed_vert_3  = 507 + (761 << 16)
    fj_cell_open_vert_0    = 32 + (68 << 16)
    fj_cell_open_vert_1    = 33 + (67 << 16)
    fj_cell_open_vert_2    = 32 + (67 << 16)
    fj_cell_closed_vert_0  = 32 + (70 << 16)
    fj_cell_closed_vert_1  = 33 + (71 << 16)
    fj_cell_closed_vert_2  = 34 + (72 << 16)
    fj_cell_closed_vert_3  = 34 + (71 << 16)
    fj_cell_closed_vert_4  = 33 + (70 << 16)
    fj_cell_closed_vert_5  = 32 + (69 << 16)
    fj_cell_closed_vert_6  = 32 + (68 << 16)
    fj_cell_closed_vert_7  = 33 + (69 << 16)
    fj_cell_closed_vert_8  = 34 + (70 << 16)
    STR_VAR
    fj_structure_type      = door
    fj_name                = Door10
    fj_door_wed_id         = DOOR10
  END
\end{verbatim}
Example 6: add an animation to an area
\begin{verbatim}
  LPF fj_are_structure
    INT_VAR
    fj_loc_x       = 2785
    fj_loc_y       = 949
    fj_flags       = 0b00000000000000000001000110000101
    //visible, not illuminated, invisible in dark, covered by actors, shown in combat
    STR_VAR
    fj_structure_type = animation
    fj_name           = Cave1
    fj_bam_resref     = ag1100c1
  END
\end{verbatim}
Example 7: delete all ambients from an area
\begin{verbatim}
  FOR( i = SHORT_AT 0x82 ; i ; --i )BEGIN
    LPF fj_are_structure
      INT_VAR fj_delete_mode = i - 1
      STR_VAR fj_structure_type = ambient
    END
  END
\end{verbatim}



\subsection{\DEFINE{scflnumberaddWmpAre}}
Adds an area to the worldmap. All variables are zero or blank by default unless otherwise indicated.
This is an ACTION function.

\begin{itemize}
\item ACTION_DEFINE_ASSOCIATIVE_ARRAY \verb+toNewArea+ to the area references that lead to the new area;
\item ACTION_DEFINE_ASSOCIATIVE_ARRAY \verb+fromNewArea+ to the area references that lead away from the new area;
\item STR_VAR \verb+areName+ to the resource reference of the area to add (like "ar0700");
\item STR_VAR \verb+strName+ to the descriptive name of the area (like "Waukeen's Promenade");
\item STR_VAR \verb+strDesc+ to the area description that will show up when hovering the cursor over the area on the worldmap;
\item STR_VAR \verb+worldmap+ to the name of the .wmp file you want patched (default is "worldmap");
\item INT_VAR \verb+mapIcon+ to the area's map icon index (from mapicons.bam);
\item INT_VAR \verb+xCoord+ to the area's X (east-west) coordinate;
\item INT_VAR \verb+yCoord+ to the area's Y (north-south) coordinate;
\item INT_VAR \verb+tTime+ to the area's travel time in hours * 4 (so 2 = 8 hours);
\item INT_VAR \verb+inclSv+ to 1 if you want to patch saved game worldmaps as well as the master worldmap. \textbf{NB:} changes to saved games are uninstallable;
\item INT_VAR \verb+visible+ to 1 if you want the 'visible' flag to be set;
\item INT_VAR \verb+visibleAdjacent+ to 1 if you want the 'visible from adjacent' flag to be set;
\item INT_VAR \verb+reachable+ to 1 if you want the 'reachable' flag to be set;
\item INT_VAR \verb+visited+ to 1 if you want the 'visited' flag to be set;
\item RET \verb+areNum+ returns the worldmap entry number for the new area;
\end{itemize}
An example best illustrates the use of this function.

\begin{verbatim}
// add links from these area(s) to the new area
ACTION_DEFINE_ASSOCIATIVE_ARRAY toNewArea BEGIN
  "AR0020" => "Exitwmp"       // City Gates
  "AR0300" => "Exitwmp"       // Docks
  "AR0400" => "Exitwmp"       // Slums
  "AR0500" => "Exitwmp"       // Bridge District
  "AR0700" => "Exitwmp"       // Waukeen's Promenade
  "AR0800" => "Exitwmp"       // Graveyard
  "AR0900" => "Exitwmp"       // Temple District
  "AR1000" => "Exitwmp"       // Government
  "AR1100" => "Exitwmp"       // Umar Hills
  "AR1300" => "Exitwmp"       // d'Arnise Keep
  "AR1304" => "Exitwmp"       // d'Arnise Keep
  "AR2000" => "Exitwmp"       // Trademeet
  "AR1200" => "Exitwmp"       // Windspear Hills
END

// add links from the new area to these area(s)
ACTION_DEFINE_ASSOCIATIVE_ARRAY fromNewArea BEGIN
  "AR0020" => "ExitNE"      // City Gates
  "AR0300" => "ExitN"       // Docks
  "AR0400" => "ExitN"       // Slums
  "AR0500" => "ExitNE"      // Bridge District
  "AR0700" => "ExitE"       // Waukeen's Promenade
  "AR0800" => "ExitS"       // Graveyard
  "AR0900" => "ExitNW"      // Temple District
  "AR1000" => "ExitN"       // Government
  "AR1100" => "ExitSE"      // Umar Hills
  "AR1300" => "ExitSE"      // d'Arnise Keep
  "AR1304" => "ExitSE"      // d'Arnise Keep
  "AR2000" => "ExitSW"      // Trademeet
  "AR1200" => "ExitW"       // Windspear Hills
END

// calls the function and returns the worldmap entry number for the new area
LAUNCH_ACTION_FUNCTION sc#addWmpAre
    INT_VAR mapIcon = 21           // map icon
            xCoord  = 240          // x coordinate
            yCoord  = 130          // y coordinate
            tTime   = 0            // travel time *4, so two means eight hours

    STR_VAR areName = "YS0390"     // area reference, like "AR0700"
            strName = "Govt. West" // area name, like "Waukeen's Promenade"
            strDesc = "Govt. West" // area description which will show up when hovering the area on the worldmap

END
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec-module-distribution}\section{\DEFINE{Module Distribution}: \t{Setup-MyMod.exe}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

If you rename \t{WeiDU.EXE} to something of the form \t{Setup-MyMod.exe},
it will behave as if the following arguments were present:
\begin{itemize}
\item \t{--log Setup-MyMod.DEBUG}
\item \t{Mymod/MyMod.tp2}
\item \t{Mymod/Setup-MyMod.tp2}
\item \t{MyMod.tp2}
\item \t{Setup-MyMod.tp2}
\end{itemize}

\subsection{Module Distribution Conventions}

To distribute your mod, rename \t{WeiDU.EXE} to \t{Setup-MyMod.EXE} (or
whatever), put \t{Setup-MyMod.TP2} file in the same directory and go!
Typically mods are distributed a ZIP files or self-extracting archives that
put the \t{EXE}, \ttref{TP2} and module data files in the main BGII
directory.

If your mod adds new resources to the game (e.g., via \ttref{COPY}) you
should be careful to pick a unique name so that you resource will not
conflict with one created by another mod. For example (and I speak from
personal experience here), naming a creature \t{BOO2.CRE} is just asking
for trouble. One common approach here is to pick a special prefix that uses
a character not found in normal game resources. For example, I might use
the prefix \t{W\#} and call a sword \t{W\#SWORD.ITM}
and a new spell \t{W\#SPELL.SPL}. However, it it still possible to run into
conflicts, so I recommend that you check out the
Community Mod Filename Prefix Reservations project at
\ahrefurl{http://forums.blackwyrmlair.net/index.php?showtopic=113} and
register your own unique prefix.

\subsection{WeiDU Return Values}

The \t{WeiDU.exe} (or \t{Setup-MyMod.exe}) process will terminate with
a ``return value'' (or ``exit code'' or ``status code'' or ``error level'')
based on the success or failure of certain operations. Depending on your
operating system you can use this value to guide shell scripts or batch
files that include WeiDU. In general, WeiDU returns 0 on success and
non-zero on failure. Here is a concrete list of return values.

\begin{itemize}
\item 0. General Success. No other error on this list was noticed.
\item 1. Invalid command-line argument.
\item 2. A \ttref{TP2} \ttref{Component} failed to install.
    A failed installation is one that displays a message like
    ``\t{Stopping installation because of error}'' or
    ``\t{ERROR Installing [Component], rolling back to previous state}'' or
    ``\t{PLEASE email the file SETUP-MYMOD.DEBUG to AUTHOR}'' or
    ``\t{ERROR Re-Installing [MyMod] component 1}''.
\item 3. A \ttref{TP2} \ttref{Component} installed with warnings. A
  warning is generally a non-terminal error that may, but need not
  necessarily, indicate problems.
\item 4. Parsing error. This is generally used when WeiDU fails to
  parse a \ttref{TP2} file.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Regular Expressions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A regular expression or \DEFINE{regexp} is "somewhat" like a DOS wildcard
but not quite. The big difference is that if you would say * in DOS you say
.* in regexp-land.  Here's a definition:

The syntax for regular expressions is the same as in Gnu Emacs. The special
characters are:
\begin{verbatim}
$^.*+?[]\
\end{verbatim}

The following constructs are recognized:
\begin{verbatim}
   .      matches any character except newline
   *      (postfix) matches the previous expression zero, one or several times
   +      (postfix) matches the previous expression one or several times
   ?      (postfix) matches the previous expression once or not at all
   [..]   character set; ranges are denoted with -, as in [a-z];
          an initial ^, as in [^0-9], complements the set
   ^      matches at beginning of line
   $      matches at end of line
   \|     (infix) alternative between two expressions
   \(..\) grouping and naming of the enclosed expression
   \1     the text matched by the first \(...\) expression
          (\2 for the second expression, etc)
   \b     matches word boundaries
   \      quotes special characters.
\end{verbatim}

So spe.* matches "sper01.itm" and "sper.eff" and "special".

Hopefully this is understandable to most people.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec-constant}\section{WeiDU \DEFINE{constant}s}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The following keywords can be used in \t{value}s and evaluate to the given
integer (usually an offset in a \ttref{CRE} file).

\begin{verbatim}
// KEYWORD VALUE
AREA_CITY 0252
AREA_DAY 0260
AREA_DUNGEON 0256
AREA_FOREST 0248
AREA_NIGHT 0264
ATTACK1 0220
ATTACK2 0224
ATTACK3 0228
ATTACK4 0232
BATTLE_CRY1 0200
BATTLE_CRY2 0204
BATTLE_CRY3 0208
BATTLE_CRY4 0212
BATTLE_CRY5 0216
BIO  0x1cc
BORED 0196
COMPLIMENT1 0352
COMPLIMENT2 0356
COMPLIMENT3 0360
CRITICAL_HIT 0424
CRITICAL_MISS 0428
DAMAGE 0236
DESC  0x54
DIALOGUE_DEFAULT 0412
DIALOGUE_HOSTILE 0408
DYING 0240
EXISTANCE1 0444
EXISTANCE2 0448
EXISTANCE3 0452
EXISTANCE4 0456
EXISTANCE5 0460
HAPPY 0172
HURT 0244
IDENTIFIED_DESC  0x54
INITIAL_MEETING 0164
INSULT 0340
INTERACTION1 0320
INTERACTION2 0324
INTERACTION3 0328
INTERACTION4 0332
INTERACTION5 0336
INVENTORY_FULL 0436
LEADER 0188
MISCELLANEOUS 0384
MORALE 0168
NAME1 8
NAME2 12
PICKED_POCKET 0440
REACT_TO_DIE_GENERAL 0376
REACT_TO_DIE_SPECIFIC 0380
RESPONSE_TO_COMPLIMENT2 0388
RESPONSE_TO_COMPLIMENT3 0392
RESPONSE_TO_INSULT1 0396
RESPONSE_TO_INSULT2 0400
RESPONSE_TO_INSULT3 0404
SELECT_ACTION1 0292
SELECT_ACTION2 0296
SELECT_ACTION3 0300
SELECT_ACTION4 0304
SELECT_ACTION5 0308
SELECT_ACTION6 0312
SELECT_ACTION7 0316
SELECT_COMMON1 0268
SELECT_COMMON2 0272
SELECT_COMMON3 0276
SELECT_COMMON4 0280
SELECT_COMMON5 0284
SELECT_COMMON6 0288
SELECT_RARE1 0416
SELECT_RARE2 0420
SPECIAL1 0364
SPECIAL2 0368
SPECIAL3 0372
TARGET_IMMUNE 0432
TIRED 0192
UNHAPPY_ANNOYED 0176
UNHAPPY_BREAKING 0184
UNHAPPY_SERIOUS 0180
UNIDENTIFIED_DESC 0080
HIDDEN_IN_SHADOWS 0444
SPELL_DISRUPTED 0448
SET_A_TRAP 0452
STORE_NAME 12

SCRIPT_OVERRIDE 0x248
SCRIPT_CLASS 0x250
SCRIPT_RACE 0x258
SCRIPT_GENERAL 0x260
SCRIPT_DEFAULT 0x268
DEATHVAR 0x280
DIALOG 0x2cc
AREA_SCRIPT 0x94

BIT0  0b00000000000000000000000000000001
BIT1  0b00000000000000000000000000000010
<snip>
BIT31 0b10000000000000000000000000000000
\end{verbatim}

\verb+WNL "\r\n"+ // Windows new line\\
\verb+MNL "\r"+ // (pre-OSX) Macintosh new line\\
\verb+LNL "\n"+ // Linux/Unix/OSX new line\\
\verb+TAB "\t"+ // tabulation character

\verb+REGISTRY_BG1_PATH+ the path of BG1 (as read from the registry),
or empty if not available.\\

\verb+REGISTRY_BG2_PATH+ ditto for BG2.\\
\verb+REGISTRY_PST_PATH+ ditto for PST.\\
\verb+REGISTRY_IWD1_PATH+ ditto for IWD1.\\
\verb+REGISTRY_IWD2_PATH+ ditto for IWD2.

\verb+USER_DIRECTORY+ evaluates to the directory in which user files
are kept. This is the game path on non-EE-type games. On EE-type
games, the \verb+USER_DIRECTORY+ variable is constructed from two
parts, the user directory and a game-specific directory. If the file
engine.lua exists, WeiDU will attempt to read the game-specific
directory from it. If the engine.lua does not exist or does not
contain the necessary information, WeiDU will use default paths.  On
Windows, the user directory is the user's personal directory, as read
from the Windows registry. On macOS, the user directory is
"\$HOME/Documents". On Linux, the user directory is
"\$HOME/.local/share". In both cases, \$HOME is the user's home
directory, as read from the pwd database. The default game-specific
path for BG: EE is "Baldur's Gate - Enhanced Edition"; for BGII: EE it
is "Baldur's Gate II - Enhanced Edition"; for IWD: EE it is
"Icewind Dale - Enhanced Edition"; and for PST: EE it is
"Planescape Torment - Enhanced Edition".

\verb+SAVE_DIRECTORY+ evaluates to the directory in which the current
game type stores its saved games. This is
"\%\verb+USER_DIRECTORY+\%/save".

\verb+MPSAVE_DIRECTORY+ evaluates to the directory in which the
current game type stores its multiplayer saved games. The
determination is done the same way as with the save directory, but for
the directory mpsave instead.

\verb+EE_LANGUAGE+ evaluates to the Enhanced Edition language
directory the user has selected, for example, \verb+en_US+. This
variable is undefined on non-EE games.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Common File Formats}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This section briefly explains some common file formats. The definitive
reference is
\ahrefurl{\url{http://gibberlings3.net/iesdp/}}.

\begin{itemize}

\item \DEFINE{2DA}. A 2DA file is a text file that includes some game rules
or file information. Kits, music, weapon proficiencies and experience point
caps are all controlled by 2DA files.

\item \DEFINE{ARE}. The ARE file format describes the content of an area
(rather than its visual representation). ARE files contain the list of actors,
items, entrances and exits, spawn points and other area-associated info.
The ARE file may contain references to other files, e.g. the list of items
in a container is stored in the ARE file, however the files themselves are
not embedded in the ARE file.

\item \DEFINE{BAM}. This file format describes animated graphics. Such files
are used for animations (both creature animations, item and spell animations)
and interactive GUI elements (e.g. buttons) and for logical collections of
images (e.g. fonts). BAM files can contain multiple sequences of animations,
up to a limit of 255.

\item \DEFINE{BIFF}. A BIFF file is like a big ZIP file that contains other
files. Basically every file used by an Infinity Engine game is either in a
BIFF somewhere or in the \t{override} folder.

\item \DEFINE{BCS}. An Infinity Engine script. These are used to control
the actions of creatures and areas. They are basically big lists of
\t{IF}s. \ttref{D} files (and also \ttref{DLG} files) use the same
predicate and action syntax as BCS files.

\item \DEFINE{CRE}. This file format describes a "creature". Creatures can
move, have an animation, hold items, run scripts, cast spells and initiate
dialog. Creatures have several stats (some visible through the game UI) which
are generally mapped to IDS or 2DA files.

\item \DEFINE{EFF}. An Infinity Engine effect file. These are sometimes used
by \ttref{ITM}s or \ttref{SPL}s to do one specific thing. You probably
won't use them.

\item \DEFINE{GAM}. This file format is used to hold game information in save
games. The GAM file does not store area, creature or item information, instead,
it stores information on the party members and the global variables which affect
party members.

\item \DEFINE{ITM}. An Infinity Engine item definition file. Notably,
\ttref{ITM} files have identified and unidentified names that are often set
using the \ttref{TP2 Action} \ttref{COPY}.

\item \DEFINE{KEY}. A KEY file is an index into \ttref{BIFF} files. Given a
resource (like \t{sw1h01.itm}) you can use the KEY file to find out where
it is in the \ttref{BIFF}s. The default KEY file is \t{CHITIN.KEY}.

\item \DEFINE{SPL}. An Infinity Engine spell definition file. Spells have
names that are often set using the \ttref{TP2 Action} \ttref{COPY}.

\item \DEFINE{TLK}. A TLK file is basically a big array of strings. Items
and spells and dialogues in the game have references into this big array
instead of having actual text in them. So a sword item doesn't have the
text "Longsword" anywhere in it. Instead if says "use strref \#1234 for my
name". The game looks up the \#1234th entry in the TLK file and prints that
on the screen. The default TLK file is called \t{\t{DIALOG.}\ttref{TLK}}.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Source Code}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The source code to WeiDU is available under the GNU General Public License,
as detailed in the file \t{COPYING}. If for some reason you are unable to
obtain a copy of the GPL, merely announce that fact on some public forum
and your mailbox will be full of copies of it for life. It's a great way to
meet new people.

Since this is the world of Windows, I distribute a pre-compiled binary.
WeiDU is written in OCaml, a functional programming language that includes
automatic memory management, higher-order functions and efficient native
code generation. If these terms mean nothing to you, you probably won't be
able to modify the source code.

Building WeiDU on Windows requires OCaml 4.01 or more recent, Cygwin and the
elkhound program. The OCaml installer can install the required Cygwin
packages.

WeiDU can also be built on x86/x86-64 GNU/Linux and PPC OS X. The exact status
on building WeiDU on x86/x86-64 OS X is not known, but there have been reports
of success.

WeiDU uses a Make system that aims to correctly auto-configure itself, through
the file \t{Configuration}.

WeiDU uses the GPL'd \t{zlib} and \t{xdiff} libraries, as well as portions from
the GPL'd \t{ocaml, batteries included} library.

Elkhound is available as source code under a BSD licence and as
pre-compiled x86 executables for Windows and GNU/Linux (built on
Debian Squeeze).

For more information, please refer to the forum.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\DEFINE{Special Thanks}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{\em Weimer's thank you}:
I would like to thank the fine folks at the Infinity Engine File Format
Hacking Project, without which this would not have been possible:
\ahrefurl{\url{http://gibberlings3.net/iesdp/}}.

In addition, I make heavy use of Near Infinity for general IE mods: \ahrefurl{\url{http://www.idi.ntnu.no/~joh/ni/}}.

The Infinity Engine Editor Pro was very good at changing \ttref{ITM}s and
\ttref{SPL}s, but DLTCEP is now a better choice:
\ahrefurl{\url{http://gibberlings3.net/tools/dltcep.php}}.

Kudos to my main out-of-house developer:
\begin{itemize}
\item Fred S. Richardson (he slices, he dices, he sends diffs!)
\item Japheth (also sends diffs!)
\end{itemize}

Special thanks to my main bug-finders *cough* I mean beta-testers:
\begin{itemize}
\item {\em Jason Compton }
\item Ghreyfain
\item Michael Lyashenko
\item Quitch
\item Dyara
\item M
\item Rene Heroux
\item Avenger TeamBG
\item Sim
\item devSin

\end{itemize}

Special thanks to Greg Henry for being the first person to mention WeiDU to
me in a face-to-face conversation. I was quite impressed. Jason Compton is
the first person to mention WeiDU to me in a telephone conversation. Scott
McPeak is the first person to discuss my modding hobby with me in a
face-to-face conversation (and he was quite well-informed).

The Bigg would additionally like to thank the following contributors:
\begin{itemize}
\item DevSin (also sends diffs and tests and compiles!)
\item cmorgan for his excellent throughput while testing.
\item Taimon (also sends diffs and tests!)
\item Gort (sends tp2 macros!)
\item vit-mg (sends documentation!)
\item Mike1072 (sends documentation and tp2 macros/functions!)
\item plainab {sends tp2 macros!}
\item wisp (sends documentation and tp2 macros/functions!)
\item Miloch (sends documentation and tp2 macros/functions!)
\item SConrad (sends tp2 functions!)
\item Nythrun (sends tp2 functions!)
\item Galactycon (sends tp2 macros!)
\end{itemize}
and additionally
\begin{itemize}
\item {\em Weimer} for having written (and maintained) the excellent WeiDU,
and having offered it freely (both as free beer and freedom) to the gaming
community.
\item All the people I've been modding with, all the people who played my mods,
and all of the BG modding community, for having been a very friendly community
(and, in some cases, even very good friends) in these last four years (or more,
this part was written in Jun 2008). It's for you that I've learned OcaML and
started editing WeiDU.
\end{itemize}

Wisp would like to extend further thanks to the following people:
\begin{itemize}
\item CamDawg (sends documentation and tp2 functions)
\item Nifft (sends compiles)
\item Antonio Favata, a.k.a. alnair (sends compiles)
\item Almateria (sends compiles)
\item Nicols Clotta aka Crevs Daak (sends compiles)
\item Argent77 (sends tp2 functions and compiles)
\end{itemize}
and also The Bigg, for having developed and maintained BiggDU for many years and, while doing so, having significantly improved upon its workings and functionality.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Informal Copyright Notice}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
WeiDU was originally made by Westley Weimer. It was subsequently significantly
improved upon in accordance with the GPL terms by Valerio Bigiani, AKA The Bigg,
starting from version 186 (which was a closed beta, while the first public
release was the 187 one). Starting from version 232 (version 231.06 to be more precise),
maintenance and development was assumed by Fredrik Lindgren, a.k.a Wisp.

What this means is that all praise and credits should go to Weimer and Bigiani,
but all bug reports and feature requests should go to Fredrik Lindgren (a.k.a Wisp).

Since WeiDU was released under the GPL, with an added notice that you are also
allowed to distribute unmodified binaries, I assume the same holds true for
mods distributed with this version of WeiDU. However, if you feel like being
nice add a line in your readme stating that the current WeiDU may be downloaded
from <insert link>. Current authorized mirrors include (but may not be limited to)
all those from IEGMC, the Dragon's Hoard Download Centre, and the SHS Download Centre.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Undocumented Features}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Currently undocumented:
\begin{itemize}
\item {\tt IF!EVAL}.
\item {\tt REPLACE!BCS!BLOCK!REGEXP}.
\item Fred's BCS diff stuff.
\item {\tt EXTEND!MOS}.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Index of Terms}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\printindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Changes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
See the file
\ahrefurl{{README-WeiDU-Changes.txt}}
for a description of how WeiDU
has changed over time.
\end{document}
